#+STARTUP: overview
#+TITLE: emacs.d config

* Better defaults
** Start Up
#+BEGIN_SRC emacs-lisp
(server-start) ; Start emacs server
;(desktop-save-mode 1) ; Save session and restore on next launch
#+END_SRC

** UI
#+BEGIN_SRC emacs-lisp
(setq inhibit-startup-screen t) ; inhibit useless and old-school startup screen
(setq ring-bell-function 'ignore) ; silent bell when you make a mistake
(setq-default frame-title-format '("%b - Emacs")) ; set the emacs title.
                                        ; overrides the old "emacs@HOST" title
(set-frame-font "Liberation Mono 7" t t)
;(set-frame-font "Unifont 12" t t)
(menu-bar-mode -1)

;; Disable these in termux mode
(defvar circ/termux-p 'nil)
(unless circ/termux-p
  (mouse-avoidance-mode 'animate)
  (tool-bar-mode -1)
  (scroll-bar-mode -1))
(when circ/termux-p
  (defun circ/termux-open (args)
    (interactive)
    (if (not (listp args))
        (setq args (list args)))
    (apply 'call-process "termux-open" nil nil nil args))
  (defun circ/browse-url-browser-function (url &rest args)
    (interactive)
    (circ/termux-open url))

  (setq browse-url-browser-function
    'circ/browse-url-browser-function))

(load-theme 'wheatgrass)
; Split vertically by default
(setq split-width-threshold 160)
(setq split-height-threshold 100)
(setq-default fill-column 80)
(setq calendar-week-start-day 1)

;; Keep point in same position relative to window when scrolling
(setq scroll-preserve-screen-position t)

;; Don't use proportional fonts in eww
(setq shr-use-fonts nil)

;; Use emacs to put in gpg password
(setq epa-pinentry-mode 'loopback)
#+END_SRC

** Display buffer behaviour
#+begin_src emacs-lisp
(setq display-buffer-alist
      '(("^\\*Proced\\*$"
         (display-buffer-same-window))
        ("^\\*Help\\*$"
         (display-buffer-reuse-window display-buffer-in-side-window)
         (side . right)
         (window-width . 86))
        ("^\\*Annotate.*"
         (display-buffer-same-window))
        ;; the function `org-fit-window-to-buffer' overrides the window height
        ;; Re-define the function if you want to enforce a height
        ("^ \\*Org todo\\*$"
         (display-buffer-in-side-window)
         (side . bottom)
         (window-height . 999))
        ;; the function `org-fit-window-to-buffer' overrides the window height
        ;; Re-define the function if you want to enforce a height
        ("^\\*Org Select\\*$"
         (display-buffer-in-side-window)
         (side . bottom)
         (window-height . 999))
        ("^\\*Capture\\*$"
         (display-buffer-in-side-window)
         (side . bottom)
         (window-height . 15))
        ("^CAPTURE-"
         (display-buffer-in-side-window)
         (side . bottom)
         (window-height . 15))
        ("^\\*Org Src "
         (display-buffer-same-window))
        ))
#+end_src

** Tab Behaviour
#+BEGIN_SRC emacs-lisp
(setq-default indent-tabs-mode nil) ; don't insert tabs
(setq-default tab-width 4) ; self-documenting
(setq indent-line-function 'insert-tab)
#+END_SRC

** Backup and autosave locations
#+BEGIN_SRC emacs-lisp
(setq auto-save-visited-file-name t)
(setq auto-save-default nil)
(setq backup-directory-alist '((".*" . "~/.emacs.d/backup")))
(setq auto-save-file-name-transforms '((".*" "~/.emacs.d/autosave/" t)))
#+END_SRC

** Default major mode
#+BEGIN_SRC emacs-lisp
(setq-default major-mode 'org-mode)
#+END_SRC

* Whitespace
Force it on all the time.

Highlights:
- face visualisation
- empty lines at beginning of end of buffer
- tabs
- tailing blanks

#+BEGIN_SRC emacs-lisp
(require 'whitespace)
(setq whitespace-style '(face empty tabs trailing))
(global-whitespace-mode t)
#+END_SRC

* Org
** Load latest org and contribs:
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/org-9.4.4/lisp")
(add-to-list 'load-path "~/.emacs.d/packages/org-9.4.4/contrib/lisp")
(add-to-list 'load-path "~/.emacs.d/packages/persist-0.4") ; for org-drill
(add-to-list 'load-path "~/.emacs.d/packages/org-drill-35c1ce349949cc213f3076799211210f49431850")
(org-reload)
#+END_SRC

** Org settings
#+BEGIN_SRC emacs-lisp
(setq org-html-postamble "<p class=\"created\">Created: %T</p>")
(setq org-src-fontify-natively t)
(setq org-src-tab-acts-natively t)
(setq org-startup-folded nil) ; Start org mode expanded
(setq org-startup-with-inline-images t) ; Show images by default
(setq org-startup-indented nil)
(setq org-hide-leading-stars t)
(setq org-edit-src-content-indentation 0)
(setq org-clock-into-drawer "CLOCK")
(setq org-use-property-inheritance t)
(setq org-clock-mode-line-total 'current)
(setq org-agenda-window-setup 'current-window)
(setq org-agenda-sticky t)
(setq org-log-done 'time)
(setq org-agenda-skip-scheduled-if-done t)
(setq org-agenda-skip-deadline-if-done t)
(setq org-src-window-setup 'plain) ; Use display-buffer-alist settings
(setq org-time-stamp-rounding-minutes '(1 1))
(setq org-clock-out-when-done nil)
(setq org-log-into-drawer "LOGBOOK")
(setq org-agenda-hide-tags-regexp ".*")
(setq org-catch-invisible-edits 'show-and-error)
(setq org-adapt-indentation nil)

;(setq org-clock-persist 'clock)
;(org-clock-persistence-insinuate)

(add-to-list 'org-link-frame-setup '(file . find-file))

;; Enable habit tracking in org-mode
(require 'org-habit)
(add-to-list 'org-modules 'org-habit)
(require 'org-drill)
(add-to-list 'org-modules 'org-drill)
(setq org-drill-add-random-noise-to-intervals-p t)

;; Don't show any habits in the agenda, there is a dedicated section for that.
(setq org-habit-show-habits nil)
(setq org-habit-show-habits-only-for-today nil)
(setq org-habit-show-all-today nil)

;; Set up languages for running code blocks in org
;; In version 9.0.9, ob-sh was renamed to ob-shell
(org-babel-do-load-languages
 'org-babel-load-languages
 (cond
  ((version< org-version "9.0.9")
   '((python . t)
     (sh . t)
     (dot . t)
     (emacs-lisp . t)))
  (t
   '((python . t)
     (shell . t)
     (dot . t)
     (emacs-lisp . t)))))

;; Set clock checks
(setq org-agenda-clock-consistency-checks
      (quote (:max-duration "4:00"
              :min-duration 0
              :max-gap 0
              :gap-ok-around ("4:00"))))

(add-to-list 'org-file-apps '("\\.mkv\\'" . "mpv %s"))
#+END_SRC

** Line wrap mode
#+BEGIN_SRC emacs-lisp
(defun org-mode-startup-functions ()
  (toggle-word-wrap 1)
  (toggle-truncate-lines -1))

(add-hook 'org-mode-hook 'org-mode-startup-functions)

(defun org-agenda-mode-startup-functions ()
  (hl-line-mode +1)
  (evil-quickscope-mode 0))

(add-hook 'org-agenda-mode-hook 'org-agenda-mode-startup-functions)
(add-hook 'org-agenda-mode-hook 'circ/disable-evil-quickscope-mode)
#+END_SRC

** Fix the =\emsp= bug in clock tables.
 #+BEGIN_SRC emacs-lisp
 (defun circ/org-clocktable-indent-string (level)
   (if (= level 1)
       ""
     (let ((str "^"))
       (while (> level 2)
         (setq level (1- level)
               str (concat str "--")))
       (concat str "-> "))))

 (advice-add 'org-clocktable-indent-string :override
             #'circ/org-clocktable-indent-string)
 #+END_SRC

** Beautifying org-mode
Credits:
zzamboni - https://zzamboni.org/post/beautifying-org-mode-in-emacs/#step-4-configure-faces-for-specific-org-elements

Hide the markup for various emphasis'
#+BEGIN_SRC emacs-lisp
(setq org-hide-emphasis-markers t)
#+END_SRC

Set up nice fonts
#+BEGIN_SRC emacs-lisp
(let* ((base-font-color  (face-foreground 'default nil 'default))
       (headline        `(:inherit    default
                          :weight     bold
                          :foreground ,base-font-color)))

  (custom-theme-set-faces
   'user
   `(org-document-title   ((t (,@headline :height 1.00 :underline t))))
   `(org-level-1          ((t (,@headline :height 1.00 :foreground "#e6194b"))))
   `(org-level-2          ((t (,@headline :height 1.00 :foreground "#3cb44b"))))
   `(org-level-3          ((t (,@headline :height 1.00 :foreground "#ffe119"))))
   `(org-level-4          ((t (,@headline :height 1.00 :foreground "#4363d8"))))
   `(org-level-5          ((t (,@headline :height 1.00 :foreground "#f58231"))))
   `(org-level-6          ((t (,@headline :height 1.00 :foreground "#911eb4"))))
   `(org-level-7          ((t (,@headline :height 1.00 :foreground "#42d4f4"))))
   `(org-level-8          ((t (,@headline :height 1.00 :foreground "#f032e6"))))
   `(org-block-background ((t (:height 1.00 :background "#222222"))))
   `(org-block            ((t (:height 1.00 :background "#222222"))))
   `(org-block-begin-line ((t (:height 1.00 :foreground "#222222" :background "#070707"))))
   `(org-block-end-line   ((t (:height 1.00 :foreground "#222222" :background "#070707"))))
))
#+END_SRC

** Notifications
Send agenda appointment desktop notifications.

#+BEGIN_SRC emacs-lisp
(setq appt-message-warning-time 15)
(setq appt-display-interval 5)
(setq appt-display-mode-line nil)
(setq appt-disp-window-function 'circ/appt-display)
(setq appt-delete-window-function (lambda () t))

;; Pre-defined functions for formatting
(defun circ/format-appt-notify-msg-simple (mins-to-appt curr-time msg)
  (format "%s: %s in %s mins" curr-time msg mins-to-appt))

;; Pre-defined functions for different notification systems
(defun circ/format-appt-notify-cmd-desktop (message)
  (format "timeout 0.2 notify-send -t 0 \"%s\"" message))
(defun circ/format-appt-notify-cmd-termux (message)
  (format "timeout 5 termux-notification -t \"%s\"" message))

(defvar circ/format-appt-notify-msg nil)
(defvar circ/format-appt-notify-cmd nil)

; Notifcations not working? Try using some of these
; (setq circ/format-appt-notify-msg 'circ/format-appt-notify-msg-simple)
; (setq circ/format-appt-notify-cmd 'circ/format-appt-notify-cmd-desktop)
; (setq circ/format-appt-notify-cmd 'circ/format-appt-notify-cmd-termux)

(defun circ/refresh-appointments ()
  (interactive)
  (setq appt-time-msg-list nil)
  (org-agenda-to-appt))

(defun circ/appt-display (mins-to-appt curr-time msg)
  "Sends a notification to the noticiation daemon. Has a
hardcoded 200ms timeout in case no notification service is alive"
  (when (and circ/format-appt-notify-msg
             circ/format-appt-notify-cmd
             msg)
    (let* ((head-msg (cond ((listp msg) (car msg))
                           (t msg)))
           (head-mins (cond ((listp mins-to-appt) (car mins-to-appt))
                            (t mins-to-appt)))
           (message (funcall circ/format-appt-notify-msg head-mins curr-time head-msg))
           (command (funcall circ/format-appt-notify-cmd message)))
      (when (< 0 (shell-command command))
        (user-error "Appointment notification failed"))
      (message "Notification: %s" message))
    (when (and (listp msg) msg)
      (circ/appt-display (cdr mins-to-appt) curr-time (cdr msg)))))

(defun circ/expanded-org-agenda-files ()
  (mapcar 'expand-file-name org-agenda-files))

(defun circ/org-agenda-file-p (&optional file)
  (member (or file (buffer-file-name)) (circ/expanded-org-agenda-files)))

(defun circ/maybe-refresh-appts ()
  (when (circ/org-agenda-file-p)
    (circ/refresh-appointments)))

;; Generate appointments on startup
(circ/refresh-appointments)
;; Regenerate at 00:05, so you can leave emacs open over night
(run-at-time "00:05" (* 60 60 24) 'circ/refresh-appointments)
;; Generate appointments when you save an agenda file
(add-hook 'after-save-hook 'circ/maybe-refresh-appts)
(add-hook 'after-revert-hook 'circ/maybe-refresh-appts)
#+END_SRC

** Tag cloud for org mode
#+BEGIN_SRC emacs-lisp
(defvar-local circ/org-agenda-filter-list nil)

(defun circ/agenda-count-tags ()
  (interactive)
  (save-excursion
    (goto-char (point-min))
    (let ((count-alist '())
          (last-pos 0))
      (while (not (= last-pos (progn
                                (ignore-errors (org-agenda-next-item 1))
                                (move-beginning-of-line nil))))
        (setq last-pos (point))
        (dolist (tag (org-get-at-bol 'tags))
          (let* ((alist-val (assoc tag count-alist))
                 (count (cond ((not alist-val) 0)
                              (t (cdr alist-val)))))
            (setq count-alist (circ/alist-set tag (1+ count) count-alist)))))
      count-alist)))

(defun circ/agenda-format-tag-cloud (tag-alist)
  (interactive)
  (let ((string "  ")
        (text-width (window-text-width))
        (line-length 0))
    (dolist (tag (sort tag-alist (lambda (a b) (> (cdr a) (cdr b)))))
      (let ((tag-name (propertize (car tag) 'face 'org-tag))
            (tag-count (cdr tag)))
        (unless (member tag-name '("proj" "ordered"))
          (let ((tag-string (format "%s (%s)  " tag-name tag-count)))
            ;; Magic number 3 to help avoid the overflow icon. Sometimes, if the
            ;; tags are just right, the tag cloud will show an icon that
            ;; indicates there is more text off the side of the buffer. I don't
            ;; ever want that, because it makes me wonder if any tags are
            ;; missing from my immediate view.
            (cond ((> (+ line-length (length tag-string) 3) text-width)
                   (setq string (concat string "\n  " tag-string))
                   (setq line-length (+ (length tag-string) 2)))
                  (t
                   (setq string (concat string tag-string))
                   (setq line-length (+ line-length (length tag-string)))))))))
    string))

(defun circ/alist-set (key val alist &optional symbol)
  "Set property KEY to VAL in ALIST. Return new alist.
This creates the association if it is missing, and otherwise sets
the cdr of the first matching association in the list. It does
not create duplicate associations. By default, key comparison is
done with `equal'. However, if SYMBOL is non-nil, then `eq' is
used instead.

This method may mutate the original alist, but you still need to
use the return value of this method instead of the original
alist, to ensure correct results."
  (if-let ((pair (if symbol (assq key alist) (assoc key alist))))
      (setcdr pair val)
    (push (cons key val) alist))
  alist)

(defun circ/org-agenda-insert-tag-cloud ()
  (interactive)
  ;; Check the buffer name and the existance of a "===" line.
  (when (and (string= (buffer-name) "*Org Agenda(T)*")
             (save-excursion
               (goto-char (point-min))
               (search-forward-regexp "^==*" nil t)))
    (save-excursion
      (read-only-mode 0)
      ;; Remove tags if exists
      (goto-char (point-min))
      (when (ignore-errors (search-forward-regexp "^Tag Cloud"))
        (search-forward-regexp "^\*\**\n")
        (move-beginning-of-line 2)
        (delete-region (point-min) (point)))

      (goto-char (point-min))
      (insert (propertize (format
                           "Tag Cloud (%s)\n"
                           (string-join circ/org-agenda-filter-list " "))
                          'face 'org-agenda-structure)
              (circ/agenda-format-tag-cloud (circ/agenda-count-tags)) "\n\n"
              (make-string (window-width) ?*) "\n")
      (read-only-mode 1))))

;; Could improve performance by caching the alist from `circ/agenda-count-tags'
;; but there is some problem with setting it. It doesn't set correcly. Don't
;; know why.
(defun circ/org-agenda-filter-tag ()
  (interactive)
  (let* ((tag-list (mapcar 'car (circ/agenda-count-tags)))
         (tag-candidates (remove-duplicates
                          (append (mapcar (lambda (tag) (concat "+" tag)) tag-list)
                                  (mapcar (lambda (tag) (concat "-" tag)) tag-list)
                                  circ/org-agenda-filter-list)
                          :test 'string=))
         (new-tag (completing-read "Tag: " tag-candidates)))
    (cond ((member new-tag circ/org-agenda-filter-list)
           (setq circ/org-agenda-filter-list (remove new-tag circ/org-agenda-filter-list))
           (circ/org-agenda-show-all-tags))
          (t
           (setq circ/org-agenda-filter-list (cons new-tag circ/org-agenda-filter-list))))
    (circ/org-agenda-apply-filter)))

(defun circ/org-agenda-apply-filter ()
  (interactive)
  (org-agenda-filter-apply circ/org-agenda-filter-list 'tag)
  (run-hooks 'org-agenda-filter-hook))

(defun circ/org-agenda-show-all-tags ()
  (interactive)
  (setq circ/org-agenda-filter-list nil)
  (org-agenda-filter-show-all-tag)
  (run-hooks 'org-agenda-filter-hook))

(defun circ/org-agenda-redo ()
  (interactive)
  (let ((filter-list circ/org-agenda-filter-list))
    (org-agenda-redo)
    (setq circ/org-agenda-filter-list filter-list)
    (circ/org-agenda-apply-filter)))

(add-hook 'org-agenda-finalize-hook 'circ/org-agenda-insert-tag-cloud)
(add-hook 'org-agenda-filter-hook 'circ/org-agenda-insert-tag-cloud)
#+END_SRC
** Org capture
*** Set a custom header
Override the current org-capture header by assigning a new header after the mode
is loaded.

#+BEGIN_SRC emacs-lisp
(defun circ/set-org-capture-mode-header ()
  (setq-local header-line-format
   (substitute-command-keys
    "\\<org-capture-mode-map>Capture buffer.  Finish \
[q] / [\\[org-capture-finalize]], refile [\\[org-capture-refile]], \
abort [Q] / [\\[org-capture-kill]].")))
(add-hook 'org-capture-mode-hook 'circ/set-org-capture-mode-header)
#+END_SRC
** Org 9.4.4 options
#+BEGIN_SRC emacs-lisp
(unless (version< org-version "9.2.0")
  (setq org-structure-template-alist '(("a" . "export ascii")
                                       ("c" . "center")
                                       ("C" . "comment")
                                       ("e" . "example")
                                       ("E" . "export")
                                       ("h" . "export html")
                                       ("l" . "export latex")
                                       ("q" . "quote")
                                       ("s" . "src")
                                       ("v" . "verse")))
  (require 'org-tempo))
#+END_SRC
** Force org mode to display buffers my way
Requires rules in =display-buffer-alist= to work properly.
=org-fit-window-to-buffer= overrides some display-buffer-alist rules. I am keeping
the call to =org-fit-window-to-buffer= because I like the behaviour.
*** Redefine =org-switch-to-buffer-other-window=
#+begin_src emacs-lisp
(defun circ/org-switch-to-buffer-other-window (&rest args)
  "Redefinition of `org-switch-to-buffer-other-window' to force
org to abide by `display-buffer-alist'"
  (apply #'switch-to-buffer-other-window args))

(advice-add 'org-switch-to-buffer-other-window :override
            #'circ/org-switch-to-buffer-other-window)
#+end_src
*** Redefine =org-capture-place-template= to not delete other windows
#+begin_src emacs-lisp
(defun circ/org-capture-place-template (&optional inhibit-wconf-store)
  "Insert the template at the target location, and display the buffer.
When `inhibit-wconf-store', don't store the window configuration, as it
may have been stored before."
  (unless inhibit-wconf-store
    (org-capture-put :return-to-wconf (current-window-configuration)))
  ;; ----------------------------------------------------------
  ;; Don't delete other windows. Just be a normal buffer
  ;; (delete-other-windows)
  ;; ----------------------------------------------------------
  (org-switch-to-buffer-other-window
   (org-capture-get-indirect-buffer (org-capture-get :buffer) "CAPTURE"))
  (widen)
  (org-show-all)
  (goto-char (org-capture-get :pos))
  (setq-local outline-level 'org-outline-level)
  (pcase (org-capture-get :type)
    ((or `nil `entry) (org-capture-place-entry))
    (`table-line (org-capture-place-table-line))
    (`plain (org-capture-place-plain-text))
    (`item (org-capture-place-item))
    (`checkitem (org-capture-place-item)))
  (setq-local org-capture-current-plist org-capture-plist)
  (org-capture-mode 1))

(advice-add 'org-capture-place-template :override
            #'circ/org-capture-place-template)
#+end_src
*** Redefine =org-fast-todo-selection= to not delete other windows
#+begin_src emacs-lisp
(defun circ/org-fast-todo-selection (&optional current-state)
  "Fast TODO keyword selection with single keys.
Returns the new TODO keyword, or nil if no state change should occur.
When CURRENT-STATE is given and selection letters are not unique globally,
prefer a state in the current sequence over on in another sequence."
  (let* ((fulltable org-todo-key-alist)
	 (head (org-get-todo-sequence-head current-state))
	 (done-keywords org-done-keywords) ;; needed for the faces.
	 (maxlen (apply 'max (mapcar
			      (lambda (x)
				(if (stringp (car x)) (string-width (car x)) 0))
			      fulltable)))
	 (expert (equal org-use-fast-todo-selection 'expert))
	 (prompt "")
	 (fwidth (+ maxlen 3 1 3))
	 (ncol (/ (- (window-width) 4) fwidth))
	 tg cnt e c tbl subtable
	 groups ingroup in-current-sequence)
    (save-excursion
      (save-window-excursion
	(if expert
	    (set-buffer (get-buffer-create " *Org todo*"))
      ;; ----------------------------------------------------------
      ;; Don't delete other windows. Just be a normal buffer
      ;; And don't split any buffers up.
	  ;; (delete-other-windows)
	  ;; (set-window-buffer (split-window-vertically) (get-buffer-create " *Org todo*"))
      ;; ----------------------------------------------------------
	  (org-switch-to-buffer-other-window " *Org todo*"))
	(erase-buffer)
	(setq-local org-done-keywords done-keywords)
	(setq tbl fulltable cnt 0)
	(while (setq e (pop tbl))
	  (cond
	   ((equal e '(:startgroup))
	    (push '() groups) (setq ingroup t)
	    (unless (= cnt 0)
	      (setq cnt 0)
	      (insert "\n"))
	    (setq prompt (concat prompt "{"))
	    (insert "{ "))
	   ((equal e '(:endgroup))
	    (setq ingroup nil cnt 0 in-current-sequence nil)
	    (setq prompt (concat prompt "}"))
	    (insert "}\n"))
	   ((equal e '(:newline))
	    (unless (= cnt 0)
	      (setq cnt 0)
	      (insert "\n")
	      (setq e (car tbl))
	      (while (equal (car tbl) '(:newline))
		(insert "\n")
		(setq tbl (cdr tbl)))))
	   (t
	    (setq tg (car e) c (cdr e))
	    (if (equal tg head) (setq in-current-sequence t))
	    (when ingroup (push tg (car groups)))
	    (when in-current-sequence (push e subtable))
	    (setq tg (org-add-props tg nil 'face
				    (org-get-todo-face tg)))
	    (when (and (= cnt 0) (not ingroup)) (insert "  "))
	    (setq prompt (concat prompt "[" (char-to-string c) "] " tg " "))
	    (insert "[" c "] " tg (make-string
				   (- fwidth 4 (length tg)) ?\ ))
	    (when (and (= (setq cnt (1+ cnt)) ncol)
		       ;; Avoid lines with just a closing delimiter.
		       (not (equal (car tbl) '(:endgroup))))
	      (insert "\n")
	      (when ingroup (insert "  "))
	      (setq cnt 0)))))
	(insert "\n")
	(goto-char (point-min))
	(unless expert (org-fit-window-to-buffer))
	(message (concat "[a-z..]:Set [SPC]:clear"
			 (if expert (concat "\n" prompt) "")))
	(setq c (let ((inhibit-quit t)) (read-char-exclusive)))
	(setq subtable (nreverse subtable))
	(cond
	 ((or (= c ?\C-g)
	      (and (= c ?q) (not (rassoc c fulltable))))
	  (setq quit-flag t))
	 ((= c ?\ ) nil)
	 ((setq e (or (rassoc c subtable) (rassoc c fulltable))
		tg (car e))
	  tg)
	 (t (setq quit-flag t)))))))

(advice-add 'org-fast-todo-selection :override
            #'circ/org-fast-todo-selection)
#+end_src
** Fix M-S-j/k when changing timestamps on newly opened buffer
#+begin_src emacs-lisp
(add-hook 'org-mode-hook 'evil-normalize-keymaps)
#+end_src
* Mode Line
#+BEGIN_SRC emacs-lisp
(column-number-mode 1) ; show column number
(set-face-attribute 'mode-line nil ; Set active mode line colour
                    :foreground "white"
                    :background "darkgreen")
(set-face-attribute 'mode-line-buffer-id nil ; Set buffer id colour
                    :foreground "white"
                    :background "black")
#+END_SRC

* Custom Functions
** Helper Functions
#+BEGIN_SRC emacs-lisp
(defun circ/strip-last-newline (string)
  (replace-regexp-in-string "\n\\'" "" string))

(defun circ/escape-double-quotes (string)
  (replace-regexp-in-string "\"" "\\\\\"" string))

(defun circ/strip-font-properties (string)
  (set-text-properties 0 (length string) nil string)
  string)
#+END_SRC

** eshell-new
Interative function to create a new instance of eshell.

#+BEGIN_SRC emacs-lisp
(defun circ/eshell-new ()
  "Open a new instance of eshell."
  (interactive)
  (eshell 'N))
#+END_SRC

** transpose-buffers
Transpose two buffers.

#+BEGIN_SRC emacs-lisp
(defun circ/transpose-buffers (dir &optional arg)
  "Transpose the buffers in the current window and the target window
If arg is non-nil, the selected window will change to keep the source buffer
selected."
  (let ((target-window (windmove-find-other-window dir))
        (source-window (selected-window)))
    (cond ((null target-window)
           (format "No window found in dir %s" dir))
          ((and (window-minibuffer-p target-window)
                (not (minibuffer-window-active-p target-window)))
           (user-error "Minibuffer is inactive"))
          (t
           (let ((target-buffer (window-buffer target-window))
                 (source-buffer (window-buffer)))
             (set-window-buffer target-window source-buffer)
             (set-window-buffer source-window target-buffer))
           (if arg
               (select-window target-window))))))

(defun circ/transpose-buffers-left (&optional arg)
    "Transpose buffers from current window to buffer to the left"
  (interactive)
  (circ/transpose-buffers 'left arg))

(defun circ/transpose-buffers-up (&optional arg)
    "Transpose buffers from current window to buffer above"
  (interactive)
  (circ/transpose-buffers 'up arg))

(defun circ/transpose-buffers-right (&optional arg)
    "Transpose buffers from current window to buffer to the right"
  (interactive)
  (circ/transpose-buffers 'right arg))

(defun circ/transpose-buffers-down (&optional arg)
    "Transpose buffers from current window to buffer below"
  (interactive)
  (circ/transpose-buffers 'down arg))
#+END_SRC

** cast-buffer
Send a buffer to another window.

#+BEGIN_SRC emacs-lisp
(defun circ/cast-buffer (dir &optional arg)
  "Casts the current buffer to window in direction dir, and switches current
window back to last buffer.
If arg is non-nil, the targetted window is selected."
  (let ((target-window (windmove-find-other-window dir))
        (source-buffer (window-buffer)))
    (cond ((null target-window)
           (format "No window found in dir %s" dir))
          ((and (window-minibuffer-p target-window)
                (not (minibuffer-window-active-p target-window)))
           (user-error "Minibuffer is inactive"))
          (t
           (set-window-buffer target-window source-buffer)
           (previous-buffer)
           (if arg
               (select-window target-window))))))

(defun circ/cast-buffer-left (&optional arg)
  "Cast current buffer to the left"
  (interactive)
  (circ/cast-buffer 'left arg))

(defun circ/cast-buffer-up (&optional arg)
  "Cast current buffer up"
  (interactive)
  (circ/cast-buffer 'up arg))

(defun circ/cast-buffer-right (&optional arg)
  "Cast current buffer to the right"
  (interactive)
  (circ/cast-buffer 'right arg))

(defun circ/cast-buffer-down (&optional arg)
  "Cast current buffer down"
  (interactive)
  (circ/cast-buffer 'down arg))
#+END_SRC

** duplicate-buffer
Open buffer in another window.

#+BEGIN_SRC emacs-lisp
(defun circ/duplicate-buffer (dir &optional arg)
  "Opens the current buffer in the window in the direction dir
If arg is non-nil, the targeted window is selected"
  (let ((target-window (windmove-find-other-window dir))
        (source-buffer (window-buffer)))
    (cond ((null target-window)
           (format "No window found in dir %s" dir))
          ((and (window-minibuffer-p target-window)
                (not (minibuffer-window-active-p target-window)))
           (user-error "Minibuffer is inactive"))
          (t
           (set-window-buffer target-window source-buffer)
           (if arg
               (select-window target-window))))))

(defun circ/duplicate-buffer-left (&optional arg)
  "Cast current buffer to the left"
  (interactive)
  (circ/duplicate-buffer 'left arg))

(defun circ/duplicate-buffer-up (&optional arg)
  "Cast current buffer up"
  (interactive)
  (circ/duplicate-buffer 'up arg))

(defun circ/duplicate-buffer-right (&optional arg)
  "Cast current buffer to the right"
  (interactive)
  (circ/duplicate-buffer 'right arg))

(defun circ/duplicate-buffer-down (&optional arg)
  "Cast current buffer down"
  (interactive)
  (circ/duplicate-buffer 'down arg))
#+END_SRC

** regenerate-tags
Regenerate tags using a command defined in the project root under the =.emacs=
directory.

#+BEGIN_SRC emacs-lisp
(defun circ/regenerate-tags ()
  "use the generate-tags script in the project root to generate tags"
  (interactive)
  (cond ((projectile-project-root)
         (let* ((root-dir (projectile-project-root))
                (generate-tags-script (concat root-dir ".emacs/generate-tags"))
                (tag-command (concat ". " generate-tags-script " " root-dir))
                (result (if (file-exists-p generate-tags-script)
                            (shell-command-to-string tag-command)
                          (projectile-regenerate-tags))))
           (message result)))
        (t
         (user-error "Not in a project!"))))
#+END_SRC

** open-terminal-in-workdir
Opens a konsole in the current project root. If not in project, opens it in the
current directory.

#+BEGIN_SRC emacs-lisp
(defun circ/open-terminal-in-workdir ()
 "Opens a terminal in the project root.
If not in a project, opens it in the current directory."
 (interactive)
 (let ((workdir (if (projectile-project-root)
                    (projectile-project-root)
                  default-directory)))
   (call-process-shell-command
    (concat "konsole --workdir " workdir) nil 0)))
#+END_SRC

** whitespace-mode
Toggle on and off whitespace trailing mode

#+BEGIN_SRC emacs-lisp
(defun circ/toggle-whitespace-full ()
  "toggle display of more whitespace"
  (interactive)
  (whitespace-toggle-options '(lines-tail)))
#+END_SRC

** alignment functions
#+BEGIN_SRC emacs-lisp
(defun circ/align-once-head (start end regexp)
  "Align by regex once, adding spaces to the head of the regexp"
  (interactive "r\nsAlign once head regexp: ")
  (align-regexp start end
                (concat "\\(\\s-*\\)" regexp) 1 1 nil))

(defun circ/align-once-tail (start end regexp)
  "Align by regex once, adding spaces to the tail of the regexp"
  (interactive "r\nsAlign once tail regexp: ")
  (align-regexp start end
                (concat regexp "\\(\\s-*\\)") 1 1 nil))

(defun circ/align-repeat-head (start end regexp)
  "Align by regex repeatedly, adding spaces to the head of the regexp"
  (interactive "r\nsAlign repeat head regexp: ")
  (align-regexp start end
                (concat "\\(\\s-*\\)" regexp) 1 1 t))

(defun circ/align-repeat-tail (start end regexp)
  "Align by regex repeatedly, adding spaces to the tail of the regexp"
  (interactive "r\nsAlign repeat tail regexp: ")
  (align-regexp start end
                (concat regexp "\\(\\s-*\\)") 1 1 t))
#+END_SRC

** file opener functions
Some extra functions to aid in opening files

#+BEGIN_SRC emacs-lisp
(defun circ/find-file-line (filename linenum)
  "invoke function find-file and goto-line"
  (find-file filename)
  (goto-line linenum))
#+END_SRC

The =find-file-line= function expects two args. We just therefore parse any
FILENAME:LINENUMBER string that it uses.

#+BEGIN_SRC emacs-lisp
(defun circ/parse-file-special-syntax (file-string)
  "parses the format FILENAME:LINENUMBER"
  (let* ((file-list (split-string file-string ":"))
         (filename (car file-list))
         (line-number (string-to-number(cadr file-list))))
    (list filename line-number)))
#+END_SRC

We also want the ability to parse dirty file paths.

#+BEGIN_SRC emacs-lisp
(defun circ/clean-file-path (file-string)
  "cleans the file path"
  (replace-regexp-in-string
   "^.*:[0-9]*\\(.*\\)$"
   ""
   file-string
   nil nil 1))
#+END_SRC

Plus we need a function to tie it all together.

#+BEGIN_SRC emacs-lisp
(defun circ/find-file-special-syntax (file-string)
  "opens special syntax"
  (apply 'circ/find-file-line
         (circ/parse-file-special-syntax
          (circ/clean-file-path file-string))))
#+END_SRC

** open-in-intellij
Helpful function to open the current buffer and line in intellij.

The complimentary command for intellij is:
#+BEGIN_SRC sh
emacsclient -n +$LINENUMBER$:$COLUMN$ $FILE$
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun circ/open-in-intellij ()
  "Open the current file + line in intellij"
  (interactive)
  (let* ((file (buffer-file-name))
         (line-num (number-to-string (line-number-at-pos)))
         (command (concat "idea " file ":" line-num)))
    (shell-command command)
    (message "file opened in intellij")))
#+END_SRC

** check-project
Compile / check the project and send results to ivy-read.

Expects results in the format:

#+BEGIN_EXAMPLE
FILENAME:100 explanation
FILENAME:200 explanation
FILENAME:40can also be dirty
#+END_EXAMPLE

#+BEGIN_SRC emacs-lisp
(defun circ/check-project ()
  "run .emacs/check-project and put results in ivy-read"
  (interactive)
  (cond ((projectile-project-root)
         (message "Checking project...")
         (let* ((root-dir (projectile-project-root))
                (script (concat root-dir ".emacs/check-project"))
                (command (concat ". " script " " root-dir))
                (result (shell-command-to-string command)))
           (cond ((> (length result) 0)
                  (completing-read "Check project results: "
                                   (split-string result "\n")
                                   :action 'circ/find-file-special-syntax))
                 (t
                  (user-error "Check complete")))))
        (t
         (user-error "Not in a project!"))))
#+END_SRC

** show-file-path
Show the full file path as a message

#+BEGIN_SRC emacs-lisp
(defun circ/show-file-path ()
  "Show full file path as a message"
  (interactive)
  (if buffer-file-name
      (message buffer-file-name)
    (message "No valid file path")))
#+END_SRC

** show-buffer-name
In case the header is overwritten

#+begin_src emacs-lisp
(defun circ/show-buffer-name ()
  "Show buffer name as a message"
  (interactive)
  (message "%s" (buffer-name)))
#+end_src

** smart-clear-buffer
Clear the buffer, but with special cases for certain major modes.

#+BEGIN_SRC emacs-lisp
(defun circ/smart-clear-buffer ()
  "Clear the current buffer. term-mode requires different command to clear."
  (interactive)
  (case major-mode
    ('term-mode (comint-clear-buffer))
    (otherwise (erase-buffer))))
#+END_SRC

** Revert project buffers
Revert all the buffers in the current project.

#+BEGIN_SRC emacs-lisp
(defun circ/revert-project-buffers ()
  (interactive)
  (let* ((project (projectile-ensure-project (projectile-project-root)))
         (project-buffers (projectile-project-buffers project))
         (buffers (remove-if-not 'buffer-file-name project-buffers)))
    (dolist (buffer buffers)
      (with-current-buffer buffer
        (ignore-errors (revert-buffer nil t))
        (message "Reverted: %s" buffer)))
    (message "Project buffers reverted")))
#+END_SRC
** Save all project buffers
#+BEGIN_SRC emacs-lisp
(defun circ/save-project-buffers ()
  (interactive)
  (let* ((project (projectile-ensure-project (projectile-project-root)))
         (project-buffers (projectile-project-buffers project))
         (buffers (remove-if-not 'buffer-file-name project-buffers)))
    (dolist (buffer buffers)
      (with-current-buffer buffer
        (save-buffer)
        (message "Saved: %s" buffer)))
    (message "Project buffers saved")))
#+END_SRC
** Org Set Property
#+BEGIN_SRC emacs-lisp
(defun circ/org-set-property (property &optional val)
  (interactive)
  (let* ((current-value (org-entry-get nil property))
         (value (cond (val val)
                      (t (read-string (format "Set property %s: " property)
                                      current-value)))))
    (org-entry-put nil property value)))
#+END_SRC
** Org file reference
#+BEGIN_SRC emacs-lisp
(defun circ/org-file-reference ()
  (interactive)
  (let* ((target-file (expand-file-name
                       (completing-read "File reference (C-M-j to done): "
                                        (mapcar (lambda (filepath)
                                                  (file-relative-name
                                                   filepath
                                                   circ/org-reference-directory))
                                                (directory-files-recursively
                                                 circ/org-reference-directory
                                                 ".*\.org"
                                                 nil)))
                       circ/org-reference-directory))
         (org-heading (org-get-heading)))
    (org-back-to-heading)
    (org-cut-subtree)

    (find-file target-file)
    (let ((target-buffer (get-file-buffer target-file)))
      (unless (file-exists-p target-file)
        (make-directory (file-name-directory target-file) t)
        (with-current-buffer target-buffer
          (insert (concat "#+TITLE: " org-heading))
          (newline))
        (message "Created file"))
      (with-current-buffer target-buffer
        (end-of-buffer)
        (newline)
        (yank)
        (save-buffer)))))
#+END_SRC
** Buffer yank paste
#+BEGIN_SRC emacs-lisp
(setq circ/buffer-clipboard nil)

(defun circ/buffer-yank ()
  (interactive)
  (setq circ/buffer-clipboard (current-buffer)))

(defun circ/buffer-paste ()
  (interactive)
  (when circ/buffer-clipboard
    (set-window-buffer (selected-window) circ/buffer-clipboard)))
#+END_SRC
** Kill buffer
#+BEGIN_SRC emacs-lisp
(defun circ/kill-this-buffer ()
  (interactive)
  (kill-buffer (current-buffer)))
#+END_SRC
** Cortex
#+BEGIN_SRC emacs-lisp
(defun circ/cortex/create-file (&optional initial-title)
  "Create a new cortex file"
  (interactive)
  (let* ((title (read-string "Title: " initial-title))
         (id (circ/cortex/create-new-file title)))
    (find-file (circ/cortex/expand-filepath id))
    (goto-char (point-max))))

(defun circ/cortex/create-new-file (title)
  (let ((new-id (circ/cortex/new-id)))
    (circ/cortex/ensure-file new-id title)
    new-id))

(defun circ/cortex/get-ids ()
  (mapcar (lambda (file)
            (replace-regexp-in-string "\.org" "" file))
          (directory-files circ/cortex/directory nil "^[0-9]*\.org$")))

(defun circ/cortex/get-title ()
  (let ((point-location (point)))
    (goto-char (point-min))
    (re-search-forward "\* \\(.*\\)")
    (goto-char point-location)
    (match-string 1)))

(defun circ/cortex/get-entry ()
  (let ((point-location (point)))
    (goto-char (point-min))
    (let ((entry (cond ((re-search-forward ":END: *\n" nil t)
                        (buffer-substring (point) (point-max)))
                       ((re-search-forward "\* .*\n" nil t)
                        (buffer-substring (point) (point-max)))
                       (t "ERROR PARSING ENTRY"))))
      (goto-char point-location)
      (replace-regexp-in-string "\\[cortex:[0-9]*\\]" "" entry))))

(defun circ/cortex/get-file-previews()
  (let ((ids (circ/cortex/get-ids)))
    (mapcar (lambda (id)
              (with-temp-buffer
                (insert-file-contents (circ/cortex/expand-filepath id))
                (concat (propertize id 'face '(:foreground "grey")) ": "
                        (propertize (circ/cortex/get-title) 'face '(:foreground "green")) "\n"
                        (circ/cortex/get-entry))))
            ids)))

(defun circ/cortex/expand-filepath (id)
  "Given an id, create the full cortex filepath"
  (concat (file-name-as-directory circ/cortex/directory)
          id ".org"))

(defun circ/cortex/extract-id (filepath)
  "Given a cortex filepath, return the id"
  (let ((filename (file-name-nondirectory filepath)))
    (string-match "^\\([0-9]*\\)\.org" filename)
    (match-string 1 filename)))

(defun circ/cortex/ensure-file (id &optional descr)
  (let ((description (cond (descr descr)
                           (t "")))
        (abs-filepath (circ/cortex/expand-filepath id)))
    (unless (file-exists-p (circ/cortex/expand-filepath id))
      (write-region (format "* %s\n" (capitalize description)) nil
                    abs-filepath))))

(defun circ/cortex/format-link (id descr)
  (format "[[cortex:%s][%s]]" id descr))

(defun circ/cortex/add-backlink (id)
  "Adds a backlink to the slide ID that links to the currently visited slide"
  (let ((current-file (buffer-file-name))
        (current-heading (org-get-heading t t))
        (abs-filepath (circ/cortex/expand-filepath id)))
    (with-temp-buffer
      (let ((file-buffer (get-file-buffer abs-filepath)))
        (insert-file-contents abs-filepath)
        (org-mode)
        (org-entry-put nil "Backlinks"
                       ;; Ensure we do not add a duplicate backlink
                       (let* ((backlinks (org-entry-get nil "Backlinks"))
                              (link (circ/cortex/format-link
                                     (circ/cortex/extract-id current-file)
                                     current-heading)))
                         (cond ((string-match-p (regexp-quote link)
                                                (cond (backlinks backlinks)
                                                      (t "")))
                                backlinks)
                               (t
                                (cond (backlinks (concat backlinks " " link))
                                      (t link))))))
        (write-file abs-filepath)))))

(defun circ/cortex/new-id ()
  (format-time-string "%Y%m%d%H%M%S"))

(defun circ/cortex/interactive-slide-picker (&optional initial-input)
  "Prompts user to interactively pick a slide and returns the id and the
description in a cons.

(id . description)

If no slide is found, a new id is generated and the search term is returned as
the description"
  (let* ((result (completing-read "Cortex link (C-M-j to done): "
                                  (circ/cortex/get-file-previews)
                                  nil nil
                                  initial-input))
         (id (progn
               (string-match "^\\([0-9]*\\):" result)
               (match-string 1 result)))
         (description (cond
                       (id
                        (string-match "^[0-9]*: \\(.*\\)" result)
                        (match-string 1 result))
                       (t
                        (string-match "^\\(.*\\)" result)
                        (match-string 1 result)))))

    ;; Remove any font properties
    (set-text-properties 0 (length id) nil id)
    (set-text-properties 0 (length description) nil description)
    (message "ID: %s" id)
    (message "Des: %s" description)

    (cons (cond ((file-exists-p (circ/cortex/expand-filepath id)) id)
                (t (circ/cortex/new-id)))
          description)))

(defun circ/cortex/add-link (id description)
  "Create a cortex link. If a region is highlighted, it is replaced with the
generated link"
  (when (region-active-p)
    (delete-region (region-beginning) (region-end)))
  (insert (circ/cortex/format-link id description)))

(defun circ/cortex/link (start end)
  "Create a cortex link.

When a region is highlighted, the initial search input is set to the highlighted
text, and the initial default description is also set to the highlighted text.

When no region is highlighed, the initial search input and initial description
are blank.

If the link given does not exist, the file is created with an initial heading
of the inputted description.

The targeted file is assigned a backlink for the original file the link was
created from."
  (interactive "r")
  (let* ((initial-input (when (region-active-p)
                               (circ/strip-font-properties
                                (buffer-substring start end))))
         (id-desc (circ/cortex/interactive-slide-picker initial-input))
         (id (car id-desc))
         (desc (cdr id-desc))
         (description (read-string "Description: " (cond (initial-input initial-input)
                                                         (t desc)))))

    ;; Firstly, ensure that a target file exists with the proper heading
    (circ/cortex/ensure-file id desc)
    (circ/cortex/add-backlink id)
    (circ/cortex/add-link id description)
    (save-buffer)))

(defun circ/cortex/get-all-links ()
  "Returns all cortex links in the current file in a list of conses."
  (let ((point-location (point))) ; Save pointer to restore later
    ;; Go to the beginning of the buffer
    (goto-char (point-min))
    ;; Move past the properties (if any)
    (re-search-forward (regexp-quote ":END:") nil t)
    (let (links)
      ;; Generate list of links in current buffer
      (while (re-search-forward "\\[\\[cortex:\\([0-9]*\\)\\]\\[\\(.*?\\)\\]\\]"
                                nil t)
        (let ((id (match-string 1))
              (desc (match-string 2)))
          (set-text-properties 0 (length id) nil id)
          (set-text-properties 0 (length desc) nil desc)
          (push (cons id desc) links)))
      (goto-char point-location)
      (cl-remove-duplicates links :test #'equal))))

(defun circ/cortex/update-backlink (slide-id link-id old-desc new-desc)
  "For the slide of `slide-id`, update the backlink of `link-id` to update the
description"
  (message "Updating cortex slide %s" slide-id)
  (with-temp-buffer
    (let ((filepath (circ/cortex/expand-filepath slide-id)))
      (insert-file-contents filepath)
      (org-mode)
      (let ((backlinks (org-entry-get nil "Backlinks")))
        (org-entry-put nil "Backlinks"
                       (replace-regexp-in-string
                        (regexp-quote (circ/cortex/format-link link-id old-desc))
                        (circ/cortex/format-link link-id new-desc)
                        backlinks)))
      (write-file filepath))))

(defun circ/cortex/rename-current-title (new-title)
  "Renames the title in the current slide"
  (let ((old-title (org-get-heading t t))
        (point-location (point))) ; Restore pointer later
    (goto-char (point-min))
    (re-search-forward (regexp-quote (concat "* " old-title)))
    (replace-match (concat "* " new-title))
    (goto-char (- point-location (- (length old-title) (length new-title)))))
  (save-buffer))

(defun circ/cortex/get-current-id ()
  (circ/cortex/extract-id (buffer-file-name)))

(defun circ/cortex/rename-slide ()
  "Rename the current slide and update the backlinks for any linked slides"
  (interactive)
  (let* ((current-id (circ/cortex/get-current-id))
         (old-title (org-get-heading t t))
         (new-title (read-string "New title: " old-title)))
    (message "Changing %s to %s" old-title new-title)
    (circ/cortex/rename-current-title new-title)
    (dolist (link (circ/cortex/get-all-links))
      (let ((link-id (car link)))
        (circ/cortex/update-backlink link-id current-id
                                       old-title new-title)))))

(defun circ/cortex/search-slides ()
  "Search all slides and open"
  (interactive)
  (let* ((search-term (circ/cortex/interactive-slide-picker))
         (filepath (circ/cortex/expand-filepath (car search-term))))
    (cond ((not (file-exists-p filepath))
           (message "Slide does not exist. Creating")
           (circ/cortex/create-file (cdr search-term)))
          (t
           (find-file filepath)))))

(defun circ/cortex/continue ()
  "Creates a continue link at the bottom of the current slide.

If the current slide has no index, set the index property to 1.

The new slide is created with an incremented index."
  (interactive)
  (let* ((point-location (point))
         (buffer-size (point-max))
         (current-title (org-get-heading t t))
         (org-index (org-entry-get nil "Index"))
         (current-index (cond (org-index org-index) (t "1")))
         (new-index (number-to-string (+ 1 (string-to-number current-index))))
         (new-id (circ/cortex/new-id))
         (new-title (read-string "New title: " current-title)))
    (goto-char (point-max))
    (insert "\n")
    (circ/cortex/ensure-file new-id new-title)
    (circ/cortex/add-backlink new-id)
    (circ/cortex/add-link new-id "Continued...")

    ;; If the continued slide has the same title, increment indexes
    (when (equal current-title new-title)
      (message "Indexing slides")
      (unless (org-entry-get nil "Index")
        (org-entry-put nil "Index" current-index))
      (circ/cortex/add-index new-id new-index))

    (goto-char (+ point-location (- (point-max) buffer-size)))
    (save-buffer)
    (find-file (circ/cortex/expand-filepath new-id))
    (goto-char (point-max))
    (message "%s continued..." current-title)))

(defun circ/cortex/add-index (id index)
  "Add index to given slide id"
  (with-temp-buffer
    (let ((abs-filepath (circ/cortex/expand-filepath id)))
      (insert-file-contents abs-filepath)
      (org-mode)
      (org-entry-put nil "Index" index)
      (write-file abs-filepath))))

(defun circ/cortex/list-reference-files ()
  (mapcar (lambda (file)
            (replace-regexp-in-string (regexp-quote (expand-file-name circ/cortex/reference-directory))
                                      "" file))
          (directory-files-recursively circ/cortex/reference-directory "")))

(defun circ/cortex/reference-completing-read (&optional initial-input)
  (completing-read "Reference: "
                   (circ/cortex/list-reference-files)
                   nil nil initial-input))

(defun circ/cortex/find-reference ()
  (interactive)
  (let* ((filepath (circ/cortex/reference-completing-read))
         (full-filepath (concat (expand-file-name circ/cortex/reference-directory) filepath)))
    (circ/ensure-file full-filepath)
    (find-file full-filepath)))

(defun circ/cortex/insert-reference-link ()
  (interactive)
  (let* ((filepath (circ/cortex/reference-completing-read))
         (description (read-string "Description: " (concat "Ref: " filepath)))
         (org-link (concat "ref:" filepath))
         (full-filepath (concat (expand-file-name circ/cortex/reference-directory) filepath)))
    (circ/ensure-file full-filepath)
    (insert (org-make-link-string org-link description))))

(defun circ/ensure-file (filepath)
  (unless (file-exists-p full-filepath)
    (make-directory (file-name-directory full-filepath) t)
    (write-region (concat "#+TITLE: "
                   (capitalize (replace-regexp-in-string
                                "_" " " (file-name-base filepath))))
                  nil full-filepath)))

(defun circ/cortex/reference-directories ()
  (seq-uniq
   (mapcar (lambda (f)
             (replace-regexp-in-string "/$" ""
                                       (file-name-directory f)))
           (circ/cortex/list-reference-files))))


(defun circ/cortex/file-web-page-archive ()
  (interactive)
  (dolist (file (directory-files (expand-file-name "~/Downloads/web_page_archive")
                                 t directory-files-no-dot-files-regexp))
    (let* ((filename (concat (file-name-base file)
                             (file-name-extension file t)))
           (directory (completing-read (format "File %s to: " filename)
                                       (circ/cortex/reference-directories)))
           (target-dir (file-name-as-directory
                          (concat (expand-file-name circ/cortex/reference-directory)
                                  directory)))
           (target-path (concat target-dir filename)))
      (message "Moving %s to %s" file target-path)
      (make-directory target-dir t)
      (rename-file file target-path))))
#+END_SRC

** Surround
#+BEGIN_SRC emacs-lisp
(defun circ/surround-parentheses () (interactive) (circ/surround "(" ")"))
(defun circ/surround-brackets    () (interactive) (circ/surround "[" "]"))
(defun circ/surround-braces      () (interactive) (circ/surround "{" "}"))
(defun circ/surround-asterisk    () (interactive) (circ/surround "*" "*"))
(defun circ/surround-d-quote     () (interactive) (circ/surround "\"" "\""))
(defun circ/surround-s-quote     () (interactive) (circ/surround "'" "'"))
(defun circ/surround-slash       () (interactive) (circ/surround "/" "/"))
(defun circ/surround-equals      () (interactive) (circ/surround "=" "="))
(defun circ/surround-plus        () (interactive) (circ/surround "+" "+"))
(defun circ/surround-minus       () (interactive) (circ/surround "-" "-"))

(defun circ/surround-region ()
  (interactive)
  (let* ((start (read-string "Beginning: "))
         (end (read-string "End: " start)))
    (circ/surround start end)))

(defun circ/surround (start end)
  (let ((region (buffer-substring (region-beginning) (region-end))))
    (delete-region (region-beginning) (region-end))
    (insert (format "%s%s%s" start region end))))
#+END_SRC

** Insert org timestamp
#+BEGIN_SRC emacs-lisp
(defun circ/insert-label-timestamp (label)
  (insert (format "%s: " label))
  (org-time-stamp-inactive))

(defun circ/insert-created-timestamp ()
  (interactive)
  (circ/insert-label-timestamp "Created"))
#+END_SRC
** Term Mode Functions
#+BEGIN_SRC emacs-lisp
(defun circ/term/delete-previous-word ()
  "Simulates typical C-<backspace> behaviour by sending C-w instead."
  (interactive)
  (term-send-raw-string "\C-w"))

(defun circ/term/delete-next-word ()
  "Simulates typical C-<delete> behaviour by sending M-d instead."
  (interactive)
  (term-send-raw-string "\^[d"))

(defun circ/term/go-to-previous-word ()
  "Simulates typical C-<left> behaviour by sending M-b instead."
  (interactive)
  (term-send-raw-string "\^[b"))

(defun circ/term/go-to-next-word ()
  "Simulates typical C-<right> behaviour by sending M-f instead."
  (interactive)
  (term-send-raw-string "\^[f"))
#+END_SRC

** Shell Command
#+BEGIN_SRC emacs-lisp
(defvar circ/shell-line-history '())

(defun circ/do-sh-cmd (input-list command &optional strip-newline)
  (let (output-list)
    (dolist (dirty-input input-list)
      (set-text-properties 0 (length dirty-input) nil dirty-input)
      (let* ((input (circ/escape-double-quotes
                     (circ/strip-last-newline
                      dirty-input)))
             (output (shell-command-to-string
                      (concat command " <<< \"" input "\""))))
        (setq output-list (cons (if strip-newline
                                    (circ/strip-last-newline output)
                                  output) output-list))))
    (reverse output-list)))

(defun circ/sh-cmd (&optional cmd whole-buffer split-lines)
  "Execute CMD on the buffer. If CMD is nil, ask the user what
command to use. If split-lines is non-nil, split the input by
newlines and send each line into the command individually.

Use the selected region as the input to the shell command. If no
region is selected, use the current line as the input, except
when WHOLE-BUFFER is non-nil, in which case, use the entire
buffer as the input.

A history of executed commands is kept."
  (interactive)
  (let ((command (cond (cmd cmd)
                       (t (completing-read "Command (C-M-j to done): "
                                           circ/shell-line-history)))))
    (add-to-list 'circ/shell-line-history command)
    (cond ((eq evil-this-type 'block)
           ;; Case when region is an evil block
           (let* ((rb (region-beginning))
                  (re (region-end))
                  (input-list (extract-rectangle rb re))
                  (output-list (circ/do-sh-cmd input-list command t))
                  (start (= (point) rb)))
             (goto-char rb)
             (delete-rectangle rb re)
             (insert-rectangle output-list)
             ;; after inserting rectanble, point will move to the end of the
             ;; input, so if the point was at the start of the rectangle, then
             ;; move it back.
             (when start
               (goto-char rb))))
          (t
           (let* ((rb (cond (whole-buffer (point-min))
                            ((use-region-p) (region-beginning))
                            (t (line-beginning-position))))
                  (re (cond (whole-buffer (point-max))
                            ((use-region-p) (region-end))
                            (t (line-end-position))))
                  (input (buffer-substring rb re))
                  (input-list (cond (split-lines (split-string input "\n"))
                                    (t (list input))))
                  (output-list (circ/do-sh-cmd input-list command (not whole-buffer))))
             (delete-region rb re)
             (dolist (line output-list)
               (insert line)))))))
#+END_SRC
** Org agenda habits
Force habit graphs to be drawn everywhere
#+BEGIN_SRC emacs-lisp
(defvar circ/org-habit-show-graphs-everywhere t
  "If non-nil, show habit graphs in all types of agenda buffers.

Normally, habits display consistency graphs only in
\"agenda\"-type agenda buffers, not in other types of agenda
buffers.  Set this variable to any non-nil variable to show
consistency graphs in all Org mode agendas.")

(defun circ/org-agenda-mark-habits ()
  "Mark all habits in current agenda for graph display.

This function enforces `circ/org-habit-show-graphs-everywhere' by
marking all habits in the current agenda as such.  When run just
before `org-agenda-finalize' (such as by advice; unfortunately,
`org-agenda-finalize-hook' is run too late), this has the effect
of displaying consistency graphs for these habits.

When `circ/org-habit-show-graphs-everywhere' is nil, this function
has no effect."
  (when (and circ/org-habit-show-graphs-everywhere
         (not (get-text-property (point) 'org-series)))
    (let ((cursor (point))
          item data)
      (while (setq cursor (next-single-property-change cursor 'org-marker))
        (setq item (get-text-property cursor 'org-marker))
        (when (and item (org-is-habit-p item))
          (with-current-buffer (marker-buffer item)
            (setq data (org-habit-parse-todo item)))
          (put-text-property cursor
                             (next-single-property-change cursor 'org-marker)
                             'org-habit-p data))))))

(advice-add #'org-agenda-finalize :before #'circ/org-agenda-mark-habits)
#+END_SRC
** Org agenda setup
#+BEGIN_SRC emacs-lisp
(defun circ/setup-agenda-view()
  (interactive)
  (circ/alias-org-agenda-tasks)
  (split-window-right)
  (circ/alias-org-agenda-agenda)
  (balance-windows)
  (circ/set-frame-name "PIMS"))
#+END_SRC
** Org agenda templates
#+BEGIN_SRC emacs-lisp
(setq circ/org-template-alist
      '(("Is this useful?" . "*Is this useful?*
/What do you think you could use it for?/

/What does it do?/
")
        ("Does this fix my issue?" . "*Does this fix my issue?*
/What issue could this solve?/

/What features does this have?/

/How could such features solve your problem?/")))

(defun circ/org-template-insert ()
  (interactive)
  (let ((template (completing-read "Template: "
                                   circ/org-template-alist)))
    (insert (cdr (assoc template circ/org-template-alist)))))
#+END_SRC
** Org sort headlines
Sorts the level 0 headlines by todo state
#+BEGIN_SRC emacs-lisp
(defun circ/org-hide-all ()
  (interactive)
  (org-map-entries
   (lambda () (outline-hide-subtree))
   nil 'file))

(defun circ/org-sort-headlines ()
  (interactive)
  (mark-whole-buffer)
  (org-sort-entries nil ?o)
  (circ/org-hide-all))
#+END_SRC
** Bash history
#+BEGIN_SRC emacs-lisp
(defun circ/bash-history ()
  (reverse
   (remove-if (lambda (string) (string-match-p "^#[0-9]*$" string))
              (split-string
               (with-temp-buffer
                 (insert-file-contents "~/.bash_history")
                 (buffer-substring-no-properties (point-min) (point-max)))
               "\n" t))))

(defun circ/bash-history-search()
  (interactive)
  (if (string-equal major-mode "term-mode")
      (progn
        (let* (;; Hacky fix for ivy sorting. Does not work with default
               ;; completing-read function
               (ivy-sort-functions-alist nil)
               (string (completing-read "History: " (circ/bash-history))))
          (term-send-raw-string string)
          (term-send-raw-string "\n")))
    (message "Not in term-mode")))
#+END_SRC
** Set Frame Name
A wrapper around the =set-frame-name= function to automatically append " - Emacs"
to the title and pre-fill the default input as the current frame name.

#+BEGIN_SRC emacs-lisp
(defun circ/set-frame-name (&optional name)
  (interactive)
  (let ((title (cond (name name)
                     (t (read-string "Title: "
                                     (replace-regexp-in-string
                                      " - Emacs$" ""
                                      (frame-parameter nil 'name)))))))
    (set-frame-name (concat title " - Emacs"))))
#+END_SRC
** New Scratch Modes
#+BEGIN_SRC emacs-lisp
(defun new-scratch-with-mode (mode)
  "Opens a new scratch buffer in given mode. If one already exists,
creates a new one"
  (interactive)
  (let ((name (concat "*" (symbol-name mode) "-scratch*")))
    (switch-to-buffer (get-buffer-create "*new-scratch-mode*"))
    (rename-buffer name t)
    (funcall mode)))

;; Add new scratch modes below
(defun new-scratch-json-mode ()
  (interactive)
  (new-scratch-with-mode 'json-mode))

(defun new-scratch-org-mode ()
  (interactive)
  (new-scratch-with-mode 'org-mode))

(defun new-scratch-text-mode ()
  (interactive)
  (new-scratch-with-mode 'text-mode))

(defun new-scratch-shell-script-mode ()
  (interactive)
  (new-scratch-with-mode 'shell-script-mode))

(defun new-scratch-python-mode ()
  (interactive)
  (new-scratch-with-mode 'python-mode))
#+END_SRC
** Disable evil quickscope
#+BEGIN_SRC emacs-lisp
(defun circ/disable-evil-quickscope-mode ()
  (evil-quickscope-mode -1))
#+END_SRC
** run-proc-and-fun
A function to run a shell program in the background and run a function on the
resulting buffer output.
#+BEGIN_SRC emacs-lisp
(defun circ/run-proc-and-fun (process-name buffer-name directory arg-list
                                           &optional erase-buffer fun)
  "Call ARG-LIST and run FUN in the results buffer.
Calls `start-process' with PROCESS-NAME BUFFER-NAME and ARG-LIST.
DIRECTORY sets the directory the process is run in.
ERASE-BUFFER, if non-nil will erase the results buffer before running
the process.
FUN, if a function, will be run after the process has finished.

Example

(circ/run-proc-and-fun \"test\" \"*test*\" \"~/Downloads\" (list \"ls\" \"-lh\") t
             (lambda ()
               (insert \"test4\\n\")))

NOTE: I use `list' because I don't know how to show a real
apostrophe in the doc"
  (interactive)
  (let* ((buf (get-buffer-create buffer-name)))
    (with-current-buffer buf
      (when erase-buffer
        (erase-buffer))
      (setq-local process-name process-name)
      (setq-local process-directory directory)
      (setq-local post-process-fun fun)
      (set-process-sentinel
       (let ((process-fun (append
                           (list process-name (current-buffer))
                           arg-list))
             (default-directory process-directory))
         (apply 'start-process process-fun))
       (lambda (process event)
         (unless (process-live-p process)
           (with-current-buffer (process-buffer process)
             (goto-char (point-max))
             (when (functionp post-process-fun)
               (funcall post-process-fun))
             (goto-char (point-max))))))))
  (message "Process started: %s" arg-list))
#+END_SRC
** RSS Feed Functions
Subscribe to subreddits
#+BEGIN_SRC emacs-lisp
(defun circ/generate-subreddit-feed ()
  (interactive)
  (let* ((subreddit (read-string "subreddit: r/"))
         (type (completing-read "Feed Type: "
                                '("Hot"
                                  "New"
                                  "Rising"
                                  "Controversial"
                                  "Top of the Past Hour"
                                  "Top of the Past Day"
                                  "Top of the Past Week"
                                  "Top of the Past Month"
                                  "Top of the Past Year"
                                  "Top of All Time")))
         (url (concat "https://www.reddit.com/r/" subreddit "/"
                      (cond ((string= type "Hot")                   "")
                            ((string= type "New")                   "new/")
                            ((string= type "Rising")                "rising/")
                            ((string= type "Controversial")         "controversial/")
                            ((string= type "Top of the Past Hour")  "top/")
                            ((string= type "Top of the Past Day")   "top/")
                            ((string= type "Top of the Past Week")  "top/")
                            ((string= type "Top of the Past Month") "top/")
                            ((string= type "Top of the Past Year")  "top/")
                            ((string= type "Top of All Time")       "top/"))
                      ".rss"
                      (cond ((string= type "Top of the Past Hour")  "?t=hour")
                            ((string= type "Top of the Past Day")   "?t=day")
                            ((string= type "Top of the Past Week")  "?t=month")
                            ((string= type "Top of the Past Month") "?t=month")
                            ((string= type "Top of the Past Year")  "?t=year")
                            ((string= type "Top of All Time")       "?t=all"))))
         (title (concat subreddit
                        (cond ((string= type "Hot")                   "")
                              ((string= type "New")                   " (new)")
                              ((string= type "Rising")                " (rising)")
                              ((string= type "Controversial")         " (controversial)")
                              ((string= type "Top of the Past Hour")  " (hourly)")
                              ((string= type "Top of the Past Day")   " (daily)")
                              ((string= type "Top of the Past Week")  " (weekly)")
                              ((string= type "Top of the Past Month") " (monthly)")
                              ((string= type "Top of the Past Year")  " (yearly)")
                              ((string= type "Top of All Time")       " (all time)"))))
         (org-link (format "[[%s][%s]]" url title)))
    (kill-new org-link)
    (message "Copied to clipboard: %s" org-link)))
#+END_SRC

Subscribe to youtube channel
#+BEGIN_SRC emacs-lisp
(defun circ/generate-youtube-channel-feed ()
  (interactive)
  (let* ((youtube-url (read-string "Youtube Channel Link: "))
         (channel-name (read-string "Youtube Channel Name: "))
         (channel-id (replace-regexp-in-string ".*channel/\\([A-Za-z0-9_-]*\\).*" "\\1" youtube-url))
         (url (concat "https://www.youtube.com/feeds/videos.xml?channel_id="
                      channel-id))
         (org-link (format "[[%s][%s]]" url channel-name)))
    (kill-new org-link)
    (message "Copied to clipboard: %s" org-link)))
#+END_SRC
** Desktop notifications
#+BEGIN_SRC emacs-lisp
(defvar circ/notify-command nil)

(defun circ/desktop-notify (message timeout)
  (format "timeout 0.2 notify-send -t %s \"%s\"" timeout message))
(defun circ/termux-notify (message timeout)
  (format "timeout 5 termux-notification -t \"%s\"" message))

(defun circ/notify (message &optional timeout)
  (interactive)
  (let ((timeout-secs (cond (timeout (* 1000 timeout))
                            (t 0))))
    (when (functionp circ/notify-command)
      (when (< 0 (shell-command (funcall circ/notify-command message timeout-secs)))
        (user-error "Notification failure: %s" message)))
    (message "Notification: %s" message)))
#+END_SRC
** vc shortcuts
#+BEGIN_SRC emacs-lisp
(defun circ/vc-diff-head-current ()
"Compare current file against HEAD"
  (interactive)
  (message "%s" (buffer-file-name))
  (vc-version-ediff (list (buffer-file-name)) "HEAD" nil))
#+END_SRC
** Reload all org agendas
#+BEGIN_SRC emacs-lisp
(defun circ/reload-all-org-agendas ()
  (interactive)
  (dolist (buffer (buffer-list))
    (with-current-buffer buffer
      (when (derived-mode-p 'org-agenda-mode)
        (let ((window (get-buffer-window buffer t)))
          (when window
            (with-selected-window window
              (org-agenda-redo))))))))

(defun circ/maybe-refresh-all-org-agendas ()
  (when (circ/org-agenda-file-p)
    (circ/reload-all-org-agendas)))

; (add-hook 'after-save-hook 'circ/maybe-refresh-all-org-agendas)
; (add-hook 'after-revert-hook 'circ/maybe-refresh-all-org-agendas)
#+END_SRC
** copy-buffer
Major mode for copy buffer
#+BEGIN_SRC emacs-lisp
(defvar copy-buffer-mode-map
  (let ((map (make-sparse-keymap)))
    map)
  "Keymap for `copy-buffer-mode'.")

(define-derived-mode copy-buffer-mode org-mode "copy-buffer"
  "Major mode for copy-buffer."
  (set (make-local-variable 'revert-buffer-function) #'copy-buffer))

(defvar copy-buffer-copy-function 'nil)

(defun copy-buffer-copy-function-desktop (string)
  (kill-new string))

(defun copy-buffer-copy-function-termux (string)
  (shell-command (concat "termux-clipboard-set" " "
                         "\"" string "\"")))

(defun copy-buffer-copy-quit ()
  (interactive)
  (cond ((functionp copy-buffer-copy-function)
         (funcall copy-buffer-copy-function (buffer-string))
         (circ/kill-this-buffer))
        (t
         (user-error "Error. Please set `copy-buffer-copy-function' to a function."))))

(defun copy-buffer ()
  (interactive)
  (let ((buf (get-buffer-create "*copy-buffer-new*")))
    (with-current-buffer buf
      (rename-buffer "*copy-buffer*" t)
      (copy-buffer-mode)
      (switch-to-buffer buf))))
#+END_SRC
** ansi-term
#+BEGIN_SRC emacs-lisp
(defun circ/ansi-term ()
  (interactive)
  (let* ((project-name (projectile-project-name))
         (path default-directory)
         (title (cond ((string= project-name "-") path)
                      (t project-name)))
         (term-name (format "term (%s)" title)))
    (ansi-term "/bin/bash" term-name)
    ;; If you are visiting a remote file, try to open a terminal in the remote box
    (if (and (functionp 'tramp-tramp-file-p)
             (tramp-tramp-file-p path))
        (let ((path (replace-regexp-in-string "^file:" "" path))
              (cd-str "fn=%s; if test ! -d $fn; then fn=$(dirname $fn); fi; cd $fn;")
              (bufname (concat "*" term-name "*" )))
          (let ((tstruct (tramp-dissect-file-name path)))
            (message "%s" (tramp-file-name-hop tstruct))
            (cond ((not (tramp-file-name-hop tstruct))
                   (cond ((equal (tramp-file-name-method tstruct) "ssh")
                          (process-send-string
                           bufname
                           (format (concat "ssh -t %s '" cd-str " exec bash'\n")
                                   (tramp-file-name-host tstruct)
                                   (tramp-file-name-localname tstruct))))
                         (t (error "not implemented for method %s"
                                   (tramp-file-name-method tstruct)))))
                  (t (error "Multiple hops not yet supported"))))))))
#+END_SRC
** reverse goto org clock
#+BEGIN_SRC emacs-lisp
(defun org-agenda-clock-goto ()
  "Jump to the currently clocked in task within the agenda.
If the currently clocked in task is not listed in the agenda
buffer, display it in another window."
  (interactive)
  (let (pos)
    (mapc (lambda (o)
        (if (eq (overlay-get o 'type) 'org-agenda-clocking)
        (setq pos (overlay-start o))))
      (reverse (overlays-in (point-min) (point-max))))
    (cond (pos (goto-char pos))
      ;; If the currently clocked entry is not in the agenda
      ;; buffer, we visit it in another window:
      ((bound-and-true-p org-clock-current-task)
       (org-switch-to-buffer-other-window (org-clock-goto)))
      (t (message "No running clock, use `C-c C-x C-j' to jump to the most recent one")))))
#+END_SRC
** org-set-tags
#+BEGIN_SRC emacs-lisp
(defun circ/org-set-tags ()
  (interactive)
  (let* ((curr-tags (org-get-tags nil t))
         (new-tags (set-difference
                    (mapcar 'car (org-global-tags-completion-table))
                    curr-tags
                    :test 'string=))
         (completion-list (append
                           (mapcar (lambda (tag)
                                     (concat "+" tag))
                                   new-tags)
                           (mapcar (lambda (tag)
                                     (concat "-" tag))
                                   curr-tags)))
         (tag-change (completing-read "Tag: " completion-list))
         (remove (string= "-" (substring tag-change 0 1)))
         (tag (if (or (string= "-" (substring tag-change 0 1))
                      (string= "+" (substring tag-change 0 1)))
                  (substring tag-change 1)
                tag-change))
         (tags (remove* "" (if remove
                               (remove tag curr-tags)
                             (cons tag curr-tags))
                        :test 'string=)))
    (org-set-tags-to tags)
    (org--align-tags-here org-tags-column)
    (circ/org-set-tags)))

(defun circ/org-clear-tags ()
  (interactive)
  (org-set-tags-to nil))
#+END_SRC
** org-agenda-set-tags
#+BEGIN_SRC emacs-lisp
;; TODO: Bug exists in org 9.4.4 where setting a tag in the agenda does not
;; update the tag property correctly. So the tags shown in the completion list
;; are out of date
(defun circ/org-agenda-set-tags ()
  (interactive)
  (let* ((curr-tags (org-get-at-bol 'tags))
         (new-tags (set-difference
                    (mapcar 'car (org-global-tags-completion-table))
                    curr-tags
                    :test 'string=))
         (completion-list (append
                           (mapcar (lambda (tag) (concat "+" tag)) new-tags)
                           (mapcar (lambda (tag) (concat "-" tag)) curr-tags)))
         (tag-change (completing-read "Tag: " completion-list))
         (remove (string= "-" (substring tag-change 0 1)))
         (tag (if (or (string= "-" (substring tag-change 0 1))
                      (string= "+" (substring tag-change 0 1)))
                  (substring tag-change 1)
                tag-change))
         (tags (remove* "" (if remove
                               (remove tag curr-tags)
                             (cons tag curr-tags))
                        :test 'string=)))
    (if remove
        (org-agenda-set-tags tag 'off)
      (org-agenda-set-tags tag 'on))
    (circ/org-agenda-set-tags)))

(defun circ/org-agenda-clear-tags ()
  (interactive)
  (dolist (tag (org-get-at-bol 'tags))
    (org-agenda-set-tags tag 'off)))
#+END_SRC
** org agenda toggle blocked tasks
#+BEGIN_SRC emacs-lisp
(defun circ/org-agenda-toggle-blocked-tasks ()
  (interactive)
  (cond ((eq org-agenda-dim-blocked-tasks 'invisible)
         (setq org-agenda-dim-blocked-tasks t))
        (org-agenda-dim-blocked-tasks
         (setq org-agenda-dim-blocked-tasks 'invisible)))
  (org-agenda-redo))
#+END_SRC
** org agenda toggle clock closed
#+BEGIN_SRC emacs-lisp
(defun circ/org-agenda-toggle-clock-closed ()
  (interactive)
  (cond ((equal org-agenda-log-mode-items '(clock))
         (setq org-agenda-log-mode-items '(closed)))
        (t
         (setq org-agenda-log-mode-items '(clock))))
  (org-agenda-redo))
#+END_SRC
** org agenda toggle hide tags
#+BEGIN_SRC emacs-lisp
(defun circ/org-agenda-toggle-hide-tags ()
  (interactive)
  (if org-agenda-hide-tags-regexp
      (setq org-agenda-hide-tags-regexp nil)
    (setq org-agenda-hide-tags-regexp ".*"))
  (org-agenda-redo))
#+END_SRC
** insert non-ascii characters
#+BEGIN_SRC emacs-lisp
(defun circ/insert-a-macron () (interactive) (insert ""))
(defun circ/insert-e-macron () (interactive) (insert ""))
(defun circ/insert-i-macron () (interactive) (insert ""))
(defun circ/insert-o-macron () (interactive) (insert ""))
(defun circ/insert-u-macron () (interactive) (insert ""))
(defun circ/insert-y-macron () (interactive) (insert ""))
#+END_SRC
** pass
#+begin_src emacs-lisp
(defvar circ/pass/pass-directory "~/.password-store")
(defvar circ/pass/ignore-regexp "")
(defvar circ/pass/clipboard-timeout 30)

(defvar circ/pass/clipboard-field nil)
(defvar circ/pass/clipboard-timeout-job nil)
(defvar circ/pass/kill-ring-pointer nil)

(defun circ/pass/get-entries ()
  (seq-filter
   (lambda (entr)
     (not (string-match-p circ/pass/ignore-regexp entr)))
   (mapcar
    (lambda (entry)
      (file-name-sans-extension
       (replace-regexp-in-string
        (regexp-quote (file-name-as-directory
                       (expand-file-name circ/pass/pass-directory)))
        "" entry)))
    (directory-files-recursively
     (expand-file-name circ/pass/pass-directory) ".gpg$"))))

(defun circ/pass/get-entry-path (entry)
  (concat (file-name-as-directory circ/pass/pass-directory)
          entry
          ".gpg"))

(defun circ/pass/read-entry (entry)
  (with-temp-buffer
    (insert-file-contents (circ/pass/get-entry-path entry))
    (buffer-substring-no-properties (point-min) (point-max))))

(defun circ/pass/parse-entry (entry)
  (mapcar
   (lambda (x)
     (split-string x ": "))
   (split-string (circ/pass/read-entry entry) "\n")))

(defun circ/pass/get-value (entry key)
  (cond ((string= key "password")
         (caar (circ/pass/parse-entry entry)))
        (t
         (cadr (assoc key (circ/pass/parse-entry entry))))))

(defun circ/pass/open-entry (&optional entry)
  (interactive)
  (unless entry (setq entry (completing-read "Pass entry: "
                                             (circ/pass/get-entries))))
  (find-file (circ/pass/get-entry-path entry)))

(defun circ/pass/clear-clipboard ()
  (when circ/pass/clipboard-timeout-job
    (cancel-timer circ/pass/clipboard-timeout-job)
    (setq circ/pass/clipboard-timeout-job nil))
  (when (or (string= (org-get-x-clipboard 'CLIPBOARD) (car circ/pass/kill-ring-pointer))
            (string= (org-get-x-clipboard 'PRIMARY) (car circ/pass/kill-ring-pointer)))
    (kill-new ""))
  (when circ/pass/kill-ring-pointer
    (setcar circ/pass/kill-ring-pointer "")
    (setq circ/pass/kill-ring-pointer nil)
    (message "%s in clipboard cleared" (capitalize circ/pass/clipboard-field))))

(defun circ/pass/copy-entry-field (entry field)
  (circ/pass/clear-clipboard)
  (kill-new (circ/pass/get-value entry field))
  (setq circ/pass/kill-ring-pointer kill-ring-yank-pointer)
  (setq circ/pass/clipboard-timeout-job
        (run-at-time circ/pass/clipboard-timeout nil
                     'circ/pass/clear-clipboard))
  (setq circ/pass/clipboard-field field)
  (message "Copied %s for %s. Will clear in %s seconds"
           field entry circ/pass/clipboard-timeout))

(defun circ/pass/copy-password (&optional entry)
  (interactive)
  (unless entry (setq entry (completing-read "Pass entry: "
                                             (circ/pass/get-entries))))
  (circ/pass/copy-entry-field entry "password"))

(defun circ/pass/copy-user (&optional entry)
  (interactive)
  (unless entry (setq entry (completing-read "Pass entry: "
                                             (circ/pass/get-entries))))
  (circ/pass/copy-entry-field entry "user"))

(defun circ/pass/generate-entry (&optional entry)
  (interactive)
  (unless entry (setq entry (read-string "Entry name: ")))
  (let ((flags ""))
    (when (file-exists-p (circ/pass/get-entry-path entry))
      (unless (y-or-n-p (format "%s already exists. Insert new password? " entry))
        (error "Generate aborted"))
      (setq flags (concat flags " -i")))
    (unless (file-directory-p (file-name-directory (circ/pass/get-entry-path entry)))
      (make-directory (file-name-directory (circ/pass/get-entry-path entry)) t))
    (unless (y-or-n-p "Use symbols? ")
      (setq flags (concat flags " -n")))
    (shell-command (format "pass generate %s %s > /dev/null" flags entry)))
  (when (y-or-n-p (format "Copy entry %s password?" entry))
    (circ/pass/copy-password entry))
  (when (y-or-n-p (format "Open entry %s?" entry))
    (circ/pass/open-entry entry)))
#+end_src
** balance-window fix
Balance window doesn't work when you have a side window with a fixed size.

This is due to a calculation bug in the =windows.el= code.

#+begin_src emacs-lisp
(defun circ/balance-windows-2 (window horizontal)
  "Subroutine of `balance-windows-1'.
WINDOW must be a vertical combination (horizontal if HORIZONTAL
is non-nil)."
  (let* ((char-size (if window-resize-pixelwise
			1
		      (frame-char-size window horizontal)))
	 (first (window-child window))
	 (sub first)
	 (number-of-children 0)
     (ignore-window-count 0)
	 (parent-size (window-new-pixel window))
	 (total-sum parent-size)
	 failed size sub-total sub-delta sub-amount rest)
    (while sub
      (setq number-of-children (1+ number-of-children))
      (when (window-size-fixed-p sub horizontal)
	(setq total-sum
	      (- total-sum (window-size sub horizontal t)))
    (setq ignore-window-count (1+ ignore-window-count))
	(set-window-new-normal sub 'ignore))
      (setq sub (window-right sub)))

    (setq failed t)
    (while (and failed (> number-of-children 0))
      (setq size (/ total-sum (- number-of-children ignore-window-count)))
      (setq failed nil)
      (setq sub first)
      (while (and sub (not failed))
	;; Ignore child windows that should be ignored or are stuck.
	(unless (window--resize-child-windows-skip-p sub)
	  (setq sub-total (window-size sub horizontal t))
	  (setq sub-delta (- size sub-total))
	  (setq sub-amount
		(window-sizable sub sub-delta horizontal nil t))
	  ;; Register the new total size for this child window.
	  (set-window-new-pixel sub (+ sub-total sub-amount))
	  (unless (= sub-amount sub-delta)
	    (setq total-sum (- total-sum sub-total sub-amount))
	    (setq number-of-children (1- number-of-children))
	    ;; We failed and need a new round.
	    (setq failed t)
	    (set-window-new-normal sub 'skip)))
	(setq sub (window-right sub))))

    ;; How can we be sure that `number-of-children' is NOT zero here ?
    (setq rest (% total-sum number-of-children))
    ;; Fix rounding by trying to enlarge non-stuck windows by one line
    ;; (column) until `rest' is zero.
    (setq sub first)
    (while (and sub (> rest 0))
      (unless (window--resize-child-windows-skip-p window)
	(set-window-new-pixel sub (min rest char-size) t)
	(setq rest (- rest char-size)))
      (setq sub (window-right sub)))

    ;; Fix rounding by trying to enlarge stuck windows by one line
    ;; (column) until `rest' equals zero.
    (setq sub first)
    (while (and sub (> rest 0))
      (unless (eq (window-new-normal sub) 'ignore)
	(set-window-new-pixel sub (min rest char-size) t)
	(setq rest (- rest char-size)))
      (setq sub (window-right sub)))

    (setq sub first)
    (while sub
      ;; Record new normal sizes.
      (set-window-new-normal
       sub (/ (if (eq (window-new-normal sub) 'ignore)
		  (window-size sub horizontal t)
		(window-new-pixel sub))
	      (float parent-size)))
      ;; Recursively balance each window's child windows.
      (balance-windows-1 sub horizontal)
      (setq sub (window-right sub)))))

(advice-add 'balance-windows-2 :override
            #'circ/balance-windows-2)
#+end_src
** Fixed window sizes
I want certain windows to have fixed width because they open in a side window.
#+begin_src emacs-lisp
(defun circ/set-fixed-window-size-width ()
  "Set the buffer to not allow window width changes"
  (interactive)
  (setq window-size-fixed 'width))

(add-hook 'help-mode-hook 'circ/set-fixed-window-size-width)
#+end_src
* Local variables
** Safe Local Eval Aliases
#+BEGIN_SRC emacs-lisp
(defun circ/file-local-eval-safe-auto-revert ()
  (interactive)
  (auto-revert-mode t))
#+END_SRC
** Safe Local Eval List
#+BEGIN_SRC emacs-lisp
(add-to-list 'safe-local-eval-forms '(circ/file-local-eval-safe-auto-revert))
#+END_SRC

* Package Specific
** ediff
#+BEGIN_SRC emacs-lisp
(setq ediff-split-window-function 'split-window-horizontally)
(setq ediff-window-setup-function 'ediff-setup-windows-plain)
#+END_SRC

Restore previous window config.
#+BEGIN_SRC emacs-lisp
(defvar circ/ediff-last-window-configuration nil)

(defun circ/ediff-store-window-configuration ()
  (setq circ/ediff-last-window-configuration (current-window-configuration)))

(defun circ/ediff-restore-window-configuration ()
  (set-window-configuration circ/ediff-last-window-configuration))

(add-hook 'ediff-before-setup-hook #'circ/ediff-store-window-configuration)
(add-hook 'ediff-quit-hook #'circ/ediff-restore-window-configuration)
#+END_SRC

Expand org files when comparing
#+BEGIN_SRC emacs-lisp
(add-hook 'ediff-prepare-buffer-hook #'outline-show-all)
#+END_SRC

Colours
#+BEGIN_SRC emacs-lisp
(custom-set-faces
 '(ediff-even-diff-A ((t (:background "dim gray"))))
 '(ediff-even-diff-B ((t (:background "dim gray"))))
 '(ediff-even-diff-C ((t (:background "dim gray"))))
 '(ediff-odd-diff-A ((t (:background "dim gray"))))
 '(ediff-odd-diff-B ((t (:background "dim gray"))))
 '(ediff-odd-diff-C ((t (:background "dim gray"))))
 )
#+END_SRC
** which-key
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/which-key-3.3.1")
(require 'which-key)
(which-key-mode)
#+END_SRC

** evil
Load evil, and its dependencies in it comes with.

#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/evil-1.2.14")
(add-to-list 'load-path "~/.emacs.d/packages/evil-1.2.14/lib")
(require 'evil)
(evil-mode 1)
#+END_SRC

Rebind the ~q~ and ~quit~ commands to make more sense.

#+BEGIN_SRC emacs-lisp
(evil-ex-define-cmd "q" 'kill-this-buffer) ; :q should kill the buffer rather
                                        ; than quiting emacs
(evil-ex-define-cmd "quit" 'evil-quit-all) ; :quit to quit emacs
;; Deal with common mistakes
(evil-ex-define-cmd "W"  'evil-write)
(evil-ex-define-cmd "Wq" 'evil-save-and-close)
(evil-ex-define-cmd "WQ" 'evil-save-and-close)

(evil-define-command evil-save-and-kill-buffer (file &optional bang)
  "Save current buffer and close buffer.
Override for :wq"
  :repeat nil
  (interactive "<f><!>")
  (evil-write nil nil nil file bang)
  (kill-this-buffer))
(evil-ex-define-cmd "wq" 'evil-save-and-kill-buffer)
#+END_SRC

** evil-leader
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/evil-leader-0.4.3")
(require 'evil-leader)
(global-evil-leader-mode)
#+END_SRC

** evil-org
#+BEGIN_SRC emacs-lisp
(add-to-list
 'load-path
 "~/.emacs.d/packages/evil-org-mode-b6d652a9163d3430a9e0933a554bdbee5244bbf6")
(require 'evil-org)
(add-hook 'org-mode-hook 'evil-org-mode)
(evil-org-set-key-theme '(navigation insert textobjects additional calendar shift todo heading))
(add-hook 'org-mode-hook
          (lambda () (setq evil-auto-indent nil)))
(require 'evil-org-agenda)
(evil-org-agenda-set-keys)

;; When using emacs in a terminal, many keys do not work.
;; Fix them here
(evil-define-key 'motion org-agenda-mode-map
  (kbd "RET") 'org-agenda-switch-to
  (kbd "TAB") 'org-agenda-goto)

(evil-define-key '(normal visual) evil-org-mode-map
  (kbd "TAB") 'org-cycle
  (kbd "<backtab>") 'org-shifttab)
#+END_SRC

** evil-numbers
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/evil-numbers-0.4")
(require 'evil-numbers)
#+END_SRC

** evil-quickscope
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/evil-quickscope-0.1.4")
(require 'evil-quickscope)
(global-evil-quickscope-mode 1)
#+END_SRC

** ivy / swiper / counsel
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/swiper-0.11.0")
(require 'ivy)
(require 'swiper)
(require 'counsel)
(setq ivy-use-selectable-prompt t)
(setq ivy-use-virtual-buffers t)
(setq ivy-count-format "(%d/%d) ")
(ivy-mode 1)

;; Setting up more ivy completion
(setq org-outline-path-complete-in-steps nil)
(setq org-completion-use-ido nil)

;; Remove the Shift-SPACE shortcut.
;; I keep accidentally activating it.
(define-key ivy-minibuffer-map (kbd "S-SPC") nil)
#+END_SRC

*** initial input alist
#+BEGIN_SRC emacs-lisp
;; (setq ivy-initial-inputs-alist '((counsel-package . "^+ ")
;;                                  (org-refile . "^")
;;                                  (org-agenda-refile . "^")
;;                                  (org-capture-refile . "^")
;;                                  (counsel-M-x . "^")
;;                                  (counsel-describe-function . "^")
;;                                  (counsel-describe-variable . "^")
;;                                  (counsel-org-capture . "^")
;;                                  (Man-completion-table . "^")
;;                                  (woman . "^")))

(setq ivy-initial-inputs-alist '())
#+END_SRC
** projectile
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/projectile-2.0.0")
(require 'projectile)
(projectile-mode +1)
(setq projectile-project-search-path '("~/projects/")) ; where the projects are
(setq projectile-completion-system 'ivy)
#+END_SRC

** counsel-projectile
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/counsel-projectile-0.3.0")
(require 'counsel-projectile)
(setq counsel-projectile-grep-initial-input '(ivy-thing-at-point))
                                        ; this required a fix that was taken
                                        ; from commit a07ddc8
#+END_SRC

** rainbow-delimiters
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/rainbow-delimiters-2.1.3")
(require 'rainbow-delimiters)
#+END_SRC

Set the colours to be as distinct as possible.

#+BEGIN_SRC emacs-lisp
(set-face-attribute 'rainbow-delimiters-depth-1-face nil :foreground "#e6194b")
(set-face-attribute 'rainbow-delimiters-depth-2-face nil :foreground "#3cb44b")
(set-face-attribute 'rainbow-delimiters-depth-3-face nil :foreground "#ffe119")
(set-face-attribute 'rainbow-delimiters-depth-4-face nil :foreground "#4363d8")
(set-face-attribute 'rainbow-delimiters-depth-5-face nil :foreground "#f58231")
(set-face-attribute 'rainbow-delimiters-depth-6-face nil :foreground "#911eb4")
(set-face-attribute 'rainbow-delimiters-depth-7-face nil :foreground "#42d4f4")
(set-face-attribute 'rainbow-delimiters-depth-8-face nil :foreground "#f032e6")
(set-face-attribute 'rainbow-delimiters-depth-9-face nil :foreground "#bfef45")
(set-face-attribute 'rainbow-delimiters-unmatched-face nil
                    :background "#ff0000"
                    :foreground "#ffffff")
#+END_SRC

** beacon
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/beacon-1.3.4")
(require 'beacon)
(beacon-mode 1)
#+END_SRC

** json-mode
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/json-snatcher-1.0.0")
(add-to-list 'load-path "~/.emacs.d/packages/json-reformat-0.0.6")
(add-to-list 'load-path "~/.emacs.d/packages/json-mode-1.7.0")
(require 'json-mode)
#+END_SRC

** telephone-line
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/telephone-line-0.4")
(require 'telephone-line)
#+END_SRC

Telephone line customization.

#+BEGIN_SRC emacs-lisp
(setq-default header-line-format "| %b | %I | %f")
(telephone-line-defsegment* circ/telephone-line-indicator-segment
  `(""
    mode-line-mule-info
    mode-line-modified
    mode-line-client
    mode-line-remote
    mode-line-frame-identification))
(setq telephone-line-lhs
      '((evil   . (telephone-line-evil-tag-segment))
        (accent . (telephone-line-vc-segment
                   telephone-line-erc-modified-channels-segment
                   telephone-line-process-segment))
        (nil    . (circ/telephone-line-indicator-segment))))
(setq telephone-line-rhs
      '((nil    . (telephone-line-misc-info-segment))
        (accent . (telephone-line-major-mode-segment))
        (evil   . (telephone-line-airline-position-segment))))
(telephone-line-mode 1)
#+END_SRC

** nlinum-relative
nlinum is a dependency.

Delay is kinda required or else files with loads of lines tend to lag.

#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/nlinum-1.8.1")
(require 'nlinum)

(add-to-list
 'load-path
 "~/.emacs.d/packages/nlinum-relative-5b9950c97ba79a6f0683e38b13da23f39e01031c")
(require 'nlinum-relative)
(nlinum-relative-setup-evil)
(global-nlinum-relative-mode)
(setq nlinum-relative-redisplay-delay 0.2) ; delay
(setq nlinum-relative-current-symbol "") ; e.g. "->"
                                        ; "" for display current line number
(setq nlinum-relative-offset 0)          ; 1 if you want 0, 2, 3...
#+END_SRC

I want relative numbers to display when in evil operator mode.

#+BEGIN_SRC emacs-lisp
(add-hook 'evil-operator-state-entry-hook
          (lambda () (when (bound-and-true-p nlinum-relative-mode)
                       (nlinum-relative-on))))
(add-hook 'evil-operator-state-exit-hook
          (lambda () (when (bound-and-true-p nlinum-relative-mode)
                       (nlinum-relative-off))))
#+END_SRC

** diff-hl
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/diff-hl-1.8.6")
(require 'diff-hl)
(require 'diff-hl-flydiff)
(global-diff-hl-mode)
(diff-hl-flydiff-mode) ; Don't wait for save to calcualte diff
#+END_SRC

** erlang
#+BEGIN_SRC emacs-lisp
(defvar circ/enable-erlang t)
(when circ/enable-erlang
  (setq load-path (cons  "~/.emacs.d/packages/erlang-2.8.4" load-path))
  (setq erlang-root-dir "~/erl_rel/18.3")
  (setq exec-path (cons "~/erl_rel/18.3/bin" exec-path))
  (require 'erlang-start)
  (require 'erlang-flymake))
#+END_SRC

*** Use regular indenting for single '%' comments
#+BEGIN_SRC emacs-lisp
(defun circ/erlang-comment-indent ()
  (cond ((looking-at "%%%") 0)
        ((looking-at "%%")
         (or (erlang-calculate-indent)
             (current-indentation)))
        ((looking-at "%")
         (or (erlang-calculate-indent)
             (current-indentation)))
        (t
         (save-excursion
           (skip-chars-backward " \t")
           (max (if (bolp) 0 (1+ (current-column)))
                comment-column)))))

(advice-add
   'erlang-comment-indent
   :override
   (lambda (&rest r) (circ/erlang-comment-indent))
   '((name . "erlang-comment-indent-advice")))
#+END_SRC

** term mode
Set colours to be more readable

#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'term
  (set-face-attribute 'term-color-green   nil :foreground "#55ff55")
  (set-face-attribute 'term-color-blue    nil :foreground "#5555ff")
  (set-face-attribute 'term-color-red     nil :foreground "#ff5555")
  (set-face-attribute 'term-color-magenta nil :foreground "#ff55ff")
  (set-face-attribute 'term-color-cyan    nil :foreground "#55ffff")
  (set-face-attribute 'term-color-yellow  nil :foreground "#ffff55"))
#+END_SRC

Disable line number mode for term mode.
Requires this hacky double add hook thing because the
global-nlinum-relative-mode hook is run after the term-mode-hook

#+BEGIN_SRC emacs-lisp
(defun setup-term-mode ()
  "Counteract global nlinum mode"
  (add-hook 'after-change-major-mode-hook
            (lambda () (nlinum-mode 0))
            :append :local))

(add-hook 'term-mode-hook 'setup-term-mode)
#+END_SRC

Set normal / visual / operator mode to be line mode.
Set insert mode to be char mode.

=ignore-errors= added because this crashes term-mode from starting up.
I don't know why.

#+BEGIN_SRC emacs-lisp
(defun term-mode-normal-visual-operator-switch ()
  (when (equal major-mode 'term-mode) (ignore-errors (term-line-mode))))
(defun term-mode-insert-switch ()
  (when (equal major-mode 'term-mode) (ignore-errors (term-char-mode)) (end-of-buffer)))

(add-hook 'evil-normal-state-entry-hook 'term-mode-normal-visual-operator-switch)
(add-hook 'evil-visual-state-entry-hook 'term-mode-normal-visual-operator-switch)
(add-hook 'evil-operator-state-entry-hook 'term-mode-normal-visual-operator-switch)
(add-hook 'evil-insert-state-entry-hook 'term-mode-insert-switch)
#+END_SRC

Have the term buffer close automatically when the process has finished.

Source: https://oremacs.com/2015/01/01/three-ansi-term-tips/

#+BEGIN_SRC emacs-lisp
(defun auto-exit-term-exec-hook ()
  (let* ((buff (current-buffer))
         (proc (get-buffer-process buff)))
    (set-process-sentinel
     proc
     `(lambda (process event)
        (if (not (process-live-p process))
            (kill-buffer ,buff))))))

(add-hook 'term-exec-hook 'auto-exit-term-exec-hook)
#+END_SRC

** man
Open man pages in current window
#+BEGIN_SRC emacs-lisp
(setq Man-notify-method 'pushy)
#+END_SRC

** mpccp
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/mpccp")
(require 'mpccp)
(setq mpccp-playlist-directory "/mnt/slave/playlists")
(add-hook 'mpccp-mode-hook 'circ/disable-evil-quickscope-mode)
#+END_SRC
** Dashboard
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/dashboard")
(require 'dashboard)
(add-to-list 'dashboard-persistent-links "file:~/.emacs.d/configuration.org")
(add-to-list 'dashboard-persistent-links "file:~/.emacs.d/settings.org")
(add-to-list 'dashboard-persistent-links "file:~/.emacs.d/personalsettings.org")
(add-to-list 'dashboard-persistent-links "file:~/pims/cortex/reference/books/read_books_list.org")
(add-to-list 'dashboard-persistent-links "url:http://duckduckgo.com")
(setq initial-buffer-choice 'dashboard)
(add-hook 'dashboard-mode-hook 'circ/disable-evil-quickscope-mode)
#+END_SRC
** eww
Evil bindings for =eww=.
#+BEGIN_SRC emacs-lisp
(evil-define-key 'normal eww-mode-map
  (kbd "H") 'eww-back-url
  (kbd "L") 'eww-forward-url
  (kbd "[") 'shr-previous-link
  (kbd "]") 'shr-next-link
  (kbd "d") 'evil-scroll-down
  (kbd "u") 'evil-scroll-up
  (kbd "o") 'eww
  (kbd "r") 'eww-reload
  (kbd "R") 'eww-readable
  (kbd "q") 'kill-this-buffer
)
#+END_SRC

Rename buffers to allow for more than one =eww= buffer.
#+BEGIN_SRC emacs-lisp
(defun circ/rename-eww-hook ()
  "Rename eww buffer with page title for easier buffer finding and to allow
multiple eww buffers to be open"
  (let ((current-title (plist-get eww-data :title)))
    (rename-buffer (concat "*" "eww" " " "(" current-title ")" "*" )
                   t)))
(add-hook 'eww-mode-hook #'circ/rename-eww-hook)
(add-hook 'eww-after-render-hook #'circ/rename-eww-hook)
#+END_SRC
** elfeed
*** Setup
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/elfeed-7b2b6fadaa498fef2ba212a50da4a8afa2a5d305")
(require 'elfeed)
(setq elfeed-db-directory "~/rss_elfeed/elfeed/")
(add-hook 'elfeed-search-mode-hook 'circ/disable-evil-quickscope-mode)
#+END_SRC

*** elfeed-org
To read rss feed links from an org file:
 #+BEGIN_SRC emacs-lisp
 ;; Dependencies
 (add-to-list 'load-path "~/.emacs.d/packages/dash.el-2.16.0")
 (add-to-list 'load-path "~/.emacs.d/packages/s.el-43ba8b563bee3426cead0e6d4ddc09398e1a349d")

 (add-to-list 'load-path "~/.emacs.d/packages/elfeed-org-77b6bbf222487809813de260447d31c4c59902c9")
 (require 'elfeed-org)
 (elfeed-org)
 (setq rmh-elfeed-org-files (list "~/rss_elfeed/rss_feeds.org"))
 #+END_SRC

*** Load and Save DB on open and close
#+BEGIN_SRC emacs-lisp
(defun circ/elfeed-load-and-open ()
  (interactive)
;  (elfeed-db-load)
  (elfeed))
(defun circ/elfeed-save-and-close ()
  (interactive)
;  (elfeed-db-save)
  (circ/kill-this-buffer))
(defun circ/elfeed-db-reload ()
  (interactive)
;  (elfeed-db-load)
  (elfeed-search-update--force))
#+END_SRC
*** Open elfeed file
#+BEGIN_SRC emacs-lisp
(defun circ/open-rss-elfeed-file ()
  (interactive)
  (find-file "~/rss_elfeed/rss_feeds.org"))
#+END_SRC
*** Open in custom application
 #+BEGIN_SRC emacs-lisp
 (defun circ/eww-readable (url &rest args)
   (interactive)
   (eww url)
   (add-hook 'eww-after-render-hook 'eww-readable nil t))

 (defun circ/open-in-mpv (url &rest args)
   (message "Opening in mpv: %s" url)
   (call-process "mpv" nil 0 nil url))

 (defun circ/elfeed-show-open-in-mpv ()
   (interactive)
   (let ((browse-url-browser-function 'circ/open-in-mpv)) (elfeed-show-visit)))
 (defun circ/elfeed-show-open-eww-readable()
   (interactive)
   (let ((browse-url-browser-function 'circ/eww-readable)) (elfeed-show-visit)))
 (defun circ/elfeed-show-open-eww()
   (interactive)
   (let ((browse-url-browser-function 'eww-browse-url)) (elfeed-show-visit)))

 (defun circ/elfeed-search-open-in-mpv ()
   (interactive)
   (let ((browse-url-browser-function 'circ/open-in-mpv)) (elfeed-search-browse-url)))
 (defun circ/elfeed-search-open-eww-readable()
   (interactive)
   (let ((browse-url-browser-function 'circ/eww-readable)) (elfeed-search-browse-url)))
 (defun circ/elfeed--search-open-eww()
   (interactive)
   (let ((browse-url-browser-function 'eww-browse-url)) (elfeed-search-browse-url)))
#+END_SRC

*** Saved tags
#+BEGIN_SRC emacs-lisp
(defun circ/elfeed-search-tag-saved ()
  (interactive)
  (let ((elfeed-search-remain-on-entry t))
    (elfeed-search-tag-all 'saved)
    (elfeed-search-untag-all 'unread))
  (forward-line))
(defun circ/elfeed-show-tag-saved ()
  (interactive)
  (elfeed-show-tag 'saved))

;; Unused
(defun circ/elfeed-search-untag-saved ()
  (interactive)
  (elfeed-search-untag-all 'saved))
(defun circ/elfeed-show-untag-saved ()
  (interactive)
  (elfeed-show-untag 'saved))

(defun circ/elfeed-search-untag-saved-unread ()
  (interactive)
  (let ((elfeed-search-remain-on-entry t))
    (elfeed-search-untag-all 'saved)
    (elfeed-search-untag-all 'unread))
  (forward-line))
(defun circ/elfeed-show-untag-saved-unread ()
  (interactive)
  (elfeed-show-untag 'saved)
  (elfeed-show-untag 'unread))
#+END_SRC
*** Tag filtering
Completing read tag editing
#+BEGIN_SRC emacs-lisp
(defun circ/elfeed-search-filter-tag ()
  (interactive)
  (unwind-protect
      (let* ((tags (mapcar 'symbol-name (elfeed-db-get-all-tags)))
             (current-filter elfeed-search-filter)
             (current-tags (plist-get (elfeed-search-parse-filter current-filter)
                                      :must-have))
             (tag-candidates (append
                              (mapcar (lambda (tag)
                                        (concat "+" tag))
                                      tags)
                              (mapcar (lambda (tag)
                                        (concat "-" tag))
                                      tags)))
             (new-tag (completing-read (format "[%s]: " current-filter) tag-candidates nil t))
             (filter-list (split-string elfeed-search-filter " " t)))
        (if (member new-tag filter-list)
            (circ/elfeed--remove-search-filter-tag new-tag)
          (circ/elfeed--add-search-filter-tag new-tag))))
  (circ/elfeed-search-filter-tag))

(defun circ/elfeed--add-search-filter-tag (tag)
  (let ((filter-list (split-string elfeed-search-filter " " t)))
    (setq elfeed-search-filter (string-join (append filter-list (list tag)) " "))
    (elfeed-search-update :force)))

(defun circ/elfeed--remove-search-filter-tag (tag)
  (let ((filter-list (split-string elfeed-search-filter " " t)))
    (setq elfeed-search-filter (string-join (delete tag filter-list) " "))
    (elfeed-search-update :force)))
#+END_SRC

*** Saved searches
#+BEGIN_SRC emacs-lisp
(defun circ/elfeed-search-saved ()
  (interactive)
  (setq elfeed-search-filter "+saved")
  (elfeed-search-update :force))
#+END_SRC
*** Auto tagging of length of videos
#+BEGIN_SRC emacs-lisp
(defun circ/elfeed-tag-yt-length ()
  (interactive)
  (dolist (entry (elfeed-search-selected))
    (let* ((link (elfeed-entry-link entry))
           (title (elfeed-entry-title entry))
           (len (split-string
                 (circ/strip-last-newline
                  (shell-command-to-string
                   (concat "youtube-dl --get-duration "
                           "\"" link "\"")))
                 ":"))
           (rlen (cond ((= (length len) 3)
                        (* (/ (+ (+ (* (string-to-number (car len)) 60)
                                    (string-to-number (cadr len))) 10) 10) 10))
                       ((= (length len) 2)
                        (* (/ (+ (string-to-number (car len)) 10) 10) 10))
                       (t -1)))
           (tag (concat (number-to-string rlen) "mins")))
      (when (> rlen 0)
        (elfeed-tag entry (intern tag))
        (message "Tagged \"%s\" as \"%s\"" title tag))))
  (elfeed-search-update--force))
#+END_SRC

*** Setting entry faces for tags
#+begin_src emacs-lisp
(defface circ/elfeed-search-saved-face
  '((t :foreground "#ffff99"))
  "Face for saved entries"
  :group 'elfeed)

(defface circ/elfeed-search-video-face
  '((t :foreground "#99ffff"))
  "Face for video entries"
  :group 'elfeed)

;; Define faces for tagged entries. Earlier faces take priority.
(setq elfeed-search-face-alist '((unread elfeed-search-unread-title-face)
                                 (video circ/elfeed-search-video-face)
                                 (saved circ/elfeed-search-saved-face)
                                 ))
#+end_src
*** Evil Keybindings
#+BEGIN_SRC emacs-lisp
(evil-set-initial-state 'elfeed-search-mode 'motion)
(evil-define-key 'motion elfeed-search-mode-map
  (kbd "RET") 'elfeed-search-show-entry
  (kbd "S-<return>") 'elfeed-search-browse-url
  "b" 'elfeed-search-browse-url
  "y" 'elfeed-search-yank
  (kbd "SPC") 'scroll-up-command
  (kbd "S-SPC") 'scroll-down-command
  (kbd "TAB") 'elfeed-show-next-link
  "/" 'elfeed-search-live-filter
  "r" 'elfeed-search-update--force
  "R" 'elfeed-search-fetch
  "gR" 'circ/elfeed-db-reload
  "f" 'circ/elfeed-search-filter-tag
  "F" 'elfeed/search-clear-filter
  "o" 'nil
  "or" 'circ/elfeed-search-open-eww-readable
  "oe" 'circ/elfeed-search-open-eww
  "ov" 'circ/elfeed-search-open-in-mpv
  "ob" 'elfeed-search-browse-url
  "gf" 'circ/open-rss-elfeed-file
  "gs" 'circ/elfeed-search-saved
  "C-d" 'evil-scroll-down
  "C-u" 'evil-scroll-up
  "q" 'circ/elfeed-save-and-close)

(evil-define-key '(motion visual) elfeed-search-mode-map
  "+" 'elfeed-search-tag-all
  "-" 'elfeed-search-untag-all
  "u" 'circ/elfeed-search-untag-saved-unread
  "m" 'circ/elfeed-search-tag-saved)

(evil-set-initial-state 'elfeed-show-mode 'motion)
(evil-define-key 'motion elfeed-show-mode-map
  "b" 'elfeed-show-visit
  (kbd "SPC") 'scroll-up-command
  (kbd "S-SPC") 'scroll-down-command
  (kbd "<tab>") 'elfeed-show-next-link
  (kbd "TAB") 'elfeed-show-next-link
  "/" 'elfeed-show-new-live-search
  "+" 'elfeed-show-tag
  "-" 'elfeed-show-untag
  "]]" 'elfeed-show-next
  "[[" 'elfeed-show-prev
  "J" 'elfeed-show-next
  "K" 'elfeed-show-prev
  "n" 'elfeed-show-next
  "p" 'elfeed-show-prev
  "r" 'elfeed-show-refresh
  "q" 'elfeed-kill-buffer
  "o" 'nil
  "or" 'circ/elfeed-show-open-eww-readable
  "oe" 'circ/elfeed-show-open-eww
  "ov" 'circ/elfeed-show-open-in-mpv
  "ob" 'elfeed-show-visit
  "y" 'elfeed-show-yank
  "C-d" 'evil-scroll-down
  "C-u" 'evil-scroll-up
  "m" 'circ/elfeed-show-tag-saved
  "u" 'circ/elfeed-show-untag-saved)
#+END_SRC
** emux
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/emux")
(require 'emux)
#+END_SRC
** abbrev
#+BEGIN_SRC emacs-lisp
(setq abbrev-file-name "~/pims/abbrev_defs.el")
(setq-default abbrev-mode t)

(defun circ/add-abbrev ()
  (interactive)
  (let ((num-of-words (cond ((region-active-p) (count-words-region
                                                (region-beginning)
                                                (region-end)))
                            (t 1)))
        (mode-specific (y-or-n-p "Specific to mode? ")))
    (goto-char (region-end))
    (deactivate-mark)
    (if mode-specific
        (add-mode-abbrev num-of-words)
      (add-global-abbrev num-of-words)))
  (write-abbrev-file abbrev-file-name t))

(defun circ/reload-abbrevs ()
  (interactive)
  (kill-all-abbrevs)
  (read-abbrev-file))
#+END_SRC
** avy
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/avy-0.5.0")
(require 'avy)
#+END_SRC
** go-mode
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/go-mode.el-fdf46fe0e110a8e0dddb5aac4ab20a93ee9c5d88")
(autoload 'go-mode "go-mode" nil t)
(add-to-list 'auto-mode-alist '("\\.go\\'" . go-mode))
(add-hook 'before-save-hook 'gofmt-before-save)
#+END_SRC
** doc-view
#+BEGIN_SRC emacs-lisp
(evil-set-initial-state 'doc-view-mode 'motion)

(evil-define-key 'motion doc-view-mode-map
  "q" 'image-kill-buffer

  "h" 'image-backward-hscroll
  "j" 'doc-view-next-line-or-next-page
  "k" 'doc-view-previous-line-or-previous-page
  "l" 'image-forward-hscroll

  "H" 'circ/doc-view-backward-hscroll-fast
  "J" 'circ/doc-view-next-line-or-next-page-fast
  "K" 'circ/doc-view-previous-line-or-previous-page-fast
  "L" 'circ/doc-view-forward-hscroll-fast

  "]" 'doc-view-next-page
  "[" 'doc-view-previous-page

  (kbd "SPC") 'doc-view-scroll-up-or-next-page
  (kbd "S-SPC") 'doc-view-scroll-down-or-previous-page
  "gg" 'doc-view-first-page
  "G" 'doc-view-last-page
  "gp" 'doc-view-goto-page
  (kbd "RET") 'image-next-line

  ;; zoom
  "+" 'doc-view-enlarge
  "=" 'doc-view-enlarge
  "0" 'doc-view-scale-reset
  "-" 'doc-view-shrink
  "_" 'doc-view-shrink

  "zw" 'doc-view-fit-width-to-window ; Like evil-image.
  "zh" 'doc-view-fit-height-to-window ; Like evil-image.
  "zp" 'doc-view-fit-page-to-window
  "X" 'doc-view-kill-proc

  "ss" 'doc-view-set-slice
  "sm" 'doc-view-set-slice-using-mouse
  "sb" 'doc-view-set-slice-from-bounding-box
  "sr" 'doc-view-reset-slice

  "n" 'doc-view-search-next-match
  "N" 'doc-view-search-previous-match
  "/" 'circ/doc-view-search
  "?" 'circ/doc-view-search-backward
  "C-t" 'doc-view-show-tooltip
  "C-c C-c" 'doc-view-toggle-display
  "C-c C-t" 'doc-view-open-text

  ;; refresh
  "r" 'doc-view-revert-buffer)
#+END_SRC
*** Faster scroll functions
#+BEGIN_SRC emacs-lisp
(defvar circ/doc-view-scroll-fast-rate 10)
(defun circ/doc-view-backward-hscroll-fast ()
  (interactive)
  (image-backward-hscroll circ/doc-view-scroll-fast-rate))
(defun circ/doc-view-forward-hscroll-fast ()
  (interactive)
  (image-forward-hscroll circ/doc-view-scroll-fast-rate))
(defun circ/doc-view-next-line-or-next-page-fast ()
  (interactive)
  (doc-view-next-line-or-next-page circ/doc-view-scroll-fast-rate))
(defun circ/doc-view-previous-line-or-previous-page-fast ()
  (interactive)
  (doc-view-previous-line-or-previous-page circ/doc-view-scroll-fast-rate))
#+END_SRC
*** Doc view search
#+BEGIN_SRC emacs-lisp
(defun circ/doc-view-search ()
  (interactive)
  (doc-view-search t))
(defun circ/doc-view-search-backward ()
  (interactive)
  (doc-view-search-backward t))
#+END_SRC
** image-mode
#+BEGIN_SRC emacs-lisp
(evil-set-initial-state 'image-mode 'motion)

(evil-define-key 'motion image-mode-map
  "q" 'image-kill-buffer

  "h" 'image-backward-hscroll
  "l" 'image-forward-hscroll
  "j" 'image-next-line
  "k" 'image-previous-line

  "H" 'circ/image-backward-hscroll-fast
  "L" 'circ/image-forward-hscroll-fast
  "J" 'circ/image-next-line-fast
  "K" 'circ/image-previous-line-fast

  "gg" 'image-bob
  "G" 'image-eob
  "RET" 'image-toggle-animation
  "a0" 'image-reset-speed
  "ar" 'image-reverse-speed
  "F" 'image-goto-frame
  "," 'image-previous-frame ; mplayer/mpv style
  "." 'image-next-frame ; mplayer/mpv style
  "{" 'image-decrease-speed ; mplayer/mpv style
  "}" 'image-increase-speed ; mplayer/mpv style

  "zh" 'image-transform-fit-to-height
  "zw" 'image-transform-fit-to-width

  "+" 'circ/image-mode-zoom-in
  "=" 'circ/image-mode-zoom-in
  "0" 'circ/image-mode-zoom-reset
  "-" 'circ/image-mode-zoom-out
  "_" 'circ/image-mode-zoom-out

  "[[" 'image-previous-file
  "]]" 'image-next-file
  "gk" 'image-previous-file
  "gj" 'image-next-file

  "C-c C-c" 'image-toggle-display)
#+END_SRC

*** Faster scroll functions
#+BEGIN_SRC emacs-lisp
(defvar circ/image-scroll-fast-rate 10)
(defun circ/image-backward-hscroll-fast ()
  (interactive)
  (image-backward-hscroll circ/image-scroll-fast-rate))
(defun circ/image-forward-hscroll-fast ()
  (interactive)
  (image-forward-hscroll circ/image-scroll-fast-rate))
(defun circ/image-next-line-fast ()
  (interactive)
  (image-next-line circ/image-scroll-fast-rate))
(defun circ/image-previous-line-fast ()
  (interactive)
  (image-previous-line circ/image-scroll-fast-rate))
#+END_SRC

*** Zoom functions
#+BEGIN_SRC emacs-lisp
(defun circ/image-mode-zoom-reset ()
  (interactive)
  (image-transform-set-scale 1))
(defun circ/image-mode-zoom-in ()
  (interactive)
  (image-transform-set-scale (* image-transform-scale 1.1)))
(defun circ/image-mode-zoom-out ()
  (interactive)
  (image-transform-set-scale (* image-transform-scale 0.9)))
#+END_SRC
** dired
*** Set up
#+begin_src emacs-lisp
(require 'dired-x)
(setq dired-dwim-target t)
(setq dired-omit-files "^\\.?#\\|^\\.$\\|^\\.\\.$\\|^\\.")
(setq dired-listing-switches "-Gghal")
(setq dired-guess-shell-alist-user '(("\\.flac\\'" "mpv")
                                     ("\\.mp3\\'" "mpv")))
#+end_src

*** reuse directory when going up directory
#+BEGIN_SRC emacs-lisp
(defun circ/dired-up-directory ()
  (interactive)
  (find-alternate-file ".."))
#+END_SRC
*** Get directory size
#+begin_src emacs-lisp
(defun circ/dired-du-current ()
  (interactive)
  (message "Directory size: %s"
           (circ/strip-last-newline
            (shell-command-to-string
             "du -h --max-depth 0"))))

(defun circ/dired-du ()
  (interactive)
  (let ((dir (dired-get-file-for-visit)))
    (when (file-directory-p dir)
      (message "Directory size: %s"
               (circ/strip-last-newline
                (shell-command-to-string
                 (format "du -h --max-depth 0 '%s'" dir)))))))
#+end_src

*** Maybe open with external application
#+begin_src emacs-lisp
(setq circ/dired-external-app-extensions
      '("mp3" "flac"
        "mkv" "mp4" "flv" "avi"))
(defun circ/dired-maybe-open-with-external-app ()
  "If file extension matches with any in
`circ/dired-external-app-extensions' then open with
`browse-url-of-dired-file' else open with `dired-find-file'"
  (interactive)
  (cond ((member (file-name-extension (dired-get-file-for-visit))
                 circ/dired-external-app-extensions)
          (browse-url-of-dired-file))
         (t
          (dired-find-file))))
(defun circ/dired-maybe-open-with-external-app-other-window ()
  "If file extension matches with any in
`circ/dired-external-app-extensions' then open with
`browse-url-of-dired-file' else open with `dired-find-file-other-window'"
  (interactive)
  (cond ((member (file-name-extension (dired-get-file-for-visit))
                 circ/dired-external-app-extensions)
          (browse-url-of-dired-file))
         (t
          (dired-find-file-other-window))))
#+end_src

*** Keybindings
#+BEGIN_SRC emacs-lisp
(evil-define-key 'normal dired-mode-map
  "q" 'circ/kill-this-buffer
  "r" 'revert-buffer

  "/" 'dired-isearch-filenames
  "gg" 'evil-goto-first-line
  "G" 'evil-goto-line

  "h" 'dired-up-directory
  "j" 'dired-next-line
  "k" 'dired-previous-line
  "l" 'dired-find-file
  "L" 'dired-find-file-other-window

  "i" 'dired-maybe-insert-subdir
  "I" 'dired-kill-subdir
  (kbd "TAB") 'dired-hide-subdir

  "o" 'circ/dired-maybe-open-with-external-app
  "O" 'circ/dired-maybe-open-with-external-app-other-window
  "W" 'browse-url-of-dired-file

  "v" 'dired-view-file

  "m" 'dired-mark
  "d" 'dired-flag-file-deletion
  "u" 'dired-unmark
  "U" 'dired-unmark-all-marks
  "t" 'dired-toggle-marks
  "x" 'dired-do-flagged-delete

  "!" 'dired-do-shell-command
  "&" 'dired-do-async-shell-command
  "=" 'ediff

  "eM" 'dired-do-chmod
  "eO" 'dired-do-chown
  "eG" 'dired-do-chgrp
  "eT" 'dired-do-touch
  "eZ" 'dired-do-compress
  "eS" 'dired-do-symlink
  "em" 'dired-do-rename
  "ec" 'dired-do-copy
  "er" 'dired-do-rename-regexp
  "et" 'dired-show-file-type
  "ed" 'circ/dired-du
  "eD" 'circ/dired-du-current

  "ad" 'dired-create-directory

  "E" 'dired-toggle-read-only
  )
(evil-set-initial-state 'wdired-mode 'normal)
(evil-define-key 'normal wdired-mode-map
  "ZQ" 'wdired-abort-changes
  "ZZ" 'wdired-finish-edit
  (kbd "<escape>") 'wdired-exit
  "q" 'wdired-exit
)
#+END_SRC

** View mode
#+begin_src emacs-lisp
(evil-define-key 'normal view-mode-map
  "q" 'View-quit)
(add-hook 'view-mode-hook 'evil-normalize-keymaps)
#+end_src
** ibuffer
#+begin_src emacs-lisp
(evil-set-initial-state 'ibuffer-mode 'normal)
(evil-define-key 'normal ibuffer-mode-map
  "q" 'circ/kill-this-buffer
  "r" 'ibuffer-update
  "R" 'ibuffer-redisplay

  "o" 'ibuffer-visit-buffer
  (kbd "RET") 'ibuffer-visit-buffer

  "m" 'ibuffer-mark-forward
  "u" 'ibuffer-unmark-forward
  "U" 'ibuffer-unmark-all-marks
  "d" 'ibuffer-mark-for-delete
  "D" 'ibuffer-do-delete

  "MM" 'ibuffer-mark-by-mode
  "Mm" 'ibuffer-mark-modified-buffers
  "Mu" 'ibuffer-mark-unsaved-buffers
  "Ms" 'ibuffer-mark-special-buffers
  "Mr" 'ibuffer-mark-read-only-buffers
  "M/" 'ibuffer-mark-dired-buffers
  "Me" 'ibuffer-mark-dissociated-buffers
  "Mh" 'ibuffer-mark-help-buffers
  "Mz" 'ibuffer-mark-compressed-file-buffers
  "Mo" 'ibuffer-mark-old-buffers

  "es" 'ibuffer-do-save
  "ex" 'ibuffer-do-shell-command-file
  "eX" 'ibuffer-do-shell-command-pipe
  "ed" 'ibuffer-do-delete

  (kbd "f RET") 'ibuffer-filter-by-mode
  "fq" 'ibuffer-filter-disable
  "fm" 'ibuffer-filter-by-used-mode
  "fM" 'ibuffer-filter-by-derived-mode
  "fn" 'ibuffer-filter-by-name
  "f*" 'ibuffer-filter-by-starred-name
  "ff" 'ibuffer-filter-by-filename
  "fb" 'ibuffer-filter-by-basename
  "f." 'ibuffer-filter-by-file-extension
  "f<" 'ibuffer-filter-by-size-lt
  "f>" 'ibuffer-filter-by-size-gt
  "fi" 'ibuffer-filter-by-modified
  "fv" 'ibuffer-filter-by-visiting-file
  "fc" 'ibuffer-filter-by-content
  "fe" 'ibuffer-filter-by-predicate

  "," 'ibuffer-toggle-sorting-mode
  "si" 'ibuffer-invert-sorting
  "sa" 'ibuffer-do-sort-by-alphabetic
  "sv" 'ibuffer-do-sort-by-recency
  "ss" 'ibuffer-do-sort-by-size
  "sf" 'ibuffer-do-sort-by-filename/process
  "sm" 'ibuffer-do-sort-by-major-mode
)
#+end_src
** image-dired
#+begin_src emacs-lisp
(evil-define-key 'normal image-dired-thumbnail-mode-map
  "q" 'circ/kill-this-buffer

  "h" 'image-dired-backward-image
  "l" 'image-dired-forward-image
  "j" 'image-dired-next-line
  "k" 'image-dired-previous-line

  (kbd "RET") 'image-dired-display-thumbnail-original-image
  "o" 'image-dired-display-thumbnail-original-image
  "[" 'image-dired-display-previous-thumbnail-original
  "]" 'image-dired-display-next-thumbnail-original
)
(evil-define-key 'normal image-dired-display-image-mode-map
  "q" 'circ/kill-this-buffer
)
(add-hook 'image-dired-display-image-mode-hook 'evil-normalize-keymaps)
#+end_src
** vc-annotate-mode
*** History for jumping around revisions
When jumping through revisions, there is no history, and therefore no way to go
back to the previous revision you were looking at. Implement this.
#+begin_src emacs-lisp
(defvar-local circ/vc-annotate-version-history '())
(defvar-local circ/vc-annotate-version-history-index 0)

(defun circ/vc-annotate ()
  "Push the current revision onto the vc-annotate history
stack. Usually I would use the hook, but using the hook doesn't
work as the `vc-annotate-parent-rev' variable isn't set properly
at the time of running the hook."
  (interactive)
  (call-interactively 'vc-annotate)
  (circ/vc-annotate-push-version-to-history))

(defun circ/vc-annotate-push-version-to-history ()
  (interactive)
  (setq circ/vc-annotate-version-history
        (cons vc-annotate-parent-rev
              (subseq circ/vc-annotate-version-history
                      circ/vc-annotate-version-history-index)))
  (setq circ/vc-annotate-version-history-index 0))

(defun circ/vc-annotate-history-back ()
  (interactive)
  (let ((history circ/vc-annotate-version-history)
        (index (1+ circ/vc-annotate-version-history-index)))
    (when (<= (length history) index)
      (error "Already at earliest history revision"))
    (vc-annotate-warp-revision (nth index history))
    (setq circ/vc-annotate-version-history history)
    (setq circ/vc-annotate-version-history-index index)))

(defun circ/vc-annotate-history-forward ()
  (interactive)
  (let ((history circ/vc-annotate-version-history)
        (index (1- circ/vc-annotate-version-history-index)))
    (when (< index 0)
      (error "Already at latest history revision"))
    (vc-annotate-warp-revision (nth index history))
    (setq circ/vc-annotate-version-history history)
    (setq circ/vc-annotate-version-history-index index)))

;; TODO: I think this should be a macro, but I don't know how macros work.
(defun circ/new-history-branch (fun)
  (let ((history circ/vc-annotate-version-history)
        (index circ/vc-annotate-version-history-index))

    (funcall fun)

    (setq circ/vc-annotate-version-history history)
    (setq circ/vc-annotate-version-history-index index)
    (circ/vc-annotate-push-version-to-history)))

(defun circ/vc-annotate-revision-previous-to-line ()
  (interactive)
  (circ/new-history-branch 'vc-annotate-revision-previous-to-line))

(defun circ/vc-annotate-revision-at-line ()
  (interactive)
  (circ/new-history-branch 'vc-annotate-revision-at-line))

(defun circ/vc-annotate-working-revision ()
  (interactive)
  (circ/new-history-branch 'vc-annotate-working-revision))
#+end_src
*** Keybindings
#+BEGIN_SRC emacs-lisp
(evil-set-initial-state 'vc-annotate-mode 'motion)
(evil-define-key 'motion vc-annotate-mode-map
  "q" 'circ/kill-this-buffer

  "a" 'circ/vc-annotate-revision-previous-to-line
  "J" 'circ/vc-annotate-revision-at-line
  "W" 'circ/vc-annotate-working-revision

  "d" 'vc-annotate-show-diff-revision-at-line
  "=" 'vc-annotate-show-diff-revision-at-line
  "D" 'vc-annotate-show-changeset-diff-revision-at-linee

  "F" 'vc-annotate-find-revision-at-line

  "gl" 'vc-annotate-show-log-revision-at-line

  (kbd "RET") 'vc-annotate-goto-line
  "o" 'vc-annotate-goto-line

  "]" 'vc-annotate-next-revision
  "[" 'vc-annotate-prev-revision

  "H" 'circ/vc-annotate-history-back
  "L" 'circ/vc-annotate-history-forward
)
(add-hook 'vc-annotate-mode-hook 'circ/disable-evil-quickscope-mode)
#+END_SRC

** Diff
#+begin_src emacs-lisp
(evil-set-initial-state 'diff-mode 'motion)
(evil-define-key 'motion diff-mode-map
  "q" 'circ/kill-this-buffer
)
#+end_src

** git log view mode
#+begin_src emacs-lisp
(evil-set-initial-state 'vc-git-log-view-mode 'motion)
(evil-define-key 'motion vc-git-log-view-mode-map
  "q" 'circ/kill-this-buffer
)
#+end_src

** proced
#+begin_src emacs-lisp
(evil-set-initial-state 'proced-mode 'motion)
(evil-define-key 'motion proced-mode-map
  "q" 'circ/kill-this-buffer
  "r" 'revert-buffer

  "m" 'proced-mark
  "M" 'proced-mark-all
  ;"u" 'proced-unmark ;; Think of a better key
  "U" 'proced-unmark-all
  "t" 'proced-toggle-marks
  "c" 'proced-mark-children
  "p" 'proced-mark-parents

  "u" 'proced-undo

  "x" 'proced-send-signal
  "n" 'proced-renice

  "O" 'proced-omit-processes

  "sO" 'proced-sort-interactive
  "sc" 'proced-sort-pcpu
  "sm" 'proced-sort-pmem
  "sp" 'proced-sort-pid
  "ss" 'proced-sort-start
  "st" 'proced-sort-time
  "su" 'proced-sort-user

  "f" 'proced-filter-interactive
  "F" 'proced-format-interactive
)
#+end_src
** Bookmarks
#+begin_src emacs-lisp
(evil-set-initial-state 'bookmark-bmenu-mode 'normal)
(evil-define-key 'normal bookmark-bmenu-mode-map
  "q" 'circ/kill-this-buffer
  "r" 'revert-buffer

  "j" 'next-line
  "k" 'previous-line

  "o" 'bookmark-bmenu-this-window
  "O" 'bookmark-bmenu-switch-other-window

  "m" 'bookmark-bmenu-mark
  "M" 'bookmark-bmenu-mark-all
  "u" 'bookmark-bmenu-unmark
  "U" 'bookmark-bmenu-unmark-all
  "d" 'bookmark-bmenu-delete
  "x" 'bookmark-bmenu-execute-deletions
  "/" 'bookmark-bmenu-search
  (kbd "DEL") 'bookmark-bmenu-backup-unmark

  "s" 'bookmark-bmenu-save
  "l" 'bookmark-bmenu-load

  "er" 'bookmark-bmenu-rename
  "eR" 'bookmark-bmenu-relocate
  "ea" 'bookmark-bmenu-show-annotation
  "eA" 'bookmark-bmenu-show-all-annotations
  "ee" 'bookmark-bmenu-edit-annotation
)
(add-hook 'bookmark-bmenu-mode-hook 'circ/disable-evil-quickscope-mode)

(evil-set-initial-state 'bookmark-edit-annotation-mode 'normal)
(evil-define-key 'normal bookmark-edit-annotation-mode-map
  "q" 'circ/bookmark-send-edited-annotation
  (kbd "<escape>") 'circ/bookmark-send-edited-annotation
  "ZQ" 'circ/kill-this-buffer
  "ZZ" 'bookmark-send-edited-annotation
)
#+end_src
*** Save annotations
#+begin_src emacs-lisp
(defun circ/bookmark-send-edited-annotation ()
  (interactive)
  (if (y-or-n-p "Save changes?")
      (bookmark-send-edited-annotation)
    (circ/kill-this-buffer)))
#+end_src
*** Annotation comment
#+begin_src emacs-lisp
(defun circ/bookmark-default-annotation-text (bookmark-name)
  (concat (format-message
           "#  Type the annotation for bookmark `%s' here.\n" bookmark-name)
          (format-message
           "#  All lines which start with a `#' will be deleted.\n")
          "#  Type [q] in normal mode when done.\n"
          "#\n"
          "#  Date:    " (current-time-string) "\n"))
(advice-add 'bookmark-default-annotation-text :override
            #'circ/bookmark-default-annotation-text)
#+end_src
** Help
#+begin_src emacs-lisp
(defun circ/disable-linum-mode ()
  "Counteract global nlinum mode"
  (add-hook 'after-change-major-mode-hook
            (lambda () (nlinum-mode 0))
            :append :local))

(add-hook 'help-mode-hook 'circ/disable-linum-mode)
#+end_src
** general
#+BEGIN_SRC emacs-lisp
(add-to-list
 'load-path
 "~/.emacs.d/packages/general-2d2dd1d532fa75c1ed0c010d50e817ce43e58066/")
(require 'general)
(general-auto-unbind-keys)
#+END_SRC

* Keybindings
** Aliases
To keep the code nice and clean.
#+BEGIN_SRC emacs-lisp
(defun circ/alias-text-scale-down () (interactive) (text-scale-adjust -1))
(defun circ/alias-text-scale-up   () (interactive) (text-scale-adjust +1))

(defun circ/alias-search-buffer () (interactive) (swiper (ivy-thing-at-point)))

(defun circ/alias-transpose-buffer-left  () (interactive) (circ/transpose-buffers-left t))
(defun circ/alias-transpose-buffer-down  () (interactive) (circ/transpose-buffers-down t))
(defun circ/alias-transpose-buffer-up    () (interactive) (circ/transpose-buffers-up t))
(defun circ/alias-transpose-buffer-right () (interactive) (circ/transpose-buffers-right t))

(defun circ/alias-cast-buffer-left  () (interactive) (circ/cast-buffer-left t))
(defun circ/alias-cast-buffer-down  () (interactive) (circ/cast-buffer-down t))
(defun circ/alias-cast-buffer-up    () (interactive) (circ/cast-buffer-up t))
(defun circ/alias-cast-buffer-right () (interactive) (circ/cast-buffer-right t))

(defun circ/alias-duplicate-buffer-left  () (interactive) (circ/duplicate-buffer-left t))
(defun circ/alias-duplicate-buffer-down  () (interactive) (circ/duplicate-buffer-down t))
(defun circ/alias-duplicate-buffer-up    () (interactive) (circ/duplicate-buffer-up t))
(defun circ/alias-duplicate-buffer-right () (interactive) (circ/duplicate-buffer-right t))

(defun circ/alias-erlang-find-tag () (interactive) (erlang-find-tag (erlang-default-function-or-module)))

(defun circ/alias-bash-shell () (interactive) (ansi-term "/bin/bash"))
(defun circ/alias-clip-shell () (interactive) (ansi-term "/usr/bin/clisp"))
(defun circ/alias-python-shell () (interactive) (ansi-term "/usr/bin/python"))

(defun circ/alias-org-force-publish () (interactive) (org-publish-current-project t))

(defun circ/alias-org-agenda-agenda () (interactive) (org-agenda nil "A"))
(defun circ/alias-org-agenda-tasks  () (interactive) (org-agenda nil "T"))

(defun circ/alias-sh-cmd-whole-buffer () (interactive) (circ/sh-cmd nil t nil))
(defun circ/alias-sh-cmd-split-lines () (interactive) (circ/sh-cmd nil nil t))
(defun circ/alias-sh-cmd-whole-buffer-split-lines () (interactive) (circ/sh-cmd nil t t))

(setq circ/vert-resize-delta 5)
(setq circ/horz-resize-delta 10)

(defvar circ/vert-resize-delta 1)
(defvar circ/horz-resize-delta 1)
(defun circ/alias-shrink-win-horz  () (interactive) (shrink-window-horizontally circ/horz-resize-delta))
(defun circ/alias-enlarge-win-horz () (interactive) (enlarge-window-horizontally circ/horz-resize-delta))
(defun circ/alias-shrink-win-vert  () (interactive) (shrink-window circ/vert-resize-delta))
(defun circ/alias-enlarge-win-vert () (interactive) (enlarge-window circ/vert-resize-delta))
#+END_SRC

** Helper Functions
#+BEGIN_SRC emacs-lisp
(setq circ/p1-prefix-normal   "C-M-S-")
(setq circ/p1-prefix-special  "C-M-")
(setq circ/p1-prefix-standard "M-f")

(setq circ/p2-prefix-normal   "s-M-S-")
(setq circ/p2-prefix-special  "s-M-")
(setq circ/p2-prefix-standard "M-d")

(setq circ/p3-prefix-normal   "s-C-S-")
(setq circ/p3-prefix-special  "s-C-")
(setq circ/p3-prefix-standard "M-s")

(setq circ/p4-prefix-normal   "s-C-M-")
(setq circ/p4-prefix-special  "s-C-M-")
(setq circ/p4-prefix-standard "M-a")

(defun circ/p1 (key command description &optional keymap)
  (let* ((prefix-normal   circ/p1-prefix-normal)
         (prefix-special  circ/p1-prefix-special)
         (standard-prefix circ/p1-prefix-standard)
         (prefix-key (cond ((string= key ";") (concat prefix-special ":"))
                           ((string= key "-") (concat prefix-special "_"))
                           ((string= key "=") (concat prefix-special "+"))
                           ((string= key ",") (concat prefix-special "<"))
                           ((string= key ".") (concat prefix-special ">"))
                           ((string= key "/") (concat prefix-special "?"))
                           (t (concat prefix-normal key))))
         (standard-prefix-key (concat standard-prefix " " key)))
    (circ/set-keys prefix-key standard-prefix-key command description keymap)))

(defun circ/p2 (key command description &optional keymap)
  (let* ((prefix-normal   circ/p2-prefix-normal)
         (prefix-special  circ/p2-prefix-special)
         (standard-prefix circ/p2-prefix-standard)
         (prefix-key (cond (t (concat prefix-special (upcase (substring key 0 1)) (substring key 1)))))
         (standard-prefix-key (concat standard-prefix " " key)))
    (circ/set-keys prefix-key standard-prefix-key command description keymap)))

(defun circ/p3 (key command description &optional keymap)
  (let* ((prefix-normal   circ/p3-prefix-normal)
         (prefix-special  circ/p3-prefix-special)
         (standard-prefix circ/p3-prefix-standard)
         (prefix-key (cond (t (concat prefix-special (upcase (substring key 0 1)) (substring key 1)))))
         (standard-prefix-key (concat standard-prefix " " key)))
    (circ/set-keys prefix-key standard-prefix-key command description keymap)))

(defun circ/p4 (key command description &optional keymap)
  (let* ((prefix-normal   circ/p4-prefix-normal)
         (prefix-special  circ/p4-prefix-special)
         (standard-prefix circ/p4-prefix-standard)
         (prefix-key (cond (t (concat prefix-normal key ))))
         (standard-prefix-key (concat standard-prefix " " key)))
    (circ/set-keys prefix-key standard-prefix-key command description keymap)))

(defun circ/set-keys (prefix-key standard-prefix-key command description &optional keymap)
  (cond (command
         (circ/set-key prefix-key command description keymap)
         (circ/set-key standard-prefix-key command description keymap))
        (t
         (circ/set-prefix prefix-key description keymap)
         (circ/set-prefix standard-prefix-key description keymap))))

(defun circ/set-prefix (key description &optional keymap)
  (cond (keymap
         (general-define-key
           :keymaps keymap
           :states '(normal insert visual operator motion emacs)
           key (list :ignore t :which-key description)))
        (t
         (general-define-key
           :states '(normal insert visual operator motion emacs)
           key (list :ignore t :which-key description)))))

(defun circ/set-key (key command description &optional keymap)
  (cond (keymap
         (general-define-key
          :keymaps keymap
          :states '(normal insert visual operator motion emacs)
          key (list command :which-key description)))
        (t
         (general-define-key
          :states '(normal insert visual operator motion emacs)
          key (list command :which-key description)))))

#+END_SRC

** Term Mode Keys
Evil-mode interferes with the normal bash bindings. They must be dealt with.

*** C-a     - Go to beginning of line
#+BEGIN_SRC emacs-lisp
(evil-define-key 'insert term-raw-map (kbd "C-a") 'term-send-raw)
#+END_SRC

*** C-e     - Go to end of line
#+BEGIN_SRC emacs-lisp
(evil-define-key 'insert term-raw-map (kbd "C-e") 'term-send-raw)
#+END_SRC

*** M-f     - Go to next word
Interferes with my custom invokers.

*** M-b     - Go to previous word
Already build in.

*** C-x x   - Toggle point between current position and start of line
C-x interferes with emacs a lot. I am leaving this out one.

*** M-d     - Delete next word
Interferes with my custom invokers.

*** C-x C-e - Edit the current command in your text editor
Danger! Having this makes it too easy to invoke vim from within emacs.

Bad idea.

*** C--     - Undo previous action(s)
Does anyone use this? I won't. Leaving it out.

*** C-w     - Cut current word before the cursor
#+BEGIN_SRC emacs-lisp
(evil-define-key 'insert term-raw-map (kbd "C-w") 'term-send-raw)
#+END_SRC

*** C-k     - Cut from cursor to end of line
#+BEGIN_SRC emacs-lisp
(evil-define-key 'insert term-raw-map (kbd "C-k") 'term-send-raw)
#+END_SRC

*** C-u     - Cut from cursor to start of line
#+BEGIN_SRC emacs-lisp
(evil-define-key 'insert term-raw-map (kbd "C-u") 'term-send-raw)
#+END_SRC

*** C-y     - Paste the cut buffer at current position
#+BEGIN_SRC emacs-lisp
(evil-define-key 'insert term-raw-map (kbd "C-y") 'term-send-raw)
#+END_SRC

*** C-d     - Send EOF / Delete current character
#+BEGIN_SRC emacs-lisp
(evil-define-key 'insert term-raw-map (kbd "C-d") 'term-send-raw)
#+END_SRC

*** C-l     - Clear the terminal screen
Already built-in.

*** C-z     - Send current command to the background.
#+BEGIN_SRC emacs-lisp
;; C-z is more useful as a switch between evil and emacs states
;; So a command is available instead
(defun term-send-current-command-to-background ()
  (interactive)
  (term-send-raw-string "\C-z"))
#+END_SRC

*** C-r - Search history
#+BEGIN_SRC emacs-lisp
;(evil-define-key 'insert term-raw-map (kbd "C-r") 'term-send-raw)
(evil-define-key 'insert term-raw-map (kbd "C-r") 'circ/bash-history-search)
#+END_SRC

*** <delete> - Delete forward
#+begin_src emacs-lisp
(evil-define-key 'insert term-raw-map (kbd "<delete>") 'term-send-del)
#+end_src
*** C-<backspace> - Delete prevous word
Not strictly a bash thing, but I'm putting it in anyway.
Simply send C-w instead
#+BEGIN_SRC emacs-lisp
(evil-define-key 'insert term-raw-map (kbd "C-<backspace>")
  'circ/term/delete-previous-word)
#+END_SRC

*** C-<delete> - Delete next word
Not strictly a bash thing, but I'm putting it in anyway.
Simply send M-d instead
#+BEGIN_SRC emacs-lisp
(evil-define-key 'insert term-raw-map (kbd "C-<delete>")
  'circ/term/delete-next-word)
#+END_SRC

*** C-<left> - Go to previous word
Not strictly a bash thing, but I'm putting it in anyway.
Simply send M-b instead
#+BEGIN_SRC emacs-lisp
(evil-define-key 'insert term-raw-map (kbd "C-<left>")
  'circ/term/go-to-previous-word)
#+END_SRC

*** C-<right> - Go to next word
Not strictly a bash thing, but I'm putting it in anyway.
Simply send M-f instead
#+BEGIN_SRC emacs-lisp
(evil-define-key 'insert term-raw-map (kbd "C-<right>")
  'circ/term/go-to-next-word)
#+END_SRC

** Unbinding Keys
#+BEGIN_SRC emacs-lisp
;(general-unbind 
;  '(normal insert visual operator)
;  '(global-map org-mode-map evil-org-mode-map)
  ;"C-S-h"
  ;"C-S-j"
  ;"C-S-k"
  ;"C-S-l"
  ;"C-M-S-d"
;)

;; Prevent these from appearing in the standard keymap
(global-unset-key (kbd "M-s ESC"))
(global-unset-key (kbd "M-s ."))
(global-unset-key (kbd "M-s _"))
(global-unset-key (kbd "M-s o"))
(global-unset-key (kbd "M-s w"))
#+END_SRC

** P1
#+BEGIN_SRC emacs-lisp
;;FUN    KEY    FUNCTION                              DESCRIPTION                           MODE
(circ/p1 ","    'previous-buffer                      "prev buffer")
(circ/p1 "-"    'circ/alias-text-scale-down           "text scale down")
(circ/p1 "."    'next-buffer                          "next buffer")
(circ/p1 "/"    'circ/alias-search-buffer             "search buffer")
(circ/p1 ";"    'counsel-M-x                          "M-x")
(circ/p1 "="    'circ/alias-text-scale-up             "text scale up")
(circ/p1 "a"    'circ/add-abbrev                      "add abbrev")
(circ/p1 "b b"  'ivy-switch-buffer                    "switch buffers")
(circ/p1 "b c"  'nil                                  "cast buffers")
(circ/p1 "b ch" 'circ/alias-cast-buffer-left          "cast buffer left")
(circ/p1 "b cj" 'circ/alias-cast-buffer-down          "cast buffer down")
(circ/p1 "b ck" 'circ/alias-cast-buffer-up            "cast buffer up")
(circ/p1 "b cl" 'circ/alias-cast-buffer-right         "cast buffer right")
(circ/p1 "b d"  'nil                                  "duplicate buffers")
(circ/p1 "b dh" 'circ/alias-duplicate-buffer-left     "duplicate buffer left")
(circ/p1 "b dj" 'circ/alias-duplicate-buffer-down     "duplicate buffer down")
(circ/p1 "b dk" 'circ/alias-duplicate-buffer-up       "duplicate buffer up")
(circ/p1 "b dl" 'circ/alias-duplicate-buffer-right    "duplicate buffer right")
(circ/p1 "b f"  'circ/show-file-path                  "show file path")
(circ/p1 "b o"  'open-in-new-config                   "open buffer in a new window config")
(circ/p1 "b n"  'circ/show-buffer-name                "show buffer name")
(circ/p1 "b p"  'circ/buffer-paste                    "paste buffer")
(circ/p1 "b r"  'rename-buffer                        "rename buffer")
(circ/p1 "b t"  'nil                                  "transpose buffers")
(circ/p1 "b th" 'circ/alias-transpose-buffer-left     "transpose windows left")
(circ/p1 "b tj" 'circ/alias-transpose-buffer-down     "transpose windows down")
(circ/p1 "b tk" 'circ/alias-transpose-buffer-up       "transpose windows up")
(circ/p1 "b tl" 'circ/alias-transpose-buffer-right    "transpose windows right")
(circ/p1 "b x"  'circ/smart-clear-buffer              "clear buffer")
(circ/p1 "b y"  'circ/buffer-yank                     "yank buffer")
(circ/p1 "b"    'nil                                  "buffers")
(circ/p1 "c"    'delete-window                        "close window")
(circ/p1 "c"    'ranger-disable                       "close ranger"                        'ranger-mode-map)
(circ/p1 "d"    'circ/alias-erlang-find-tag           "goto definition"                     'erlang-mode-map)
(circ/p1 "d"    'evil-goto-definition                 "goto definition")
(circ/p1 "d"    'org-open-at-point                    "open link"                           'org-agenda-mode-map)
(circ/p1 "d"    'org-open-at-point                    "open link"                           'org-mode-map)
(circ/p1 "e #"  'nil                                  "number increment / decrement")
(circ/p1 "e #a" 'evil-numbers/inc-at-pt               "increment")
(circ/p1 "e #x" 'evil-numbers/dec-at-pt               "decrement")
(circ/p1 "e a"  'nil                                  "align")
(circ/p1 "e aH" 'circ/align-repeat-head               "regex ahead of match repeatedly")
(circ/p1 "e aT" 'circ/align-repeat-tail               "regex to tail of match repeatedly")
(circ/p1 "e aa" 'erlang-align-arrows                  "align arrows"                        'erlang-mode-map)
(circ/p1 "e ah" 'circ/align-once-head                 "regex ahead of match")
(circ/p1 "e at" 'circ/align-once-tail                 "regex to tail of match")
(circ/p1 "e c"  'dabbrev-completion                   "dabbrev completion")
(circ/p1 "e d"  'erlang-clone-arguments               "duplicate arguments"                 'erlang-mode-map)
(circ/p1 "e f"  'nil                                  "formatting")
(circ/p1 "e fb" 'json-mode-beautify                   "json beautify"                       'json-mode-map)
(circ/p1 "e fi" 'indent-region                        "indent region")
(circ/p1 "e fp" 'fill-paragraph                       "fill paragraph")
(circ/p1 "e fr" 'fill-region                          "fill region")
(circ/p1 "e i"  'erlang-indent-region                 "indent region"                       'erlang-mode-map)
(circ/p1 "e j"  'erlang-generate-new-clause           "new clause"                          'erlang-mode-map)
(circ/p1 "e l"  'org-insert-link                      "edit link"                           'org-mode-map)
(circ/p1 "e s"  'nil                                  "surround")
(circ/p1 "e s'" 'circ/surround-s-quote                "single quote '")
(circ/p1 "e s(" 'circ/surround-parentheses            "parentheses ( )")
(circ/p1 "e s)" 'circ/surround-parentheses            "parentheses ( )")
(circ/p1 "e s*" 'circ/surround-asterisk               "asterisk *")
(circ/p1 "e s+" 'circ/surround-plus                   "plus +")
(circ/p1 "e s-" 'circ/surround-minus                  "minus -")
(circ/p1 "e s/" 'circ/surround-slash                  "slash /")
(circ/p1 "e s=" 'circ/surround-equals                 "equals =")
(circ/p1 "e s[" 'circ/surround-brackets               "brackets [ ]")
(circ/p1 "e s\"" 'circ/surround-d-quote               "double quote \"")
(circ/p1 "e s]" 'circ/surround-brackets               "brackets [ ]")
(circ/p1 "e ss" 'circ/surround-region                 "surround region")
(circ/p1 "e s{" 'circ/surround-braces                 "braces { }")
(circ/p1 "e s}" 'circ/surround-braces                 "braces { }")
(circ/p1 "e"    'nil                                  "edits")
(circ/p1 "f b"  'ivy-switch-buffer                    "buffers")
(circ/p1 "f d"  'dired-create-directory               "create directory"                    'ranger-mode-map)
(circ/p1 "f f"  'counsel-find-file                    "find file")
(circ/p1 "f h"  'org-html-export-to-html              "export to html"                      'org-mode-map)
(circ/p1 "f r"  'counsel-recentf                      "find recent file")
(circ/p1 "f s"  'nil                                  "scratch buffers")
(circ/p1 "f sj" 'new-scratch-json-mode                "json scratch buffer")
(circ/p1 "f so" 'new-scratch-org-mode                 "org scratch buffer")
(circ/p1 "f st" 'new-scratch-text-mode                "text scratch buffer")
(circ/p1 "f ss" 'new-scratch-shell-script-mode        "shell script scratch buffer")
(circ/p1 "f sp" 'new-scratch-python-mode              "python scratch buffer")
(circ/p1 "f t"  'nil                                  "tramp")
(circ/p1 "f tB" 'tramp-cleanup-all-buffers            "tramp clean all buffers")
(circ/p1 "f tc" 'tramp-cleanup-this-connection        "tramp clean this connection")
(circ/p1 "f tC" 'tramp-cleanup-all-connections        "tramp clean all connection")
(circ/p1 "f"    'nil                                  "files")
(circ/p1 "g"    'nil                                  "goto")
(circ/p1 "g 1"  'avy-goto-char                        "goto char 1")
(circ/p1 "g 2"  'avy-goto-char-2                      "goto char 2")
(circ/p1 "g t"  'avy-goto-char-timer                  "goto char timer")
(circ/p1 "g l"  'avy-goto-line                        "goto line")
(circ/p1 "g w"  'avy-goto-word-1                      "goto word 1")
(circ/p1 "g h"  'avy-org-goto-heading-timer           "goto org heading timer"              'org-mode-map)
(circ/p1 "h"    'windmove-left                        "win left")
(circ/p1 "j"    'windmove-down                        "win down")
(circ/p1 "k"    'windmove-up                          "win up")
(circ/p1 "l"    'windmove-right                       "wind right")
(circ/p1 "m"    'nil                                  "bookmarks")
(circ/p1 "m a"  'bookmark-set                         "set bookmark")
(circ/p1 "m A"  'bookmark-set-no-overwrite            "set bookmark (no overwrite)")
(circ/p1 "m b"  'bookmark-jump                        "open bookmark")
(circ/p1 "m l"  'bookmark-bmenu-list                  "open bookmark")
(circ/p1 "o b"  'ibuffer                              "ibuffer")
(circ/p1 "o c"  'copy-buffer                          "copy buffer")
(circ/p1 "o d"  'dired-jump                           "dired jump")
(circ/p1 "o D"  'dired                                "dired")
(circ/p1 "o i"  'circ/open-in-intellij                "open in intellij")
(circ/p1 "o i"  'image-dired                          "image-dired"                         'dired-mode-map)
(circ/p1 "o m"  'mpccp                                "mpccp")
(circ/p1 "o p"  'proced                               "proded")
(circ/p1 "o r"  'circ/elfeed-load-and-open            "elfeed")
(circ/p1 "o tc" 'circ/alias-clisp-shell               "clisp")
(circ/p1 "o te" 'erlang-shell                         "erlang")
(circ/p1 "o tp" 'circ/alias-python-shell              "python")
(circ/p1 "o tt" 'circ/ansi-term                       "bash")
(circ/p1 "o x"  'emux                                 "emux")
(circ/p1 "o"    'nil                                  "applications")
(circ/p1 "p ?"  'projectile-command-map               "other")
(circ/p1 "p O"  'circ/alias-org-force-publish         "force org publish project"           'org-mode-map)
(circ/p1 "p b"  'projectile-switch-to-buffer          "switch project buffer")
(circ/p1 "p c"  'circ/check-project                   "check / compile project")
(circ/p1 "p f"  'counsel-projectile-find-file         "find project file")
(circ/p1 "p g"  'counsel-projectile-grep              "find instances in project")
(circ/p1 "p i"  'org-insert-link                      "insert link")
(circ/p1 "p o"  'org-publish-current-project          "org publish project"                 'org-mode-map)
(circ/p1 "p p"  'counsel-projectile-switch-project    "switch project")
(circ/p1 "p r"  'circ/revert-project-buffers          "revert project buffers")
(circ/p1 "p s"  'org-store-link                       "copy link")
(circ/p1 "p t"  'circ/regenerate-tags                 "regenerate tags")
(circ/p1 "p w"  'circ/save-project-buffers            "save all project buffers")
(circ/p1 "p w"  'org-save-all-org-buffers             "save all org buffers"                'org-mode-map)
(circ/p1 "p"    'nil                                  "projects")
(circ/p1 "q"    'circ/kill-this-buffer                "kill buffer")
(circ/p1 "r n"  'nil                                  "numbers")
(circ/p1 "r ni" 'increment-register                   "increment register with number")
(circ/p1 "r np" 'insert-register                      "paste number from register")
(circ/p1 "r ny" 'number-to-register                   "yank number to register")
(circ/p1 "r p"  'nil                                  "positions")
(circ/p1 "r pp" 'jump-to-register                     "goto register position")
(circ/p1 "r py" 'point-to-register                    "yank current position to register")
(circ/p1 "r r"  'nil                                  "rectangle")
(circ/p1 "r rp" 'insert-register                      "paste rectangle from register")
(circ/p1 "r ry" 'copy-rectangle-to-register           "yank rectangle to register")
(circ/p1 "r t"  'nil                                  "text")
(circ/p1 "r ta" 'append-to-register                   "append text to register")
(circ/p1 "r tb" 'prepend-to-register                  "prepend text to register (before)")
(circ/p1 "r tp" 'insert-register                      "paste text register")
(circ/p1 "r ty" 'copy-to-register                     "yank text to register")
(circ/p1 "r"    'nil                                  "registers")
(circ/p1 "t R"  'auto-revert-mode                     "toggle auto revert mode")
(circ/p1 "t W"  'circ/toggle-whitespace-full          "toggle whitespace full")
(circ/p1 "t a"  'abbrev-mode                          "toggle abbrev mode")
(circ/p1 "t a"  'vc-annotate-toggle-annotation-visibility "toggle annotations"              'vc-annotate-mode-map)
(circ/p1 "t b"  'circ/org-agenda-toggle-blocked-tasks "toggle blocked tasks"                'org-agenda-mode-map)
(circ/p1 "t c"  'circ/org-agenda-toggle-clock-closed  "toggle clock closed"                 'org-agenda-mode-map)
(circ/p1 "t c"  'comment-line                         "toggle comment line")
(circ/p1 "t f"  'font-lock-mode                       "toggle auto font formatting")
(circ/p1 "t h"  'hl-line-mode                         "toggle highight line mode")
(circ/p1 "t h"  'ranger-toggle-dotfiles               "toggle hidden"                       'ranger-mode-map)
(circ/p1 "t h"  'dired-omit-mode                      "toggle hidden"                       'dired-mode-map)
(circ/p1 "t i"  'org-toggle-inline-images             "toggle images"                       'org-mode-map)
(circ/p1 "t l"  'nlinum-mode                          "toggle relative line numbers")
(circ/p1 "t p"  'projectile-mode                      "toggle projectile mode")
(circ/p1 "t r"  'rainbow-delimiters-mode              "toggle rainbow delimiters")
(circ/p1 "t t"  'nil                                  "tables"                              'org-mode-map)
(circ/p1 "t t"  'circ/org-agenda-toggle-hide-tags     "toggle hide tags"                    'org-agenda-mode-map)
(circ/p1 "t t"  'proced-toggle-tree                   "toggle proced tree"                  'proced-mode-map)
(circ/p1 "t tr" 'org-table-toggle-coordinate-overlay  "toggle table coords"                 'org-mode-map)
(circ/p1 "t w"  'whitespace-mode                      "toggle whitespace display")
(circ/p1 "t"    'nil                                  "toggles")
(circ/p1 "v D"  'vc-ediff                             "ediff")
(circ/p1 "v a"  'circ/vc-annotate                     "annotate")
(circ/p1 "v b"  'counsel-git-checkout                 "change branch")
(circ/p1 "v d"  'nil                                  "diff")
(circ/p1 "v dd" 'vc-version-ediff                     "version ediff")
(circ/p1 "v dm" 'circ/vc-diff-head-current            "compare current to head")
(circ/p1 "v n"  'diff-hl-next-hunk                    "next change")
(circ/p1 "v p"  'diff-hl-previous-hunk                "prev change")
(circ/p1 "v m"  'nil                                  "merge conflict"                      'smerge-mode-map)
(circ/p1 "v mn" 'smerge-next                          "next merge conflict"                 'smerge-mode-map)
(circ/p1 "v mp" 'smerge-prev                          "prev merge conflict"                 'smerge-mode-map)
(circ/p1 "v"    'nil                                  "version control")
(circ/p1 "w e"  'balance-windows                      "balance windows")
(circ/p1 "w h"  'split-window-right                   "split horizontal")
(circ/p1 "w o"  'delete-other-windows                 "delete other windows")
(circ/p1 "w r"  'revert-buffer                        "reload from disk")
(circ/p1 "w v"  'split-window-below                   "split vertical")
(circ/p1 "w z"  'maximize-window                      "maximize")
(circ/p1 "w"    'nil                                  "windows")
(circ/p1 "x S"  'circ/alias-sh-cmd-whole-buffer-split-lines "sh cmd whole buffer split lines")
(circ/p1 "x X"  'circ/alias-sh-cmd-whole-buffer       "sh cmd whole buffer")
(circ/p1 "x s"  'circ/alias-sh-cmd-split-lines        "sh cmd split lines")
(circ/p1 "x x"  'circ/sh-cmd                          "sh cmd")
(circ/p1 "x"    'nil                                  "sh cmd")
#+END_SRC

** P2
#+BEGIN_SRC emacs-lisp
;;       KEY    FUNCTION                              DESCRIPTION                           MODE
(circ/p2 "h"    'circ/alias-shrink-win-horz           "shrink horz"                         'override)
(circ/p2 "j"    'circ/alias-enlarge-win-vert          "enlarge vert"                        'override)
(circ/p2 "k"    'circ/alias-shrink-win-vert           "shrink vert"                         'override)
(circ/p2 "l"    'circ/alias-enlarge-win-horz          "enlarge horz"                        'override)
(circ/p2 "i"    'nil                                  "insert")
(circ/p2 "i a"  'nil                                  "a chars")
(circ/p2 "i am" 'circ/insert-a-macron                 "")
(circ/p2 "i e"  'nil                                  "e chars")
(circ/p2 "i em" 'circ/insert-e-macron                 "")
(circ/p2 "i i"  'nil                                  "i chars")
(circ/p2 "i im" 'circ/insert-i-macron                 "")
(circ/p2 "i o"  'nil                                  "o chars")
(circ/p2 "i om" 'circ/insert-o-macron                 "")
(circ/p2 "i u"  'nil                                  "u chars")
(circ/p2 "i um" 'circ/insert-u-macron                 "")
(circ/p2 "i y"  'nil                                  "y chars")
(circ/p2 "i ym" 'circ/insert-y-macron                 "")
(circ/p2 "p"    'nil                                  "pass")
(circ/p2 "p u"  'circ/pass/copy-user                  "copy user")
(circ/p2 "p p"  'circ/pass/copy-password              "copy password")
(circ/p2 "p g"  'circ/pass/generate-entry             "generate")
(circ/p2 "p o"  'circ/pass/open-entry                 "open entry")
#+END_SRC

** P3
#+BEGIN_SRC emacs-lisp
;;       KEY    FUNCTION                              DESCRIPTION                           MODE
(circ/p3 "f r"  'circ/set-frame-name                  "rename frame")
(circ/p3 "f c"  'make-frame                           "create new frame")
(circ/p3 "f q"  'delete-frame                         "close frame")
(circ/p3 "f o"  'pop-out-config-to-new-frame          "pop out to frame")
(circ/p3 "f"    'nil                                  "frames")
(circ/p3 "h"    'evil-jump-backward                   "jump back")
(circ/p3 "l"    'evil-jump-forward                    "jump forward")
#+END_SRC

** P4
#+BEGIN_SRC emacs-lisp
;;       KEY    FUNCTION                              DESCRIPTION                           MODE
(circ/p4 "["    'org-previous-link                    "previous link"                       'org-mode-map)
(circ/p4 "]"    'org-next-link                        "next link"                           'org-mode-map)
(circ/p4 "["    'org-previous-link                    "previous link"                       'org-agenda-mode-map)
(circ/p4 "]"    'org-next-link                        "next link"                           'org-agenda-mode-map)
(circ/p4 "/"    'counsel-org-goto                     "org goto"                            'org-mode-map)
(circ/p4 "a"    'nil                                  "org-agenda")
(circ/p4 "a a"  'circ/alias-org-agenda-agenda         "agenda")
(circ/p4 "a t"  'circ/alias-org-agenda-tasks          "tasks")
(circ/p4 "a s"  'circ/setup-agenda-view               "setup agenda view")
(circ/p4 "b c"  'circ/open-calendar                   "calendar")
(circ/p4 "b l"  'circ/open-checklists                 "checklists")
(circ/p4 "b i"  'circ/open-inbox                      "inbox")
(circ/p4 "b r"  'circ/open-read                       "read")
(circ/p4 "b s"  'circ/open-someday                    "someday")
(circ/p4 "b t"  'circ/open-todo                       "todo")
(circ/p4 "b vc" 'org-columns                          "columns"                             'org-mode-map)
(circ/p4 "b"    'nil                                  "buffer switching")
(circ/p4 "c c"  'circ/cortex/continue                 "continue in another slide"           'org-mode-map)
(circ/p4 "c f"  'circ/cortex/search-slides            "search slides")
(circ/p4 "c l"  'circ/cortex/link                     "cortex link"                         'org-mode-map)
(circ/p4 "c n"  'circ/cortex/create-file              "create cortex file")
(circ/p4 "c r"  'circ/cortex/rename-slide             "rename slide"                        'org-mode-map)
(circ/p4 "c"    'nil                                  "cortex"                              'org-mode-map)
(circ/p4 "e"    'nil                                  "org edit"                            'org-mode-map)
(circ/p4 "e s"  'circ/org-sort-headlines              "sort headlines"                      'org-mode-map)
(circ/p4 "e c"  'org-clone-subtree-with-time-shift    "clone subtree with time shirt"       'org-mode-map)
(circ/p4 "f m"  'circ/org-file-reference              "file reference"                      'org-mode-map)
(circ/p4 "f p"  'circ/pims/set-project                "set as project"                      'org-mode-map)
(circ/p4 "f r"  'org-refile                           "org refile"                          'org-mode-map)
(circ/p4 "f t"  'circ/pims/set-todo                   "set as todo"                         'org-mode-map)
(circ/p4 "f"    'nil                                  "filing"                              'org-mode-map)
(circ/p4 "h"    'outline-backward-same-level          "back same level")
(circ/p4 "i"    'org-clock-in                         "clock in"                            'org-mode-map)
(circ/p4 "j"    'outline-next-visible-heading         "next visible heading")
(circ/p4 "k"    'outline-previous-visible-heading     "prev visible heading")
(circ/p4 "l"    'outline-forward-same-level           "forward same level")
(circ/p4 "d"    'org-archive-subtree-default          "archive"                             'org-mode-map)
(circ/p4 "n"    'org-capture                          "org capture")
(circ/p4 "o"    'org-clock-out                        "clock out"                           'org-mode-map)
(circ/p4 "p d"  'org-deadline                         "deadline"                            'org-mode-map)
(circ/p4 "p p"  'org-set-property                     "set property"                        'org-mode-map)
(circ/p4 "p p"  'org-agenda-set-property              "set property"                        'org-agenda-mode-map)
(circ/p4 "p s"  'org-schedule                         "schedule"                            'org-mode-map)
(circ/p4 "p t"  'circ/org-set-tags                    "set tags"                            'org-mode-map)
(circ/p4 "p T"  'circ/org-clear-tags                  "clear tags"                          'org-mode-map)
(circ/p4 "p t"  'circ/org-agenda-set-tags             "set tags"                            'org-agenda-mode-map)
(circ/p4 "p T"  'circ/org-agenda-clear-tags           "clear tags"                          'org-agenda-mode-map)
(circ/p4 "p o"  'org-toggle-ordered-property          "toggle ordered"                      'org-mode-map)
(circ/p4 "p"    'nil                                  "property"                            'org-mode-map)
(circ/p4 "r"    'nil                                  "references"                          'org-mode-map)
(circ/p4 "r f"  'circ/cortex/find-reference           "find reference")
(circ/p4 "r l"  'circ/cortex/insert-reference-link    "insert reference link"               'org-mode-map)
(circ/p4 "t c"  'org-table-create-or-convert-from-region "create / convert table"           'org-mode-map)
(circ/p4 "t d"  'nil                                  "delete"                              'org-mode-map)
(circ/p4 "t dd" 'org-cut-special                      "delete cell"                         'org-mode-map)
(circ/p4 "t dc" 'org-table-delete-column              "delete column"                       'org-mode-map)
(circ/p4 "t dr" 'org-table-kill-row                   "delete row"                          'org-mode-map)
(circ/p4 "t i"  'nil                                  "insert"                              'org-mode-map)
(circ/p4 "t ic" 'org-table-insert-column              "insert column"                       'org-mode-map)
(circ/p4 "t ih" 'org-table-insert-hline               "insert horizontal line"              'org-mode-map)
(circ/p4 "t ir" 'org-table-insert-row                 "insert row"                          'org-mode-map)
(circ/p4 "t y"  'nil                                  "yank"                                'org-mode-map)
(circ/p4 "t yy" 'org-copy-special                     "yank cell"                           'org-mode-map)
(circ/p4 "t p"  'nil                                  "paste"                               'org-mode-map)
(circ/p4 "t pp" 'org-paste-special                    "paste cell"                          'org-mode-map)
(circ/p4 "t"    'nil                                  "tables"                              'org-mode-map)
(circ/p4 "u"    'outline-up-heading                   "up heading")
(circ/p4 "v c"  'circ/insert-created-timestamp        "created date"                        'org-mode-map)
(circ/p4 "v d"  'org-time-stamp                       "time stamp"                          'org-mode-map)
(circ/p4 "v p"  'counsel-yank-pop                     "paste selector")
(circ/p4 "v t"  'circ/org-template-insert             "template"                            'org-mode-map)
(circ/p4 "v"    'nil                                  "insert items"                        'org-mode-map)
(circ/p4 "x"    'nil                                  "none")
(circ/p4 "x"    'org-toggle-checkbox                  "toggle checkbox"                     'org-mode-map)
#+END_SRC

** Other
*** Non-P Bindings
#+BEGIN_SRC emacs-lisp
(evil-define-key 'motion org-agenda-mode-map "ci" 'org-agenda-show-clocking-issues)
(evil-define-key 'motion org-agenda-mode-map "cl" 'org-agenda-log-mode)

;; F1 is reserved for some special cases when "C-h" isn't available
(general-define-key
  "<f2>" 'circ/alias-org-agenda-agenda
  "<f3>" 'circ/alias-org-agenda-tasks
  "<f4>" 'circ/open-inbox
  "<f5>" 'circ/open-checklists
)

(evil-define-key '(normal visual) copy-buffer-mode-map
  "q" 'copy-buffer-copy-quit)

(evil-define-key 'motion org-agenda-mode-map
  "f" 'circ/org-agenda-filter-tag
  "F" 'circ/org-agenda-show-all-tags
  "r" 'circ/org-agenda-redo)

(evil-define-key 'normal org-capture-mode-map
  "q" 'org-capture-finalize
  "Q" 'org-capture-kill)
;; Evil mode only sets keymaps on state transition. It does not know that
;; org-capture-mode-map has evil bindings when you start an org-capture. Force
;; it to load the keymap with this function on hook.
(add-hook 'org-capture-mode-hook 'evil-normalize-keymaps)

(general-define-key
 :keymaps 'ivy-minibuffer-map
 "<escape>"  'minibuffer-keyboard-quit)

(general-define-key
 :keymaps 'swiper-map
 "<escape>"  'minibuffer-keyboard-quit)
#+END_SRC

*** Help
#+BEGIN_SRC emacs-lisp
(general-define-key
  "C-h v" 'counsel-describe-variable
  "C-h f" 'counsel-describe-function
)
#+END_SRC
* Custom Command Line Options
These are for easy launching of emacs.

To automagically open emacsclient or emacs do so in the format:
#+BEGIN_SRC sh
emacsclient -c -a 'false' --no-wait --eval "(circ/startup/agenda)" || emacs --agenda
#+END_SRC
This will open an emacsclient and automatically launch an emacsclient if emacs
is already running, and run the =circ/startup/agenda= function. If emacs is not
running, it will open a new instance and use the =--agenda= flag to launch
=circ/startup/agenda=.

#+BEGIN_SRC emacs-lisp
(defun circ/startup/inbox (&optional switch) (circ/open-inbox))
(add-to-list 'command-switch-alist '("--inbox" . circ/startup/inbox))

(defun circ/startup/agenda (&optional switch) (circ/alias-org-agenda-agenda))
(add-to-list 'command-switch-alist '("--agenda" . circ/startup/agenda))

(defun circ/startup/tasks (&optional switch) (circ/alias-org-agenda-tasks))
(add-to-list 'command-switch-alist '("--tasks" . circ/startup/tasks))

(defun circ/startup/pims (&optional switch) (circ/set-up-agenda-view))
(add-to-list 'command-switch-alist '("--pims" . circ/startup/pims))
#+END_SRC
