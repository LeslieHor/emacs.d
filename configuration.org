#+STARTUP: overview
#+TITLE: emacs.d config

* Log messages
#+begin_src emacs-lisp
(defun circ/log-message (format-string &rest args)
  (interactive)
  (apply 'message (cons
                   (concat "[%s] " format-string)
                   (cons (format-time-string "%Y-%m-%dT%H:%M:%S.%N")
                         args))))
#+end_src
* Better defaults
** Start Up
#+BEGIN_SRC emacs-lisp
(circ/log-message "Starting server")
(server-start) ; Start emacs server
;(desktop-save-mode 1) ; Save session and restore on next launch
#+END_SRC

** UI
#+BEGIN_SRC emacs-lisp
(circ/log-message "Setting UI settings")
(setq inhibit-startup-screen t) ; inhibit useless and old-school startup screen
(setq ring-bell-function 'ignore) ; silent bell when you make a mistake
(setq-default frame-title-format '("%b - Emacs")) ; set the emacs title.
                                        ; overrides the old "emacs@HOST" title
(set-frame-font "Liberation Mono 7" t t)
;(set-frame-font "IBM Plex Mono 7" t t)
;(set-frame-font "Lemon 6" t t)
;(set-frame-font "Unifont 12" t t)
(menu-bar-mode -1)

(circ/log-message "Setting up optional termux settings")
;; Disable these in termux mode
(defvar circ/termux-p 'nil)
(unless circ/termux-p
  (mouse-avoidance-mode 'animate)
  (tool-bar-mode -1)
  (scroll-bar-mode -1))
(when circ/termux-p
  (defun circ/termux-open (args)
    (interactive)
    (if (not (listp args))
        (setq args (list args)))
    (apply 'call-process "termux-open" nil nil nil args))
  (defun circ/browse-url-browser-function (url &rest args)
    (interactive)
    (circ/termux-open url))

  (setq browse-url-browser-function
    'circ/browse-url-browser-function))

(circ/log-message "Setting up theme")
(load-theme 'wheatgrass)
(circ/log-message "Setting up split settings and others")
; Split vertically by default
(setq split-width-threshold 160)
(setq split-height-threshold 100)
(setq-default fill-column 80)
(setq calendar-week-start-day 1)

;; Keep point in same position relative to window when scrolling
(setq scroll-preserve-screen-position t)

;; Don't use proportional fonts in eww
(setq shr-use-fonts nil)

;; Use emacs to put in gpg password
(setq epa-pinentry-mode 'loopback)

;; Scrolling
(setq scroll-margin 0)
(setq scroll-conservatively 101)
#+END_SRC

** Display buffer behaviour
#+begin_src emacs-lisp
(circ/log-message "Setting up display buffer settings")
(setq display-buffer-alist
      '(("^\\*Proced\\*$"
         (display-buffer-same-window))
        ("^\\*Help\\*$"
         (display-buffer-reuse-window display-buffer-in-side-window)
         (side . right)
         (window-width . 86))
        ("^\\*Annotate.*"
         (display-buffer-same-window))
        ;; the function `org-fit-window-to-buffer' overrides the window height
        ;; Re-define the function if you want to enforce a height
        ("^ \\*Org todo\\*$"
         (display-buffer-in-side-window)
         (side . bottom)
         (window-height . 999))
        ;; the function `org-fit-window-to-buffer' overrides the window height
        ;; Re-define the function if you want to enforce a height
        ("^\\*Org Select\\*$"
         (display-buffer-in-side-window)
         (side . bottom)
         (window-height . 999))
        ("^\\*Capture\\*$"
         (display-buffer-in-side-window)
         (side . bottom)
         (window-height . 15))
        ("^CAPTURE-"
         (display-buffer-in-side-window)
         (side . bottom)
         (window-height . 15))
        ("^\\*Org Src "
         (display-buffer-same-window))
        ("^\\*Org Note\\*$"
         (display-buffer-in-side-window)
         (side . bottom)
         (window-height . 20))
        ("^\\*Calendar\\*$"
         (display-buffer-in-side-window)
         (side . bottom)
         (window-height . 20))
        ("^\\*vc-dir\\*$"
         (display-buffer-same-window))
        ("^\\*vc-diff\\*$"
         (display-buffer-same-window))
        ))
#+end_src

** Tab Behaviour
#+BEGIN_SRC emacs-lisp
(circ/log-message "Setting up tab settings")
(setq-default indent-tabs-mode nil) ; don't insert tabs
(setq-default tab-width 2) ; self-documenting
(setq indent-line-function 'insert-tab)
#+END_SRC

** Backup and autosave locations
#+BEGIN_SRC emacs-lisp
(circ/log-message "Setting up backup and autosave locations")
(setq auto-save-visited-file-name t)
(setq auto-save-default nil)
(setq backup-directory-alist '((".*" . "~/.emacs.d/backup")))
(setq auto-save-file-name-transforms '((".*" "~/.emacs.d/autosave/" t)))
#+END_SRC

** Default major mode
#+BEGIN_SRC emacs-lisp
(circ/log-message "Setting up default major mode")
(setq-default major-mode 'org-mode)
#+END_SRC

* Whitespace
Force it on all the time.

Highlights:
- face visualisation
- empty lines at beginning of end of buffer
- tabs
- tailing blanks

#+BEGIN_SRC emacs-lisp
(circ/log-message "Setting up whitespace")
(require 'whitespace)
(setq whitespace-style '(face empty tabs trailing))
(global-whitespace-mode t)
(setq whitespace-line-column 80)

;; Disable in certain modes
(setq whitespace-global-modes '((not erc-mode)
                                (not org-mode)))
#+END_SRC

* Org
#+begin_src emacs-lisp
(circ/log-message "Setting up org mode")
#+end_src
** Load latest org and contribs:
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/org-9.4.4/lisp")
(add-to-list 'load-path "~/.emacs.d/packages/org-9.4.4/contrib/lisp")
(add-to-list 'load-path "~/.emacs.d/packages/persist-0.4") ; for org-drill
(add-to-list 'load-path "~/.emacs.d/packages/org-drill-35c1ce349949cc213f3076799211210f49431850")
(org-reload)
#+END_SRC

** Org settings
#+BEGIN_SRC emacs-lisp
(setq org-html-postamble "<p class=\"created\">Created: %T</p>")
(setq org-src-fontify-natively t)
(setq org-src-tab-acts-natively t)
(setq org-startup-folded nil) ; Start org mode expanded
(setq org-startup-with-inline-images t) ; Show images by default
(setq org-startup-indented nil)
(setq org-hide-leading-stars t)
(setq org-edit-src-content-indentation 0)
(setq org-clock-into-drawer "CLOCK")
(setq org-use-property-inheritance t)
(setq org-clock-mode-line-total 'current)
(setq org-agenda-window-setup 'current-window)
(setq org-agenda-sticky t)
(setq org-log-done 'time)
(setq org-agenda-skip-scheduled-if-done t)
(setq org-agenda-skip-deadline-if-done t)
(setq org-src-window-setup 'plain) ; Use display-buffer-alist settings
(setq org-time-stamp-rounding-minutes '(1 1))
(setq org-clock-out-when-done nil)
(setq org-log-into-drawer "LOGBOOK")
(setq org-agenda-hide-tags-regexp ".*")
(setq org-catch-invisible-edits 'show-and-error)
(setq org-adapt-indentation nil)

(add-to-list 'org-link-frame-setup '(file . find-file))

;; Enable habit tracking in org-mode
(require 'org-habit)
(add-to-list 'org-modules 'org-habit)
(require 'org-drill)
(add-to-list 'org-modules 'org-drill)
(setq org-drill-add-random-noise-to-intervals-p t)

;; Don't show any habits in the agenda, there is a dedicated section for that.
(setq org-habit-show-habits nil)
(setq org-habit-show-habits-only-for-today nil)
(setq org-habit-show-all-today nil)

;; Set up languages for running code blocks in org
;; In version 9.0.9, ob-sh was renamed to ob-shell
(org-babel-do-load-languages
 'org-babel-load-languages
 (cond
  ((version< org-version "9.0.9")
   '((python . t)
     (sh . t)
     (dot . t)
     (emacs-lisp . t)))
  (t
   '((python . t)
     (shell . t)
     (dot . t)
     (emacs-lisp . t)))))

;; Set clock checks
(setq org-agenda-clock-consistency-checks
      (quote (:max-duration "4:00"
              :min-duration 0
              :max-gap 0
              :gap-ok-around ("4:00"))))

(add-to-list 'org-file-apps '("\\.mkv\\'" . "mpv %s"))
#+END_SRC

** Line wrap mode
#+BEGIN_SRC emacs-lisp
(defun org-mode-startup-functions ()
  (toggle-word-wrap 1)
  (toggle-truncate-lines -1))

(add-hook 'org-mode-hook 'org-mode-startup-functions)

(defun org-agenda-mode-startup-functions ()
  (hl-line-mode +1))

(add-hook 'org-agenda-mode-hook 'org-agenda-mode-startup-functions)
(add-hook 'org-agenda-mode-hook 'circ/disable-evil-quickscope-mode)
#+END_SRC

** Fix the =\emsp= bug in clock tables.
 #+BEGIN_SRC emacs-lisp
 (defun circ/org-clocktable-indent-string (level)
   (if (= level 1)
       ""
     (let ((str "^"))
       (while (> level 2)
         (setq level (1- level)
               str (concat str "--")))
       (concat str "-> "))))

 (advice-add 'org-clocktable-indent-string :override
             #'circ/org-clocktable-indent-string)
 #+END_SRC

** Beautifying org-mode
Credits:
zzamboni - https://zzamboni.org/post/beautifying-org-mode-in-emacs/#step-4-configure-faces-for-specific-org-elements

Hide the markup for various emphasis'
#+BEGIN_SRC emacs-lisp
(setq org-hide-emphasis-markers t)
#+END_SRC

Set up nice fonts
#+BEGIN_SRC emacs-lisp
(let* ((base-font-color  (face-foreground 'default nil 'default))
       (headline        `(:inherit    default
                          :weight     bold
                          :foreground ,base-font-color)))

  (custom-theme-set-faces
   'user
   `(org-document-title   ((t (,@headline :height 1.00 :underline t))))
   `(org-level-1          ((t (,@headline :height 1.00 :foreground "#e6194b"))))
   `(org-level-2          ((t (,@headline :height 1.00 :foreground "#3cb44b"))))
   `(org-level-3          ((t (,@headline :height 1.00 :foreground "#ffe119"))))
   `(org-level-4          ((t (,@headline :height 1.00 :foreground "#4363d8"))))
   `(org-level-5          ((t (,@headline :height 1.00 :foreground "#f58231"))))
   `(org-level-6          ((t (,@headline :height 1.00 :foreground "#911eb4"))))
   `(org-level-7          ((t (,@headline :height 1.00 :foreground "#42d4f4"))))
   `(org-level-8          ((t (,@headline :height 1.00 :foreground "#f032e6"))))
   `(org-block-background ((t (:height 1.00 :background "#222222"))))
   `(org-block            ((t (:height 1.00 :background "#222222"))))
   `(org-block-begin-line ((t (:height 1.00 :foreground "#118811" :background "#181818"))))
   `(org-block-end-line   ((t (:height 1.00 :foreground "#118811" :background "#181818"))))
))
#+END_SRC

** Notifications
Send agenda appointment desktop notifications.

#+BEGIN_SRC emacs-lisp
(setq appt-message-warning-time 15)
(setq appt-display-interval 5)
(setq appt-display-mode-line nil)
(setq appt-disp-window-function 'circ/appt-display)
(setq appt-delete-window-function (lambda () t))

;; Pre-defined functions for formatting
(defun circ/format-appt-notify-msg-simple (mins-to-appt curr-time msg)
  (format "%s: %s in %s mins" curr-time msg mins-to-appt))

;; Pre-defined functions for different notification systems
(defun circ/format-appt-notify-cmd-desktop (message)
  (format "timeout 0.2 notify-send -t 0 \"%s\"" message))
(defun circ/format-appt-notify-cmd-termux (message)
  (format "timeout 5 termux-notification -t \"%s\"" message))

(defvar circ/format-appt-notify-msg nil)
(defvar circ/format-appt-notify-cmd nil)

; Notifcations not working? Try using some of these
; (setq circ/format-appt-notify-msg 'circ/format-appt-notify-msg-simple)
; (setq circ/format-appt-notify-cmd 'circ/format-appt-notify-cmd-desktop)
; (setq circ/format-appt-notify-cmd 'circ/format-appt-notify-cmd-termux)

(defun circ/refresh-appointments ()
  (interactive)
  (setq appt-time-msg-list nil)
  (org-agenda-to-appt))

(defun circ/appt-display (mins-to-appt curr-time msg)
  "Sends a notification to the noticiation daemon. Has a
hardcoded 200ms timeout in case no notification service is alive"
  (when (and circ/format-appt-notify-msg
             circ/format-appt-notify-cmd
             msg)
    (let* ((head-msg (cond ((listp msg) (car msg))
                           (t msg)))
           (head-mins (cond ((listp mins-to-appt) (car mins-to-appt))
                            (t mins-to-appt)))
           (message (funcall circ/format-appt-notify-msg head-mins curr-time head-msg))
           (command (funcall circ/format-appt-notify-cmd message)))
      (when (< 0 (shell-command command))
        (user-error "Appointment notification failed"))
      (message "Notification: %s" message))
    (when (and (listp msg) msg)
      (circ/appt-display (cdr mins-to-appt) curr-time (cdr msg)))))

(defun circ/expanded-org-agenda-files ()
  (mapcar 'expand-file-name org-agenda-files))

(defun circ/org-agenda-file-p (&optional file)
  (member (or file (buffer-file-name)) (circ/expanded-org-agenda-files)))

(defun circ/maybe-refresh-appts ()
  (when (circ/org-agenda-file-p)
    (circ/refresh-appointments)))

;; Generate appointments on startup
(circ/refresh-appointments)
;; Regenerate at 00:05, so you can leave emacs open over night
(run-at-time "00:05" (* 60 60 24) 'circ/refresh-appointments)
;; Generate appointments when you save an agenda file
(add-hook 'after-save-hook 'circ/maybe-refresh-appts)
(add-hook 'after-revert-hook 'circ/maybe-refresh-appts)
#+END_SRC

** Tag cloud for org mode
#+BEGIN_SRC emacs-lisp
(defvar-local circ/org-agenda-filter-list-tags nil)

(defun circ/agenda-count-tags ()
  (interactive)
  (save-excursion
    (goto-char (point-min))
    (let ((count-alist '())
          (last-pos 0))
      (while (not (= last-pos (progn
                                (ignore-errors (org-agenda-next-item 1))
                                (move-beginning-of-line nil))))
        (setq last-pos (point))
        (dolist (tag (org-get-at-bol 'tags))
          (let* ((alist-val (assoc tag count-alist))
                 (count (cond ((not alist-val) 0)
                              (t (cdr alist-val)))))
            (setq count-alist (circ/alist-set tag (1+ count) count-alist)))))
      count-alist)))

(defun circ/agenda-format-tag-cloud (tag-alist)
  (interactive)
  (let ((string "  ")
        (text-width (window-text-width))
        (line-length 0))
    (dolist (tag (sort tag-alist (lambda (a b) (> (cdr a) (cdr b)))))
      (let ((tag-name (propertize (car tag) 'face 'org-tag))
            (tag-count (cdr tag)))
        (unless (member tag-name '("proj" "ordered"))
          (let ((tag-string (format "%s (%s)  " tag-name tag-count)))
            ;; Magic number 3 to help avoid the overflow icon. Sometimes, if the
            ;; tags are just right, the tag cloud will show an icon that
            ;; indicates there is more text off the side of the buffer. I don't
            ;; ever want that, because it makes me wonder if any tags are
            ;; missing from my immediate view.
            (cond ((> (+ line-length (length tag-string) 3) text-width)
                   (setq string (concat string "\n  " tag-string))
                   (setq line-length (+ (length tag-string) 2)))
                  (t
                   (setq string (concat string tag-string))
                   (setq line-length (+ line-length (length tag-string)))))))))
    string))

(defun circ/alist-set (key val alist &optional symbol)
  "Set property KEY to VAL in ALIST. Return new alist.
This creates the association if it is missing, and otherwise sets
the cdr of the first matching association in the list. It does
not create duplicate associations. By default, key comparison is
done with `equal'. However, if SYMBOL is non-nil, then `eq' is
used instead.

This method may mutate the original alist, but you still need to
use the return value of this method instead of the original
alist, to ensure correct results."
  (if-let ((pair (if symbol (assq key alist) (assoc key alist))))
      (setcdr pair val)
    (push (cons key val) alist))
  alist)

(defun circ/org-agenda-insert-tag-cloud ()
  (interactive)
  ;; Check the buffer name and the existance of a "===" line.
  (when (and (string= (buffer-name) "*Org Agenda(T)*")
             (save-excursion
               (goto-char (point-min))
               (search-forward-regexp "^==*" nil t)))
    (save-excursion
      (read-only-mode 0)
      ;; Remove tags if exists
      (goto-char (point-min))
      (when (ignore-errors (search-forward-regexp "^Tag Cloud"))
        (search-forward-regexp "^\*\**\n")
        (move-beginning-of-line 2)
        (delete-region (point-min) (point)))

      (goto-char (point-min))
      (insert (propertize (format
                           "Tag Cloud (Tag Filter: %s, Effort Filter:  %s, Cat Filter: %s)\n"
                           (string-join circ/org-agenda-filter-list-tags " ")
                           (string-join circ/org-agenda-filter-list-effort " ")
                           (string-join circ/org-agenda-filter-list-categories " "))
                          'face 'org-agenda-structure)
              (circ/agenda-format-tag-cloud (circ/agenda-count-tags)) "\n\n"
              (make-string (window-width) ?*) "\n")
      (read-only-mode 1))))

;; Could improve performance by caching the alist from `circ/agenda-count-tags'
;; but there is some problem with setting it. It doesn't set correcly. Don't
;; know why.
(defun circ/org-agenda-filter-tag ()
  (interactive)
  (let* ((tag-list (mapcar 'car (circ/agenda-count-tags)))
         (tag-candidates (remove-duplicates
                          (append (mapcar (lambda (tag) (concat "+" tag)) tag-list)
                                  (mapcar (lambda (tag) (concat "-" tag)) tag-list)
                                  circ/org-agenda-filter-list-tags)
                          :test 'string=))
         (new-tag (completing-read "Tag: " tag-candidates)))
    (cond ((member new-tag circ/org-agenda-filter-list-tags)
           (setq circ/org-agenda-filter-list-tags (remove new-tag circ/org-agenda-filter-list-tags))
           (circ/org-agenda-redo))
          (t
           (setq circ/org-agenda-filter-list-tags (cons new-tag circ/org-agenda-filter-list-tags))))
    (circ/org-agenda-apply-filter)))

(defun circ/org-agenda-apply-filter ()
  (interactive)
  (when circ/org-agenda-filter-list-tags
    (org-agenda-filter-apply circ/org-agenda-filter-list-tags 'tag))
  (when circ/org-agenda-filter-list-effort
    (org-agenda-filter-apply circ/org-agenda-filter-list-effort 'effort))
  (when circ/org-agenda-filter-list-categories
    (org-agenda-filter-apply circ/org-agenda-filter-list-categories 'category))
  (run-hooks 'org-agenda-filter-hook))

(defun circ/org-agenda-show-all-tags ()
  (interactive)
  (setq circ/org-agenda-filter-list-tags nil)
  (org-agenda-filter-show-all-tag)
  (circ/org-agenda-redo))

(defun circ/org-agenda-redo ()
  (interactive)
  (let ((filter-list-tags circ/org-agenda-filter-list-tags)
        (filter-list-effort circ/org-agenda-filter-list-effort)
        (filter-list-categories circ/org-agenda-filter-list-categories))
    (org-agenda-redo)
    (setq circ/org-agenda-filter-list-tags filter-list-tags)
    (setq circ/org-agenda-filter-list-effort filter-list-effort)
    (setq circ/org-agenda-filter-list-categories filter-list-categories)
    (circ/org-agenda-apply-filter)))

(add-hook 'org-agenda-finalize-hook 'circ/org-agenda-insert-tag-cloud)
(add-hook 'org-agenda-filter-hook 'circ/org-agenda-insert-tag-cloud)
#+END_SRC

** Org agenda filter effort
#+begin_src emacs-lisp
(defvar-local circ/org-agenda-filter-list-effort nil)

(defun circ/org-agenda-filter-effort ()
  (interactive)
  (let* ((effort-list (split-string
                       (or (cdr (assoc-string (concat org-effort-property "_ALL")
                                              org-global-properties
                                              t))
                           "0 0:10 0:30 1:00 2:00 3:00 4:00 5:00 6:00 7:00")))
         (effort-candidates (append (mapcar (lambda (e) (concat "<= " e)) effort-list)
                                    (mapcar (lambda (e) (concat "== " e)) effort-list)
                                    (mapcar (lambda (e) (concat ">= " e)) effort-list)))
         (new-effort (concat "+" (replace-regexp-in-string "^<= " "<"
                                   (replace-regexp-in-string "^== " "="
                                     (replace-regexp-in-string "^>= " ">"
                                  (completing-read "Effort: " effort-candidates)))))))
    (cond ((member new-effort circ/org-agenda-filter-list-effort)
           (setq circ/org-agenda-filter-list-effort (remove new-effort circ/org-agenda-filter-list-effort))
           (circ/org-agenda-redo))
          (t
           (setq circ/org-agenda-filter-list-effort (cons new-effort circ/org-agenda-filter-list-effort))))
    (circ/org-agenda-apply-filter)))

(defun circ/org-agenda-show-all-efforts ()
  (interactive)
  (setq circ/org-agenda-filter-list-effort nil)
  (org-agenda-filter-show-all-effort)
  (circ/org-agenda-redo))
#+end_src
** Org agenda filter category
#+begin_src emacs-lisp
(defvar-local circ/org-agenda-filter-list-categories nil)

(defun circ/org-agenda-filter-category ()
  (interactive)
  (let* ((category-list (circ/org-agenda-get-categories))
         (category-candidates (remove-duplicates
                               (append (mapcar (lambda (c) (concat "+" c)) category-list)
                                       (mapcar (lambda (c) (concat "-" c)) category-list)
                                       circ/org-agenda-filter-list-categories)
                               :test 'string=))
         (new-category (completing-read "Category: " category-candidates)))
    (cond ((member new-category circ/org-agenda-filter-list-categories)

           (setq circ/org-agenda-filter-list-categories (remove new-category circ/org-agenda-filter-list-categories))
           (circ/org-agenda-redo))
          (t
           (setq circ/org-agenda-filter-list-categories (cons new-category circ/org-agenda-filter-list-categories))))
    (circ/org-agenda-apply-filter)))

(defun circ/org-agenda-get-categories ()
  (interactive)
  (save-excursion
    (goto-char (point-min))
    (let ((category-list '())
          (last-pos 0))
      (while (not (= last-pos (progn
                                (ignore-errors (org-agenda-next-item 1))
                                (move-beginning-of-line nil))))
        (setq last-pos (point))
        (let ((category (org-get-at-bol 'org-category)))
          (when (and category (not (member category category-list)))
            (setq category-list (cons category category-list)))))
      category-list)))

(defun circ/org-agenda-show-all-categories ()
  (interactive)
  (setq circ/org-agenda-filter-list-categories nil)
  (org-agenda-filter-show-all-cat)
  (circ/org-agenda-redo))
#+end_src
** Org capture
*** Set a custom header
Override the current org-capture header by assigning a new header after the mode
is loaded.

#+BEGIN_SRC emacs-lisp
(defun circ/set-org-capture-mode-header ()
  (setq-local header-line-format
   (substitute-command-keys
    "\\<org-capture-mode-map>Capture buffer.  Finish \
[q] / [\\[org-capture-finalize]], refile [\\[org-capture-refile]], \
abort [Q] / [\\[org-capture-kill]].")))
(add-hook 'org-capture-mode-hook 'circ/set-org-capture-mode-header)
#+END_SRC
** Org 9.4.4 options
#+BEGIN_SRC emacs-lisp
(unless (version< org-version "9.2.0")
  (setq org-structure-template-alist '(("a" . "export ascii")
                                       ("c" . "center")
                                       ("C" . "comment")
                                       ("e" . "example")
                                       ("E" . "export")
                                       ("h" . "export html")
                                       ("l" . "export latex")
                                       ("q" . "quote")
                                       ("s" . "src")
                                       ("v" . "verse")))
  (require 'org-tempo))
#+END_SRC
** Force org mode to display buffers my way
Requires rules in =display-buffer-alist= to work properly.
=org-fit-window-to-buffer= overrides some display-buffer-alist rules. I am keeping
the call to =org-fit-window-to-buffer= because I like the behaviour.
*** Redefine =org-switch-to-buffer-other-window=
#+begin_src emacs-lisp
(defun circ/org-switch-to-buffer-other-window (&rest args)
  "Redefinition of `org-switch-to-buffer-other-window' to force
org to abide by `display-buffer-alist'"
  (apply #'switch-to-buffer-other-window args))

(advice-add 'org-switch-to-buffer-other-window :override
            #'circ/org-switch-to-buffer-other-window)
#+end_src
*** Redefine =org-capture-place-template= to not delete other windows
#+begin_src emacs-lisp
(defun circ/org-capture-place-template (&optional inhibit-wconf-store)
  "Insert the template at the target location, and display the buffer.
When `inhibit-wconf-store', don't store the window configuration, as it
may have been stored before."
  (unless inhibit-wconf-store
    (org-capture-put :return-to-wconf (current-window-configuration)))
  ;; ----------------------------------------------------------
  ;; Don't delete other windows. Just be a normal buffer
  ;; (delete-other-windows)
  ;; ----------------------------------------------------------
  (org-switch-to-buffer-other-window
   (org-capture-get-indirect-buffer (org-capture-get :buffer) "CAPTURE"))
  (widen)
  (org-show-all)
  (goto-char (org-capture-get :pos))
  (setq-local outline-level 'org-outline-level)
  (pcase (org-capture-get :type)
    ((or `nil `entry) (org-capture-place-entry))
    (`table-line (org-capture-place-table-line))
    (`plain (org-capture-place-plain-text))
    (`item (org-capture-place-item))
    (`checkitem (org-capture-place-item)))
  (setq-local org-capture-current-plist org-capture-plist)
  (org-capture-mode 1))

(advice-add 'org-capture-place-template :override
            #'circ/org-capture-place-template)
#+end_src
*** Redefine =org-fast-todo-selection= to not delete other windows
#+begin_src emacs-lisp
(defun circ/org-fast-todo-selection (&optional current-state)
  "Fast TODO keyword selection with single keys.
Returns the new TODO keyword, or nil if no state change should occur.
When CURRENT-STATE is given and selection letters are not unique globally,
prefer a state in the current sequence over on in another sequence."
  (let* ((fulltable org-todo-key-alist)
	 (head (org-get-todo-sequence-head current-state))
	 (done-keywords org-done-keywords) ;; needed for the faces.
	 (maxlen (apply 'max (mapcar
			      (lambda (x)
				(if (stringp (car x)) (string-width (car x)) 0))
			      fulltable)))
	 (expert (equal org-use-fast-todo-selection 'expert))
	 (prompt "")
	 (fwidth (+ maxlen 3 1 3))
	 (ncol (/ (- (window-width) 4) fwidth))
	 tg cnt e c tbl subtable
	 groups ingroup in-current-sequence)
    (save-excursion
      (save-window-excursion
	(if expert
	    (set-buffer (get-buffer-create " *Org todo*"))
      ;; ----------------------------------------------------------
      ;; Don't delete other windows. Just be a normal buffer
      ;; And don't split any buffers up.
	  ;; (delete-other-windows)
	  ;; (set-window-buffer (split-window-vertically) (get-buffer-create " *Org todo*"))
      ;; ----------------------------------------------------------
	  (org-switch-to-buffer-other-window " *Org todo*"))
	(erase-buffer)
	(setq-local org-done-keywords done-keywords)
	(setq tbl fulltable cnt 0)
	(while (setq e (pop tbl))
	  (cond
	   ((equal e '(:startgroup))
	    (push '() groups) (setq ingroup t)
	    (unless (= cnt 0)
	      (setq cnt 0)
	      (insert "\n"))
	    (setq prompt (concat prompt "{"))
	    (insert "{ "))
	   ((equal e '(:endgroup))
	    (setq ingroup nil cnt 0 in-current-sequence nil)
	    (setq prompt (concat prompt "}"))
	    (insert "}\n"))
	   ((equal e '(:newline))
	    (unless (= cnt 0)
	      (setq cnt 0)
	      (insert "\n")
	      (setq e (car tbl))
	      (while (equal (car tbl) '(:newline))
		(insert "\n")
		(setq tbl (cdr tbl)))))
	   (t
	    (setq tg (car e) c (cdr e))
	    (if (equal tg head) (setq in-current-sequence t))
	    (when ingroup (push tg (car groups)))
	    (when in-current-sequence (push e subtable))
	    (setq tg (org-add-props tg nil 'face
				    (org-get-todo-face tg)))
	    (when (and (= cnt 0) (not ingroup)) (insert "  "))
	    (setq prompt (concat prompt "[" (char-to-string c) "] " tg " "))
	    (insert "[" c "] " tg (make-string
				   (- fwidth 4 (length tg)) ?\ ))
	    (when (and (= (setq cnt (1+ cnt)) ncol)
		       ;; Avoid lines with just a closing delimiter.
		       (not (equal (car tbl) '(:endgroup))))
	      (insert "\n")
	      (when ingroup (insert "  "))
	      (setq cnt 0)))))
	(insert "\n")
	(goto-char (point-min))
	(unless expert (org-fit-window-to-buffer))
	(message (concat "[a-z..]:Set [SPC]:clear"
			 (if expert (concat "\n" prompt) "")))
	(setq c (let ((inhibit-quit t)) (read-char-exclusive)))
	(setq subtable (nreverse subtable))
	(cond
	 ((or (= c ?\C-g)
	      (and (= c ?q) (not (rassoc c fulltable))))
	  (setq quit-flag t))
	 ((= c ?\ ) nil)
	 ((setq e (or (rassoc c subtable) (rassoc c fulltable))
		tg (car e))
	  tg)
	 (t (setq quit-flag t)))))))

(advice-add 'org-fast-todo-selection :override
            #'circ/org-fast-todo-selection)
#+end_src
*** Redefine =org-add-log-note= to not delete othe windows
#+begin_src emacs-lisp
(defun circ/org-add-log-note (&optional _purpose)
  "Pop up a window for taking a note, and add this note later."
  (remove-hook 'post-command-hook 'org-add-log-note)
  (setq org-log-note-window-configuration (current-window-configuration))
;; DON'T DELETE OTHER WINDOWS
;;  (delete-other-windows)
  (move-marker org-log-note-return-to (point))
  (pop-to-buffer-same-window (marker-buffer org-log-note-marker))
  (goto-char org-log-note-marker)
  (org-switch-to-buffer-other-window "*Org Note*")
  (erase-buffer)
  (if (memq org-log-note-how '(time state))
      (org-store-log-note)
    (let ((org-inhibit-startup t)) (org-mode))
;; Message altered to include evil keys
    (insert (format "# Insert note for %s.
# Finish with [q] / [C-c C-c], or cancel with [Q] / [C-c C-k].\n\n"
		    (cl-case org-log-note-purpose
		     (clock-out "stopped clock")
		     (done  "closed todo item")
		     (reschedule "rescheduling")
		     (delschedule "no longer scheduled")
		     (redeadline "changing deadline")
		     (deldeadline "removing deadline")
		     (refile "refiling")
		     (note "this entry")
		     (state
		      (format "state change from \"%s\" to \"%s\""
			      (or org-log-note-previous-state "")
			      (or org-log-note-state "")))
		     (t (error "This should not happen")))))
    (when org-log-note-extra (insert org-log-note-extra))
    (setq-local org-finish-function 'org-store-log-note)
    (run-hooks 'org-log-buffer-setup-hook)))

(advice-add 'org-add-log-note :override
            #'circ/org-add-log-note)
#+end_src
** Fix M-S-j/k when changing timestamps on newly opened buffer
#+begin_src emacs-lisp
(add-hook 'org-mode-hook 'evil-normalize-keymaps)
#+end_src
** Set q and Q keys on org add note
#+begin_src emacs-lisp
(defun circ/org-note-set-evil-quit-keys ()
  (interactive)
  (evil-local-set-key 'normal "q" 'org-ctrl-c-ctrl-c)
  (evil-local-set-key 'normal "Q" 'org-kill-note-or-show-branches))

(add-hook 'org-log-buffer-setup-hook 'circ/org-note-set-evil-quit-keys)
#+end_src
** Org Clocking settings
To sync clocks with multiple devices.

Disabled cause it doesn't work very well.
#+begin_src emacs-lisp
;; (setq org-clock-persist 'clock)
;; (setq org-clock-persist-query-resume nil)
;; (setq org-clock-persist-file "~/pims/org-clock-save.el")
;; (org-clock-persistence-insinuate)
;; (add-hook 'org-clock-in-hook 'org-clock-save)
;; (add-hook 'org-clock-out-hook 'org-clock-save)

;; (defun circ/after-revert-maybe-load-clock ()
;;   (when (circ/org-agenda-file-p)
;;     (org-clock-load)))
;; (add-hook 'after-revert-hook 'circ/after-revert-maybe-load-clock)

;; (defun circ/org-clock-save-file-fix-paths ()
;;   (let ((full-home-dir (expand-file-name "~/"))
;;         (abbrev-home-dir "~/"))
;;     (with-temp-file org-clock-persist-file
;;       (insert-file-contents org-clock-persist-file)
;;       (while (search-forward full-home-dir nil t)
;;         (replace-match abbrev-home-dir)))))

;; (advice-add 'org-clock-load
;;             :before
;;             (lambda () (setq org-clock-loaded nil))
;;             '((name . "set-org-clock-loaded-nil")))

;; (advice-add 'org-clock-save
;;             :after
;;             'circ/org-clock-save-file-fix-paths
;;             '((name . "circ/org-clock-save-file-fix-paths")))

;; (org-clock-load)
#+end_src
* Mode Line
#+BEGIN_SRC emacs-lisp
(circ/log-message "Setting up mode line")
(column-number-mode 1) ; show column number
(set-face-attribute 'mode-line nil ; Set active mode line colour
                    :foreground "white"
                    :background "darkgreen")
(set-face-attribute 'mode-line-buffer-id nil ; Set buffer id colour
                    :foreground "white"
                    :background "black")
#+END_SRC

* Custom Functions
** Helper Functions
#+BEGIN_SRC emacs-lisp
(defun circ/strip-last-newline (string)
  (replace-regexp-in-string "\n\\'" "" string))

(defun circ/escape-double-quotes (string)
  (replace-regexp-in-string "\"" "\\\\\"" string))

(defun circ/strip-font-properties (string)
  (set-text-properties 0 (length string) nil string)
  string)
#+END_SRC

** eshell-new
Interative function to create a new instance of eshell.

#+BEGIN_SRC emacs-lisp
(defun circ/eshell-new ()
  "Open a new instance of eshell."
  (interactive)
  (eshell 'N))
#+END_SRC

** transpose-buffers
Transpose two buffers.

#+BEGIN_SRC emacs-lisp
(defun circ/transpose-buffers (dir &optional arg)
  "Transpose the buffers in the current window and the target window
If arg is non-nil, the selected window will change to keep the source buffer
selected."
  (let ((target-window (windmove-find-other-window dir))
        (source-window (selected-window)))
    (cond ((null target-window)
           (format "No window found in dir %s" dir))
          ((and (window-minibuffer-p target-window)
                (not (minibuffer-window-active-p target-window)))
           (user-error "Minibuffer is inactive"))
          (t
           (let ((target-buffer (window-buffer target-window))
                 (source-buffer (window-buffer)))
             (set-window-buffer target-window source-buffer)
             (set-window-buffer source-window target-buffer))
           (if arg
               (select-window target-window))))))

(defun circ/transpose-buffers-left (&optional arg)
    "Transpose buffers from current window to buffer to the left"
  (interactive)
  (circ/transpose-buffers 'left arg))

(defun circ/transpose-buffers-up (&optional arg)
    "Transpose buffers from current window to buffer above"
  (interactive)
  (circ/transpose-buffers 'up arg))

(defun circ/transpose-buffers-right (&optional arg)
    "Transpose buffers from current window to buffer to the right"
  (interactive)
  (circ/transpose-buffers 'right arg))

(defun circ/transpose-buffers-down (&optional arg)
    "Transpose buffers from current window to buffer below"
  (interactive)
  (circ/transpose-buffers 'down arg))
#+END_SRC

** cast-buffer
Send a buffer to another window.

#+BEGIN_SRC emacs-lisp
(defun circ/cast-buffer (dir &optional arg)
  "Casts the current buffer to window in direction dir, and switches current
window back to last buffer.
If arg is non-nil, the targetted window is selected."
  (let ((target-window (windmove-find-other-window dir))
        (source-buffer (window-buffer)))
    (cond ((null target-window)
           (format "No window found in dir %s" dir))
          ((and (window-minibuffer-p target-window)
                (not (minibuffer-window-active-p target-window)))
           (user-error "Minibuffer is inactive"))
          (t
           (set-window-buffer target-window source-buffer)
           (previous-buffer)
           (if arg
               (select-window target-window))))))

(defun circ/cast-buffer-left (&optional arg)
  "Cast current buffer to the left"
  (interactive)
  (circ/cast-buffer 'left arg))

(defun circ/cast-buffer-up (&optional arg)
  "Cast current buffer up"
  (interactive)
  (circ/cast-buffer 'up arg))

(defun circ/cast-buffer-right (&optional arg)
  "Cast current buffer to the right"
  (interactive)
  (circ/cast-buffer 'right arg))

(defun circ/cast-buffer-down (&optional arg)
  "Cast current buffer down"
  (interactive)
  (circ/cast-buffer 'down arg))
#+END_SRC

** duplicate-buffer
Open buffer in another window.

#+BEGIN_SRC emacs-lisp
(defun circ/duplicate-buffer (dir &optional arg)
  "Opens the current buffer in the window in the direction dir
If arg is non-nil, the targeted window is selected"
  (let ((target-window (windmove-find-other-window dir))
        (source-buffer (window-buffer)))
    (cond ((null target-window)
           (format "No window found in dir %s" dir))
          ((and (window-minibuffer-p target-window)
                (not (minibuffer-window-active-p target-window)))
           (user-error "Minibuffer is inactive"))
          (t
           (set-window-buffer target-window source-buffer)
           (if arg
               (select-window target-window))))))

(defun circ/duplicate-buffer-left (&optional arg)
  "Cast current buffer to the left"
  (interactive)
  (circ/duplicate-buffer 'left arg))

(defun circ/duplicate-buffer-up (&optional arg)
  "Cast current buffer up"
  (interactive)
  (circ/duplicate-buffer 'up arg))

(defun circ/duplicate-buffer-right (&optional arg)
  "Cast current buffer to the right"
  (interactive)
  (circ/duplicate-buffer 'right arg))

(defun circ/duplicate-buffer-down (&optional arg)
  "Cast current buffer down"
  (interactive)
  (circ/duplicate-buffer 'down arg))
#+END_SRC

** regenerate-tags
Regenerate tags using a command defined in the project root under the =.emacs=
directory.

#+BEGIN_SRC emacs-lisp
(defun circ/regenerate-tags ()
  "use the generate-tags script in the project root to generate tags"
  (interactive)
  (cond ((projectile-project-root)
         (let* ((root-dir (projectile-project-root))
                (generate-tags-script (concat root-dir ".emacs/generate-tags"))
                (tag-command (concat ". " generate-tags-script " " root-dir))
                (result (if (file-exists-p generate-tags-script)
                            (shell-command-to-string tag-command)
                          (projectile-regenerate-tags))))
           (message result)))
        (t
         (user-error "Not in a project!"))))
#+END_SRC

** open-terminal-in-workdir
Opens a konsole in the current project root. If not in project, opens it in the
current directory.

#+BEGIN_SRC emacs-lisp
(defun circ/open-terminal-in-workdir ()
 "Opens a terminal in the project root.
If not in a project, opens it in the current directory."
 (interactive)
 (let ((workdir (if (projectile-project-root)
                    (projectile-project-root)
                  default-directory)))
   (call-process-shell-command
    (concat "konsole --workdir " workdir) nil 0)))
#+END_SRC

** whitespace-mode
Toggle on and off whitespace trailing mode

#+BEGIN_SRC emacs-lisp
(defun circ/toggle-whitespace-full ()
  "toggle display of more whitespace"
  (interactive)
  (whitespace-toggle-options '(lines-tail)))
#+END_SRC

** alignment functions
#+BEGIN_SRC emacs-lisp
(defun circ/align-once-head (start end regexp)
  "Align by regex once, adding spaces to the head of the regexp"
  (interactive "r\nsAlign once head regexp: ")
  (align-regexp start end
                (concat "\\(\\s-*\\)" regexp) 1 1 nil))

(defun circ/align-once-tail (start end regexp)
  "Align by regex once, adding spaces to the tail of the regexp"
  (interactive "r\nsAlign once tail regexp: ")
  (align-regexp start end
                (concat regexp "\\(\\s-*\\)") 1 1 nil))

(defun circ/align-repeat-head (start end regexp)
  "Align by regex repeatedly, adding spaces to the head of the regexp"
  (interactive "r\nsAlign repeat head regexp: ")
  (align-regexp start end
                (concat "\\(\\s-*\\)" regexp) 1 1 t))

(defun circ/align-repeat-tail (start end regexp)
  "Align by regex repeatedly, adding spaces to the tail of the regexp"
  (interactive "r\nsAlign repeat tail regexp: ")
  (align-regexp start end
                (concat regexp "\\(\\s-*\\)") 1 1 t))
#+END_SRC

** file opener functions
Some extra functions to aid in opening files

#+BEGIN_SRC emacs-lisp
(defun circ/find-file-line (filename linenum)
  "invoke function find-file and goto-line"
  (find-file filename)
  (goto-line linenum))
#+END_SRC

The =find-file-line= function expects two args. We just therefore parse any
FILENAME:LINENUMBER string that it uses.

#+BEGIN_SRC emacs-lisp
(defun circ/parse-file-special-syntax (file-string)
  "parses the format FILENAME:LINENUMBER"
  (let* ((file-list (split-string file-string ":"))
         (filename (car file-list))
         (line-number (string-to-number(cadr file-list))))
    (list filename line-number)))
#+END_SRC

We also want the ability to parse dirty file paths.

#+BEGIN_SRC emacs-lisp
(defun circ/clean-file-path (file-string)
  "cleans the file path"
  (replace-regexp-in-string
   "^.*:[0-9]*\\(.*\\)$"
   ""
   file-string
   nil nil 1))
#+END_SRC

Plus we need a function to tie it all together.

#+BEGIN_SRC emacs-lisp
(defun circ/find-file-special-syntax (file-string)
  "opens special syntax"
  (apply 'circ/find-file-line
         (circ/parse-file-special-syntax
          (circ/clean-file-path file-string))))
#+END_SRC

** open-in-intellij
Helpful function to open the current buffer and line in intellij.

The complimentary command for intellij is:
#+BEGIN_SRC sh
emacsclient -n +$LINENUMBER$:$COLUMN$ $FILE$
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun circ/open-in-intellij ()
  "Open the current file + line in intellij"
  (interactive)
  (let* ((file (buffer-file-name))
         (line-num (number-to-string (line-number-at-pos)))
         (command (concat "idea " file ":" line-num)))
    (shell-command command)
    (message "file opened in intellij")))
#+END_SRC

** check-project
Compile / check the project and send results to ivy-read.

Expects results in the format:

#+BEGIN_EXAMPLE
FILENAME:100 explanation
FILENAME:200 explanation
FILENAME:40can also be dirty
#+END_EXAMPLE

#+BEGIN_SRC emacs-lisp
(defun circ/check-project ()
  "run .emacs/check-project and put results in ivy-read"
  (interactive)
  (cond ((projectile-project-root)
         (message "Checking project...")
         (let* ((root-dir (projectile-project-root))
                (script (concat root-dir ".emacs/check-project"))
                (command (concat ". " script " " root-dir))
                (result (shell-command-to-string command)))
           (cond ((> (length result) 0)
                  (completing-read "Check project results: "
                                   (split-string result "\n")
                                   :action 'circ/find-file-special-syntax))
                 (t
                  (user-error "Check complete")))))
        (t
         (user-error "Not in a project!"))))
#+END_SRC

** show-file-path
Show the full file path as a message

#+BEGIN_SRC emacs-lisp
(defun circ/show-file-path ()
  "Show full file path as a message"
  (interactive)
  (if buffer-file-name
      (message buffer-file-name)
    (message "No valid file path")))
#+END_SRC

** show-buffer-name
In case the header is overwritten

#+begin_src emacs-lisp
(defun circ/show-buffer-name ()
  "Show buffer name as a message"
  (interactive)
  (message "%s" (buffer-name)))
#+end_src

** smart-clear-buffer
Clear the buffer, but with special cases for certain major modes.

#+BEGIN_SRC emacs-lisp
(defun circ/smart-clear-buffer ()
  "Clear the current buffer. term-mode requires different command to clear."
  (interactive)
  (case major-mode
    ('term-mode (comint-clear-buffer))
    (otherwise (erase-buffer))))
#+END_SRC

** Revert project buffers
Revert all the buffers in the current project.

#+BEGIN_SRC emacs-lisp
(defun circ/revert-project-buffers ()
  (interactive)
  (let* ((project (projectile-ensure-project (projectile-project-root)))
         (project-buffers (projectile-project-buffers project))
         (buffers (remove-if-not 'buffer-file-name project-buffers)))
    (dolist (buffer buffers)
      (with-current-buffer buffer
        (ignore-errors (revert-buffer nil t))
        (message "Reverted: %s" buffer)))
    (message "Project buffers reverted")))
#+END_SRC
** Save all project buffers
#+BEGIN_SRC emacs-lisp
(defun circ/save-project-buffers ()
  (interactive)
  (let* ((project (projectile-ensure-project (projectile-project-root)))
         (project-buffers (projectile-project-buffers project))
         (buffers (remove-if-not 'buffer-file-name project-buffers)))
    (dolist (buffer buffers)
      (with-current-buffer buffer
        (save-buffer)
        (message "Saved: %s" buffer)))
    (message "Project buffers saved")))
#+END_SRC
** Org Set Property
#+BEGIN_SRC emacs-lisp
(defun circ/org-set-property (property &optional val)
  (interactive)
  (let* ((current-value (org-entry-get nil property))
         (value (cond (val val)
                      (t (read-string (format "Set property %s: " property)
                                      current-value)))))
    (org-entry-put nil property value)))
#+END_SRC
** Org file reference
#+BEGIN_SRC emacs-lisp
(defun circ/org-file-reference ()
  (interactive)
  (let* ((target-file (expand-file-name
                       (completing-read "File reference (C-M-j to done): "
                                        (mapcar (lambda (filepath)
                                                  (file-relative-name
                                                   filepath
                                                   circ/org-reference-directory))
                                                (directory-files-recursively
                                                 circ/org-reference-directory
                                                 ".*\.org"
                                                 nil)))
                       circ/org-reference-directory))
         (org-heading (org-get-heading)))
    (org-back-to-heading)
    (org-cut-subtree)

    (find-file target-file)
    (let ((target-buffer (get-file-buffer target-file)))
      (unless (file-exists-p target-file)
        (make-directory (file-name-directory target-file) t)
        (with-current-buffer target-buffer
          (insert (concat "#+TITLE: " org-heading))
          (newline))
        (message "Created file"))
      (with-current-buffer target-buffer
        (end-of-buffer)
        (newline)
        (yank)
        (save-buffer)))))
#+END_SRC
** Buffer yank paste
#+BEGIN_SRC emacs-lisp
(setq circ/buffer-clipboard nil)

(defun circ/buffer-yank ()
  (interactive)
  (setq circ/buffer-clipboard (current-buffer)))

(defun circ/buffer-paste ()
  (interactive)
  (when circ/buffer-clipboard
    (set-window-buffer (selected-window) circ/buffer-clipboard)))
#+END_SRC
** Kill buffer
#+BEGIN_SRC emacs-lisp
(defun circ/kill-this-buffer ()
  (interactive)
  (kill-buffer (current-buffer)))
#+END_SRC
** References
#+BEGIN_SRC emacs-lisp
(defun circ/pims/list-reference-files ()
  (mapcar (lambda (file)
            (replace-regexp-in-string (regexp-quote (expand-file-name circ/pims/reference-directory))
                                      "" file))
          (directory-files-recursively circ/pims/reference-directory "")))

(defun circ/pims/reference-completing-read (&optional initial-input)
  (completing-read "Reference: "
                   (circ/pims/list-reference-files)
                   nil nil initial-input))

(defun circ/pims/find-reference ()
  (interactive)
  (let* ((filepath (circ/pims/reference-completing-read))
         (full-filepath (concat (expand-file-name circ/pims/reference-directory) filepath)))
    (circ/ensure-file full-filepath)
    (find-file full-filepath)))

(defun circ/pims/insert-reference-link ()
  (interactive)
  (let* ((filepath (circ/pims/reference-completing-read))
         (description (read-string "Description: " (concat "Ref: " filepath)))
         (org-link (concat "ref:" filepath))
         (full-filepath (concat (expand-file-name circ/pims/reference-directory) filepath)))
    (circ/ensure-file full-filepath)
    (insert (org-make-link-string org-link description))))

(defun circ/ensure-file (filepath)
  (unless (file-exists-p full-filepath)
    (make-directory (file-name-directory full-filepath) t)
    (write-region (concat "#+TITLE: "
                   (capitalize (replace-regexp-in-string
                                "_" " " (file-name-base filepath))))
                  nil full-filepath)))

(defun circ/pims/reference-directories ()
  (seq-uniq
   (mapcar (lambda (f)
             (replace-regexp-in-string "/$" ""
                                       (file-name-directory f)))
           (circ/pims/list-reference-files))))


(defun circ/pims/file-web-page-archive ()
  (interactive)
  (dolist (file (directory-files (expand-file-name "~/Downloads/web_page_archive")
                                 t directory-files-no-dot-files-regexp))
    (let* ((filename (concat (file-name-base file)
                             (file-name-extension file t)))
           (directory (completing-read (format "File %s to: " filename)
                                       (circ/pims/reference-directories)))
           (target-dir (file-name-as-directory
                          (concat (expand-file-name circ/pims/reference-directory)
                                  directory)))
           (target-path (concat target-dir filename)))
      (message "Moving %s to %s" file target-path)
      (make-directory target-dir t)
      (rename-file file target-path))))
#+END_SRC

** Surround
#+BEGIN_SRC emacs-lisp
(defun circ/surround-parentheses () (interactive) (circ/surround "(" ")"))
(defun circ/surround-brackets    () (interactive) (circ/surround "[" "]"))
(defun circ/surround-braces      () (interactive) (circ/surround "{" "}"))
(defun circ/surround-asterisk    () (interactive) (circ/surround "*" "*"))
(defun circ/surround-d-quote     () (interactive) (circ/surround "\"" "\""))
(defun circ/surround-s-quote     () (interactive) (circ/surround "'" "'"))
(defun circ/surround-slash       () (interactive) (circ/surround "/" "/"))
(defun circ/surround-equals      () (interactive) (circ/surround "=" "="))
(defun circ/surround-plus        () (interactive) (circ/surround "+" "+"))
(defun circ/surround-minus       () (interactive) (circ/surround "-" "-"))

(defun circ/surround-region ()
  (interactive)
  (let* ((start (read-string "Beginning: "))
         (end (read-string "End: " start)))
    (circ/surround start end)))

(defun circ/surround (start end)
  (let ((region (buffer-substring (region-beginning) (region-end))))
    (delete-region (region-beginning) (region-end))
    (insert (format "%s%s%s" start region end))))
#+END_SRC

** Insert org timestamp
#+BEGIN_SRC emacs-lisp
(defun circ/insert-label-timestamp (label)
  (insert (format "%s: " label))
  (org-time-stamp-inactive))

(defun circ/insert-created-timestamp ()
  (interactive)
  (circ/insert-label-timestamp "Created"))
#+END_SRC
** Term Mode Functions
#+BEGIN_SRC emacs-lisp
(defun circ/term/delete-previous-word ()
  "Simulates typical C-<backspace> behaviour by sending C-w instead."
  (interactive)
  (term-send-raw-string "\C-w"))

(defun circ/term/delete-next-word ()
  "Simulates typical C-<delete> behaviour by sending M-d instead."
  (interactive)
  (term-send-raw-string "\^[d"))

(defun circ/term/go-to-previous-word ()
  "Simulates typical C-<left> behaviour by sending M-b instead."
  (interactive)
  (term-send-raw-string "\^[b"))

(defun circ/term/go-to-next-word ()
  "Simulates typical C-<right> behaviour by sending M-f instead."
  (interactive)
  (term-send-raw-string "\^[f"))
#+END_SRC

** Shell Command
#+BEGIN_SRC emacs-lisp
(defvar circ/shell-line-history '())

(defun circ/do-sh-cmd (input-list command &optional strip-newline)
  (let (output-list)
    (dolist (dirty-input input-list)
      (set-text-properties 0 (length dirty-input) nil dirty-input)
      (let* ((input (circ/escape-double-quotes
                     (circ/strip-last-newline
                      dirty-input)))
             (output (shell-command-to-string
                      (concat command " <<< \"" input "\""))))
        (setq output-list (cons (if strip-newline
                                    (circ/strip-last-newline output)
                                  output) output-list))))
    (reverse output-list)))

(defun circ/sh-cmd (&optional cmd whole-buffer split-lines)
  "Execute CMD on the buffer. If CMD is nil, ask the user what
command to use. If split-lines is non-nil, split the input by
newlines and send each line into the command individually.

Use the selected region as the input to the shell command. If no
region is selected, use the current line as the input, except
when WHOLE-BUFFER is non-nil, in which case, use the entire
buffer as the input.

A history of executed commands is kept."
  (interactive)
  (let ((command (cond (cmd cmd)
                       (t (completing-read "Command (C-M-j to done): "
                                           circ/shell-line-history)))))
    (add-to-list 'circ/shell-line-history command)
    (cond ((eq evil-this-type 'block)
           ;; Case when region is an evil block
           (let* ((rb (region-beginning))
                  (re (region-end))
                  (input-list (extract-rectangle rb re))
                  (output-list (circ/do-sh-cmd input-list command t))
                  (start (= (point) rb)))
             (goto-char rb)
             (delete-rectangle rb re)
             (insert-rectangle output-list)
             ;; after inserting rectanble, point will move to the end of the
             ;; input, so if the point was at the start of the rectangle, then
             ;; move it back.
             (when start
               (goto-char rb))))
          (t
           (let* ((rb (cond (whole-buffer (point-min))
                            ((use-region-p) (region-beginning))
                            (t (line-beginning-position))))
                  (re (cond (whole-buffer (point-max))
                            ((use-region-p) (region-end))
                            (t (line-end-position))))
                  (input (buffer-substring rb re))
                  (input-list (cond (split-lines (split-string input "\n"))
                                    (t (list input))))
                  (output-list (circ/do-sh-cmd input-list command (not whole-buffer))))
             (delete-region rb re)
             (dolist (line output-list)
               (insert line)))))))
#+END_SRC
** Org agenda habits
Force habit graphs to be drawn everywhere
#+BEGIN_SRC emacs-lisp
(defvar circ/org-habit-show-graphs-everywhere t
  "If non-nil, show habit graphs in all types of agenda buffers.

Normally, habits display consistency graphs only in
\"agenda\"-type agenda buffers, not in other types of agenda
buffers.  Set this variable to any non-nil variable to show
consistency graphs in all Org mode agendas.")

(defun circ/org-agenda-mark-habits ()
  "Mark all habits in current agenda for graph display.

This function enforces `circ/org-habit-show-graphs-everywhere' by
marking all habits in the current agenda as such.  When run just
before `org-agenda-finalize' (such as by advice; unfortunately,
`org-agenda-finalize-hook' is run too late), this has the effect
of displaying consistency graphs for these habits.

When `circ/org-habit-show-graphs-everywhere' is nil, this function
has no effect."
  (when (and circ/org-habit-show-graphs-everywhere
         (not (get-text-property (point) 'org-series)))
    (let ((cursor (point))
          item data)
      (while (setq cursor (next-single-property-change cursor 'org-marker))
        (setq item (get-text-property cursor 'org-marker))
        (when (and item (org-is-habit-p item))
          (with-current-buffer (marker-buffer item)
            (setq data (org-habit-parse-todo item)))
          (put-text-property cursor
                             (next-single-property-change cursor 'org-marker)
                             'org-habit-p data))))))

(advice-add #'org-agenda-finalize :before #'circ/org-agenda-mark-habits)
#+END_SRC
** Org agenda setup
#+BEGIN_SRC emacs-lisp
(defun circ/setup-agenda-view()
  (interactive)
  (circ/open-inbox)
  (split-window-right)
  (circ/alias-org-agenda-tasks)
  (split-window-right)
  (circ/alias-org-agenda-agenda)
  (balance-windows)
  (windmove-right)
  (circ/org-agenda-redo)
  (windmove-left)
  (circ/org-agenda-redo)
  (circ/set-frame-name "PIMS"))
#+END_SRC
** Org mode templates
#+BEGIN_SRC emacs-lisp
(setq circ/org-template-alist
      '(("Is this useful?" . "*Is this useful?*
/What do you think you could use it for?/

/What does it do?/
")
        ("Does this fix my issue?" . "*Does this fix my issue?*
/What issue could this solve?/

/What features does this have?/

/How could such features solve your problem?/")
        ("")
        ("Research" . 'circ/org-research-template)))

(defun circ/org-research-template ()
  (interactive)
  (let ((phrase (read-string "Phrase to search: ")))
    (move-end-of-line 1)
    (org-insert-heading nil)
    (insert "TODO Research \"" phrase "\"")
    (org-set-tags '("ORDERED"))
	  (org-entry-put nil "ORDERED" "t")

    (move-end-of-line 2)
    (org-insert-subheading nil)
    (insert "TODO Search \"" phrase "\" And Note Any Links")
    (org-set-tags '("internet" "search"))

    (move-end-of-line 1)
    (insert "\n")
    (insert "[[ddg:" phrase "]]\n"
            "\n"
            "Reference Links:\n"
            "- ")

    (move-end-of-line 1)
    (org-insert-heading nil)
    (insert "TODO Read Links And Make Notes On Each One")
    (org-set-tags '("internet" "notetaking"))

    (move-end-of-line 1)
    (org-insert-heading nil)
    (insert "TODO Write Down Conclusion Based On Notes")
    (org-set-tags '("internet" "notetaking"))))

(defun circ/org-template-insert ()
  (interactive)
  (let ((template (cdr (assoc (completing-read "Template: "
                                               circ/org-template-alist)
                              circ/org-template-alist))))
    (cond ((stringp template)
           (move-end-of-line 1)
           (insert "\n" template))
          (t
           (funcall (cadr template))))))
#+END_SRC
** Org sort headlines
Sorts the level 0 headlines by todo state
#+BEGIN_SRC emacs-lisp
(defun circ/org-hide-all ()
  (interactive)
  (org-map-entries
   (lambda () (outline-hide-subtree))
   nil 'file))

(defun circ/org-sort-headlines ()
  (interactive)
  (mark-whole-buffer)
  (org-sort-entries nil ?o)
  (circ/org-hide-all))
#+END_SRC
** Bash history
#+BEGIN_SRC emacs-lisp
(defun circ/bash-history ()
  (reverse
   (remove-if (lambda (string) (string-match-p "^#[0-9]*$" string))
              (split-string
               (with-temp-buffer
                 (insert-file-contents "~/.bash_history")
                 (buffer-substring-no-properties (point-min) (point-max)))
               "\n" t))))

(defun circ/bash-history-search()
  (interactive)
  (if (string-equal major-mode "term-mode")
      (progn
        (let* (;; Hacky fix for ivy sorting. Does not work with default
               ;; completing-read function
               (ivy-sort-functions-alist nil)
               (string (completing-read "History: " (circ/bash-history))))
          (term-send-raw-string string)
          (term-send-raw-string "\n")))
    (message "Not in term-mode")))
#+END_SRC
** Set Frame Name
A wrapper around the =set-frame-name= function to automatically append " - Emacs"
to the title and pre-fill the default input as the current frame name.

#+BEGIN_SRC emacs-lisp
(defun circ/set-frame-name (&optional name)
  (interactive)
  (let ((title (cond (name name)
                     (t (read-string "Title: "
                                     (replace-regexp-in-string
                                      " - Emacs$" ""
                                      (frame-parameter nil 'name)))))))
    (set-frame-name (concat title " - Emacs"))))
#+END_SRC
** New Scratch Modes
#+BEGIN_SRC emacs-lisp
(defun new-scratch-with-mode (mode)
  "Opens a new scratch buffer in given mode. If one already exists,
creates a new one"
  (interactive)
  (let ((name (concat "*" (symbol-name mode) "-scratch*")))
    (switch-to-buffer (get-buffer-create "*new-scratch-mode*"))
    (rename-buffer name t)
    (funcall mode)))

;; Add new scratch modes below
(defun new-scratch-json-mode ()
  (interactive)
  (new-scratch-with-mode 'json-mode))

(defun new-scratch-org-mode ()
  (interactive)
  (new-scratch-with-mode 'org-mode))

(defun new-scratch-text-mode ()
  (interactive)
  (new-scratch-with-mode 'text-mode))

(defun new-scratch-shell-script-mode ()
  (interactive)
  (new-scratch-with-mode 'shell-script-mode))

(defun new-scratch-python-mode ()
  (interactive)
  (new-scratch-with-mode 'python-mode))
#+END_SRC
** Disable evil quickscope
#+BEGIN_SRC emacs-lisp
(defun circ/disable-evil-quickscope-mode ()
  (evil-quickscope-mode -1))
#+END_SRC
** run-proc-and-fun
A function to run a shell program in the background and run a function on the
resulting buffer output.
#+BEGIN_SRC emacs-lisp
(defun circ/run-proc-and-fun (process-name buffer-name directory arg-list
                                           &optional erase-buffer fun)
  "Call ARG-LIST and run FUN in the results buffer.
Calls `start-process' with PROCESS-NAME BUFFER-NAME and ARG-LIST.
DIRECTORY sets the directory the process is run in.
ERASE-BUFFER, if non-nil will erase the results buffer before running
the process.
FUN, if a function, will be run after the process has finished.

Example

(circ/run-proc-and-fun \"test\" \"*test*\" \"~/Downloads\" (list \"ls\" \"-lh\") t
             (lambda ()
               (insert \"test4\\n\")))

NOTE: I use `list' because I don't know how to show a real
apostrophe in the doc"
  (interactive)
  (let* ((buf (get-buffer-create buffer-name)))
    (with-current-buffer buf
      (when erase-buffer
        (erase-buffer))
      (setq-local process-name process-name)
      (setq-local process-directory directory)
      (setq-local post-process-fun fun)
      (set-process-sentinel
       (let ((process-fun (append
                           (list process-name (current-buffer))
                           arg-list))
             (default-directory process-directory))
         (apply 'start-process process-fun))
       (lambda (process event)
         (unless (process-live-p process)
           (with-current-buffer (process-buffer process)
             (goto-char (point-max))
             (when (functionp post-process-fun)
               (funcall post-process-fun))
             (goto-char (point-max))))))))
  (message "Process started: %s" arg-list))
#+END_SRC
** RSS Feed Functions
Subscribe to subreddits
#+BEGIN_SRC emacs-lisp
(defun circ/generate-subreddit-feed ()
  (interactive)
  (let* ((subreddit (read-string "subreddit: r/"))
         (type (completing-read "Feed Type: "
                                '("Hot"
                                  "New"
                                  "Rising"
                                  "Controversial"
                                  "Top of the Past Hour"
                                  "Top of the Past Day"
                                  "Top of the Past Week"
                                  "Top of the Past Month"
                                  "Top of the Past Year"
                                  "Top of All Time")))
         (url (concat "https://www.reddit.com/r/" subreddit "/"
                      (cond ((string= type "Hot")                   "")
                            ((string= type "New")                   "new/")
                            ((string= type "Rising")                "rising/")
                            ((string= type "Controversial")         "controversial/")
                            ((string= type "Top of the Past Hour")  "top/")
                            ((string= type "Top of the Past Day")   "top/")
                            ((string= type "Top of the Past Week")  "top/")
                            ((string= type "Top of the Past Month") "top/")
                            ((string= type "Top of the Past Year")  "top/")
                            ((string= type "Top of All Time")       "top/"))
                      ".rss"
                      (cond ((string= type "Top of the Past Hour")  "?t=hour")
                            ((string= type "Top of the Past Day")   "?t=day")
                            ((string= type "Top of the Past Week")  "?t=month")
                            ((string= type "Top of the Past Month") "?t=month")
                            ((string= type "Top of the Past Year")  "?t=year")
                            ((string= type "Top of All Time")       "?t=all"))))
         (title (concat subreddit
                        (cond ((string= type "Hot")                   "")
                              ((string= type "New")                   " (new)")
                              ((string= type "Rising")                " (rising)")
                              ((string= type "Controversial")         " (controversial)")
                              ((string= type "Top of the Past Hour")  " (hourly)")
                              ((string= type "Top of the Past Day")   " (daily)")
                              ((string= type "Top of the Past Week")  " (weekly)")
                              ((string= type "Top of the Past Month") " (monthly)")
                              ((string= type "Top of the Past Year")  " (yearly)")
                              ((string= type "Top of All Time")       " (all time)"))))
         (org-link (format "[[%s][%s]]" url title)))
    (kill-new org-link)
    (message "Copied to clipboard: %s" org-link)))
#+END_SRC

Subscribe to youtube channel
#+BEGIN_SRC emacs-lisp
(defun circ/generate-youtube-channel-feed ()
  (interactive)
  (let* ((youtube-url (read-string "Youtube Channel Link: "))
         (channel-name (read-string "Youtube Channel Name: "))
         (channel-id (replace-regexp-in-string ".*channel/\\([A-Za-z0-9_-]*\\).*" "\\1" youtube-url))
         (url (concat "https://www.youtube.com/feeds/videos.xml?channel_id="
                      channel-id))
         (org-link (format "[[%s][%s]]" url channel-name)))
    (kill-new org-link)
    (message "Copied to clipboard: %s" org-link)))
#+END_SRC
** Desktop notifications
#+BEGIN_SRC emacs-lisp
(defvar circ/notify-command nil)

(defun circ/desktop-notify (subject message timeout)
  (format "timeout 0.2 notify-send -t %s \"%s\" \"%s\"" timeout subject message))
(defun circ/termux-notify (subject message timeout)
  (format "timeout 5 termux-notification -t \"%s\"" subject))

(defun circ/notify (subject &optional message timeout)
  (interactive)
  (let ((timeout-secs (cond (timeout (* 1000 timeout))
                            (t 0))))
    (when (functionp circ/notify-command)
      (when (< 0 (shell-command (funcall circ/notify-command subject message timeout-secs)))
        (user-error "Notification failure: %s" message)))
    (message "Notification: %s %s" subject message)))
#+END_SRC
** vc shortcuts
#+BEGIN_SRC emacs-lisp
(defun circ/vc-diff-head-current ()
"Compare current file against HEAD"
  (interactive)
  (message "%s" (buffer-file-name))
  (vc-version-ediff (list (buffer-file-name)) "HEAD" nil))
#+END_SRC
** Reload all org agendas
#+BEGIN_SRC emacs-lisp
(defun circ/reload-all-org-agendas ()
  (interactive)
  (dolist (buffer (buffer-list))
    (with-current-buffer buffer
      (when (derived-mode-p 'org-agenda-mode)
        (let ((window (get-buffer-window buffer t)))
          (when window
            (with-selected-window window
              (org-agenda-redo))))))))

(defun circ/maybe-refresh-all-org-agendas ()
  (when (circ/org-agenda-file-p)
    (circ/reload-all-org-agendas)))

; (add-hook 'after-save-hook 'circ/maybe-refresh-all-org-agendas)
; (add-hook 'after-revert-hook 'circ/maybe-refresh-all-org-agendas)
#+END_SRC
** copy-buffer
Major mode for copy buffer
#+BEGIN_SRC emacs-lisp
(defvar copy-buffer-mode-map
  (let ((map (make-sparse-keymap)))
    map)
  "Keymap for `copy-buffer-mode'.")

(define-derived-mode copy-buffer-mode org-mode "copy-buffer"
  "Major mode for copy-buffer."
  (set (make-local-variable 'revert-buffer-function) #'copy-buffer))

(defvar copy-buffer-copy-function 'nil)

(defun copy-buffer-copy-function-desktop (string)
  (kill-new string))

(defun copy-buffer-copy-function-termux (string)
  (shell-command (concat "termux-clipboard-set" " "
                         "\"" string "\"")))

(defun copy-buffer-copy-quit ()
  (interactive)
  (cond ((functionp copy-buffer-copy-function)
         (funcall copy-buffer-copy-function (buffer-string))
         (circ/kill-this-buffer))
        (t
         (user-error "Error. Please set `copy-buffer-copy-function' to a function."))))

(defun copy-buffer ()
  (interactive)
  (let ((buf (get-buffer-create "*copy-buffer-new*")))
    (with-current-buffer buf
      (rename-buffer "*copy-buffer*" t)
      (copy-buffer-mode)
      (switch-to-buffer buf))))
#+END_SRC
** ansi-term
#+BEGIN_SRC emacs-lisp
(defun circ/ansi-term ()
  (interactive)
  (let* ((project-name (projectile-project-name))
         (path default-directory)
         (title (cond ((string= project-name "-") path)
                      (t project-name)))
         (term-name (format "term (%s)" title)))
    (ansi-term "/bin/bash" term-name)
    ;; If you are visiting a remote file, try to open a terminal in the remote box
    (if (and (functionp 'tramp-tramp-file-p)
             (tramp-tramp-file-p path))
        (let ((path (replace-regexp-in-string "^file:" "" path))
              (cd-str "fn=%s; if test ! -d $fn; then fn=$(dirname $fn); fi; cd $fn;")
              (bufname (concat "*" term-name "*" )))
          (let ((tstruct (tramp-dissect-file-name path)))
            (message "%s" (tramp-file-name-hop tstruct))
            (cond ((not (tramp-file-name-hop tstruct))
                   (cond ((equal (tramp-file-name-method tstruct) "ssh")
                          (process-send-string
                           bufname
                           (format (concat "ssh -t %s '" cd-str " exec bash'\n")
                                   (tramp-file-name-host tstruct)
                                   (tramp-file-name-localname tstruct))))
                         (t (error "not implemented for method %s"
                                   (tramp-file-name-method tstruct)))))
                  (t (error "Multiple hops not yet supported"))))))))
#+END_SRC
** reverse goto org clock
#+BEGIN_SRC emacs-lisp
(defun org-agenda-clock-goto ()
  "Jump to the currently clocked in task within the agenda.
If the currently clocked in task is not listed in the agenda
buffer, display it in another window."
  (interactive)
  (let (pos)
    (mapc (lambda (o)
        (if (eq (overlay-get o 'type) 'org-agenda-clocking)
        (setq pos (overlay-start o))))
      (reverse (overlays-in (point-min) (point-max))))
    (cond (pos (goto-char pos))
      ;; If the currently clocked entry is not in the agenda
      ;; buffer, we visit it in another window:
      ((bound-and-true-p org-clock-current-task)
       (org-switch-to-buffer-other-window (org-clock-goto)))
      (t (message "No running clock, use `C-c C-x C-j' to jump to the most recent one")))))
#+END_SRC
** org-set-tags
#+BEGIN_SRC emacs-lisp
(defun circ/org-set-tags ()
  (interactive)
  (let* ((curr-tags (org-get-tags nil t))
         (new-tags (set-difference
                    (mapcar 'car (org-global-tags-completion-table))
                    curr-tags
                    :test 'string=))
         (completion-list (append
                           '("<DONE>")
                           (sort (mapcar (lambda (tag)
                                           (concat "+" tag))
                                         new-tags)
                                 'string<)
                           (sort (mapcar (lambda (tag)
                                           (concat "-" tag))
                                         curr-tags)
                                 'string<)))
         (ivy-sort-functions-alist nil)
         (tag-change (completing-read "Tag: " completion-list))
         (remove (string= "-" (substring tag-change 0 1)))
         (tag (if (or (string= "-" (substring tag-change 0 1))
                      (string= "+" (substring tag-change 0 1)))
                  (substring tag-change 1)
                tag-change))
         (tags (remove* "" (if remove
                               (remove tag curr-tags)
                             (cons tag curr-tags))
                        :test 'string=)))
    (if (not (string= tag-change "<DONE>"))
        (progn
          (org-set-tags-to tags)
          (org--align-tags-here org-tags-column)
          (circ/org-set-tags)))))

(defun circ/org-clear-tags ()
  (interactive)
  (org-set-tags-to nil))
#+END_SRC
** org-agenda-set-tags
#+BEGIN_SRC emacs-lisp
;; TODO: Bug exists in org 9.4.4 where setting a tag in the agenda does not
;; update the tag property correctly. So the tags shown in the completion list
;; are out of date
(defun circ/org-agenda-set-tags ()
  (interactive)
  (let* ((curr-tags (org-get-at-bol 'tags))
         (new-tags (set-difference
                    (mapcar 'car (org-global-tags-completion-table))
                    curr-tags
                    :test 'string=))
         (completion-list (append
                           (mapcar (lambda (tag) (concat "+" tag)) new-tags)
                           (mapcar (lambda (tag) (concat "-" tag)) curr-tags)))
         (tag-change (completing-read "Tag: " completion-list))
         (remove (string= "-" (substring tag-change 0 1)))
         (tag (if (or (string= "-" (substring tag-change 0 1))
                      (string= "+" (substring tag-change 0 1)))
                  (substring tag-change 1)
                tag-change))
         (tags (remove* "" (if remove
                               (remove tag curr-tags)
                             (cons tag curr-tags))
                        :test 'string=)))
    (if remove
        (org-agenda-set-tags tag 'off)
      (org-agenda-set-tags tag 'on))
    (circ/org-agenda-set-tags)))

(defun circ/org-agenda-clear-tags ()
  (interactive)
  (dolist (tag (org-get-at-bol 'tags))
    (org-agenda-set-tags tag 'off)))
#+END_SRC
** org agenda toggle blocked tasks
#+BEGIN_SRC emacs-lisp
(defun circ/org-agenda-toggle-blocked-tasks ()
  (interactive)
  (cond ((eq org-agenda-dim-blocked-tasks 'invisible)
         (setq org-agenda-dim-blocked-tasks t))
        (org-agenda-dim-blocked-tasks
         (setq org-agenda-dim-blocked-tasks 'invisible)))
  (org-agenda-redo))
#+END_SRC
** org agenda toggle clock closed
#+BEGIN_SRC emacs-lisp
(defun circ/org-agenda-toggle-clock-closed ()
  (interactive)
  (cond ((equal org-agenda-log-mode-items '(clock))
         (setq org-agenda-log-mode-items '(closed)))
        (t
         (setq org-agenda-log-mode-items '(clock))))
  (org-agenda-redo))
#+END_SRC
** org agenda toggle hide tags
#+BEGIN_SRC emacs-lisp
(defun circ/org-agenda-toggle-hide-tags ()
  (interactive)
  (if org-agenda-hide-tags-regexp
      (setq org-agenda-hide-tags-regexp nil)
    (setq org-agenda-hide-tags-regexp ".*"))
  (org-agenda-redo))
#+END_SRC
** insert non-ascii characters
#+BEGIN_SRC emacs-lisp
(defun circ/insert-a-macron () (interactive) (insert ""))
(defun circ/insert-e-macron () (interactive) (insert ""))
(defun circ/insert-i-macron () (interactive) (insert ""))
(defun circ/insert-o-macron () (interactive) (insert ""))
(defun circ/insert-u-macron () (interactive) (insert ""))
(defun circ/insert-y-macron () (interactive) (insert ""))
#+END_SRC
** pass
#+begin_src emacs-lisp
(defvar circ/pass/pass-directory "~/.password-store")
(defvar circ/pass/ignore-regexp "")
(defvar circ/pass/clipboard-timeout 30)

(defvar circ/pass/clipboard-field nil)
(defvar circ/pass/clipboard-timeout-job nil)
(defvar circ/pass/kill-ring-pointer nil)

(defun circ/pass/get-entries ()
  (seq-filter
   (lambda (entr)
     (not (string-match-p circ/pass/ignore-regexp entr)))
   (mapcar
    (lambda (entry)
      (file-name-sans-extension
       (replace-regexp-in-string
        (regexp-quote (file-name-as-directory
                       (expand-file-name circ/pass/pass-directory)))
        "" entry)))
    (directory-files-recursively
     (expand-file-name circ/pass/pass-directory) ".gpg$"))))

(defun circ/pass/get-entry-path (entry)
  (concat (file-name-as-directory circ/pass/pass-directory)
          entry
          ".gpg"))

(defun circ/pass/read-entry (entry)
  (with-temp-buffer
    (insert-file-contents (circ/pass/get-entry-path entry))
    (buffer-substring-no-properties (point-min) (point-max))))

(defun circ/pass/parse-entry (entry)
  (mapcar
   (lambda (x)
     (split-string x ": "))
   (split-string (circ/pass/read-entry entry) "\n")))

(defun circ/pass/get-value (entry key)
  (cond ((string= key "password")
         (caar (circ/pass/parse-entry entry)))
        (t
         (cadr (assoc key (circ/pass/parse-entry entry))))))

(defun circ/pass/open-entry (&optional entry)
  (interactive)
  (unless entry (setq entry (completing-read "Pass entry: "
                                             (circ/pass/get-entries))))
  (find-file (circ/pass/get-entry-path entry)))

(defun circ/pass/clear-clipboard ()
  (when circ/pass/clipboard-timeout-job
    (cancel-timer circ/pass/clipboard-timeout-job)
    (setq circ/pass/clipboard-timeout-job nil))
  (when (or (string= (org-get-x-clipboard 'CLIPBOARD) (car circ/pass/kill-ring-pointer))
            (string= (org-get-x-clipboard 'PRIMARY) (car circ/pass/kill-ring-pointer)))
    (kill-new ""))
  (when circ/pass/kill-ring-pointer
    (setcar circ/pass/kill-ring-pointer "")
    (setq circ/pass/kill-ring-pointer nil)
    (message "%s in clipboard cleared" (capitalize circ/pass/clipboard-field))))

(defun circ/pass/copy-entry-field (entry field)
  (circ/pass/clear-clipboard)
  (kill-new (circ/pass/get-value entry field))
  (setq circ/pass/kill-ring-pointer kill-ring-yank-pointer)
  (setq circ/pass/clipboard-timeout-job
        (run-at-time circ/pass/clipboard-timeout nil
                     'circ/pass/clear-clipboard))
  (setq circ/pass/clipboard-field field)
  (message "Copied %s for %s. Will clear in %s seconds"
           field entry circ/pass/clipboard-timeout))

(defun circ/pass/copy-password (&optional entry)
  (interactive)
  (unless entry (setq entry (completing-read "Pass entry: "
                                             (circ/pass/get-entries))))
  (circ/pass/copy-entry-field entry "password"))

(defun circ/pass/copy-user (&optional entry)
  (interactive)
  (unless entry (setq entry (completing-read "Pass entry: "
                                             (circ/pass/get-entries))))
  (circ/pass/copy-entry-field entry "user"))

(defun circ/pass/generate-entry (&optional entry)
  (interactive)
  (unless entry (setq entry (read-string "Entry name: ")))
  (let ((flags ""))
    (when (file-exists-p (circ/pass/get-entry-path entry))
      (unless (y-or-n-p (format "%s already exists. Insert new password? " entry))
        (error "Generate aborted"))
      (setq flags (concat flags " -i")))
    (unless (file-directory-p (file-name-directory (circ/pass/get-entry-path entry)))
      (make-directory (file-name-directory (circ/pass/get-entry-path entry)) t))
    (unless (y-or-n-p "Use symbols? ")
      (setq flags (concat flags " -n")))
    (shell-command (format "pass generate %s %s > /dev/null" flags entry)))
  (when (y-or-n-p (format "Copy entry %s password?" entry))
    (circ/pass/copy-password entry))
  (when (y-or-n-p (format "Open entry %s?" entry))
    (circ/pass/open-entry entry)))


(defun circ/pass/cache-passphrase ()
  (interactive)
  (circ/pass/get-value "access" "value"))
#+end_src
** balance-window fix
Balance window doesn't work when you have a side window with a fixed size.

This is due to a calculation bug in the =windows.el= code.

#+begin_src emacs-lisp
(defun circ/balance-windows-2 (window horizontal)
  "Subroutine of `balance-windows-1'.
WINDOW must be a vertical combination (horizontal if HORIZONTAL
is non-nil)."
  (let* ((char-size (if window-resize-pixelwise
			1
		      (frame-char-size window horizontal)))
	 (first (window-child window))
	 (sub first)
	 (number-of-children 0)
     (ignore-window-count 0)
	 (parent-size (window-new-pixel window))
	 (total-sum parent-size)
	 failed size sub-total sub-delta sub-amount rest)
    (while sub
      (setq number-of-children (1+ number-of-children))
      (when (window-size-fixed-p sub horizontal)
	(setq total-sum
	      (- total-sum (window-size sub horizontal t)))
    (setq ignore-window-count (1+ ignore-window-count))
	(set-window-new-normal sub 'ignore))
      (setq sub (window-right sub)))

    (setq failed t)
    (while (and failed (> number-of-children 0))
      (setq size (/ total-sum (- number-of-children ignore-window-count)))
      (setq failed nil)
      (setq sub first)
      (while (and sub (not failed))
	;; Ignore child windows that should be ignored or are stuck.
	(unless (window--resize-child-windows-skip-p sub)
	  (setq sub-total (window-size sub horizontal t))
	  (setq sub-delta (- size sub-total))
	  (setq sub-amount
		(window-sizable sub sub-delta horizontal nil t))
	  ;; Register the new total size for this child window.
	  (set-window-new-pixel sub (+ sub-total sub-amount))
	  (unless (= sub-amount sub-delta)
	    (setq total-sum (- total-sum sub-total sub-amount))
	    (setq number-of-children (1- number-of-children))
	    ;; We failed and need a new round.
	    (setq failed t)
	    (set-window-new-normal sub 'skip)))
	(setq sub (window-right sub))))

    ;; How can we be sure that `number-of-children' is NOT zero here ?
    (setq rest (% total-sum number-of-children))
    ;; Fix rounding by trying to enlarge non-stuck windows by one line
    ;; (column) until `rest' is zero.
    (setq sub first)
    (while (and sub (> rest 0))
      (unless (window--resize-child-windows-skip-p window)
	(set-window-new-pixel sub (min rest char-size) t)
	(setq rest (- rest char-size)))
      (setq sub (window-right sub)))

    ;; Fix rounding by trying to enlarge stuck windows by one line
    ;; (column) until `rest' equals zero.
    (setq sub first)
    (while (and sub (> rest 0))
      (unless (eq (window-new-normal sub) 'ignore)
	(set-window-new-pixel sub (min rest char-size) t)
	(setq rest (- rest char-size)))
      (setq sub (window-right sub)))

    (setq sub first)
    (while sub
      ;; Record new normal sizes.
      (set-window-new-normal
       sub (/ (if (eq (window-new-normal sub) 'ignore)
		  (window-size sub horizontal t)
		(window-new-pixel sub))
	      (float parent-size)))
      ;; Recursively balance each window's child windows.
      (balance-windows-1 sub horizontal)
      (setq sub (window-right sub)))))

(advice-add 'balance-windows-2 :override
            #'circ/balance-windows-2)
#+end_src
** Fixed window sizes
I want certain windows to have fixed width because they open in a side window.
#+begin_src emacs-lisp
(defun circ/set-fixed-window-size-width ()
  "Set the buffer to not allow window width changes"
  (interactive)
  (setq window-size-fixed 'width))

(add-hook 'help-mode-hook 'circ/set-fixed-window-size-width)
#+end_src
** Open in openscad
#+begin_src emacs-lisp
(defun circ/open-in-openscad ()
  (interactive)
  (start-process "openscad" nil "openscad" buffer-file-name))
#+end_src
** Org toggle pinned
#+begin_src emacs-lisp
(defun circ/org-toggle-pinned-property ()
  (interactive)
  (save-excursion
    (org-back-to-heading)
    (if (org-entry-get nil "Pinned")
        (progn
          (org-delete-property "Pinned")
          (org-toggle-tag "PINNED" 'off)
          (message "Entry unpinned"))
      (progn
        (org-entry-put nil "Pinned" "t")
        (org-toggle-tag "PINNED" 'on)
        (message "Entry pinned")))))

;; Code taken from `org-agenda-set-propert' which navigates to the headline and
;; calls some function.
(defun circ/org-agenda-toggle-pinned-property ()
  "Toggles the pin property on the current headline."
  (interactive)
  (org-agenda-check-no-diary)
  (org-agenda-maybe-loop
   #'org-agenda-set-property nil nil nil
   (let* ((hdmarker (or (org-get-at-bol 'org-hd-marker)
                        (org-agenda-error)))
          (buffer (marker-buffer hdmarker))
          (pos (marker-position hdmarker))
          (inhibit-read-only t)
          newhead)
     (org-with-remote-undo buffer
       (with-current-buffer buffer
         (widen)
         (goto-char pos)
         (org-show-context 'agenda)
         (circ/org-toggle-pinned-property))))))
#+end_src
** Split window functions
#+begin_src emacs-lisp
(defun circ/split-window-right ()
  (interactive)
  (let ((win (split-window-right)))
    (previous-buffer)
    (select-window win)))

(defun circ/split-window-below ()
  (interactive)
  (let ((win (split-window-below)))
    (previous-buffer)
    (select-window win)))
#+end_src
** Maximise windows
#+begin_src emacs-lisp
(defun circ/maximise-window-vertical (&optional window)
  (interactive)
  (setq window (window-normalize-window window))
  (window-resize
   window (window-max-delta window nil nil nil nil nil window-resize-pixelwise)
   nil nil window-resize-pixelwise))

(defun circ/maximise-window-horizontal (&optional window)
  (interactive)
  (setq window (window-normalize-window window))
  (window-resize
   window (window-max-delta window t nil nil nil nil window-resize-pixelwise)
   t nil window-resize-pixelwise))
#+end_src
** Minimize windows
#+begin_src emacs-lisp
(defun circ/minimise-window-vertical (&optional window)
  (interactive)
  (setq window (window-normalize-window window))
  (window-resize
   window
   (- (window-min-delta window nil nil nil nil nil window-resize-pixelwise))
   nil nil window-resize-pixelwise))

(defun circ/minimise-window-horizontal (&optional window)
  (interactive)
  (setq window (window-normalize-window window))
  (window-resize
   window
   (- (window-min-delta window t nil nil nil nil window-resize-pixelwise))
   t nil window-resize-pixelwise))
#+end_src
** Org goto today
When in task view, jump to todos. Else perform normal action.
#+begin_src emacs-lisp
(defun circ/org-agenda-goto-todo ()
  (goto-char (point-min))
  (search-forward-regexp "==*\nTodo")
  (move-beginning-of-line 1))

(defun circ/org-agenda-goto-today-custom ()
  (beginning-of-buffer)
  (org-agenda-update-agenda-type)
  (org-agenda-goto-today))

(defun circ/org-agenda-goto-today ()
  "In PIMs task view, go to the Todo list. Else, do `org-agenda-goto-today'"
  (interactive)
  (cond ((string= (buffer-name) "*Org Agenda(T)*")
         (circ/org-agenda-goto-todo))
        ((string= (buffer-name) "*Org Agenda(A)*")
         (circ/org-agenda-goto-today-custom))
        (t
         (org-agenda-goto-today))))
#+end_src
** Snippets
#+begin_src emacs-lisp
(defvar circ/snippets nil)

(defun circ/snippet-find-options (snippet)
  (let ((placeholder-options nil))
    (with-temp-buffer
      (insert snippet)
      (goto-char (point-min))
      ;; There are MULTIPLE places this regexp is!
      (while (search-forward-regexp "{{[0-9]+\\(:[a-zA-Z0-9\-_ !]+\\)*}}" nil t)
        (setq placeholder-options (cons (match-string 0) placeholder-options))))
    ;; Sort the place holder options and remove the {{0}} point option if it
    ;; exists
    ;; Firstly, reverse the sorting so it reflects the order found in the
    ;; snippet template
    (setq placeholder-options (reverse placeholder-options))
    (setq placeholder-options (circ/sort-snippets placeholder-options))
    (when (string= (car placeholder-options) "{{0}}")
      (setq placeholder-options (cdr placeholder-options)))
    placeholder-options))

(defun circ/snippet-find-snippet-mode (snippet-symbol mode)
  (cdr (assoc snippet-symbol (cdr (assoc mode circ/snippets)))))

(defun circ/snippet-find-snippet (snippet-symbol)
  (or (circ/snippet-find-snippet-mode snippet-symbol major-mode)
      (circ/snippet-find-snippet-mode snippet-symbol 'all)))

(defun circ/snippet-select ()
  (interactive)
  (let ((candidates nil)
        (selected-option nil)
        (selected-mode nil)
        (selected-symbol nil))
    (dolist (mode circ/snippets)
      (dolist (symbol (cdr mode))
        (setq candidates (cons (format "%s/%s" (car mode) (car symbol))
                               candidates))))
    (setq selected-option (split-string (completing-read "Snippet: " candidates) "/"))
    (setq selected-mode (car selected-option))
    (setq selected-symbol (cadr selected-option))
    (circ/snippet-insert-and-fill
     (circ/snippet-find-snippet-mode selected-symbol (intern selected-mode)))))

(defun circ/snippet-expand ()
  (interactive)
  (let ((snippet-symbol nil)
        (snippet "")
        (end-point (+ (point) (if (eq evil-state 'normal) 1 0)))
        (start-point nil)
        (placeholder-options nil))
    ;; Find and delete the snippet symbol
    (save-excursion
      (goto-char end-point)
      (search-backward-regexp "<\\([A-Za-z0-9 \-_]*\\)")
      (setq snippet-symbol (match-string 1))
      (setq snippet (circ/snippet-find-snippet snippet-symbol))
      (unless snippet (user-error "No snippet found for %s" snippet-symbol)))
    ;; Set the starting point of the buffer that the snippet will be inserted to
    (setq start-point (match-beginning 0))

    ;; Insert the snippet as a place holder for preview
    (delete-region start-point end-point)

    (circ/snippet-insert-and-fill snippet)))

(defun circ/snippet-insert-and-fill (snippet)
  (let ((end-point)
        (start-point (point)))
    (insert snippet)

    ;; Get the end point of the snippet, so we can continually replace it.
    (setq end-point (+ start-point (length snippet)))

    ;; Gather a starting list of options
    (setq placeholder-options (circ/snippet-find-options snippet))

    ;; Go through each option and prompt for replacement
    (while placeholder-options
      (let* ((current-placeholder (car placeholder-options))
             (options-list (circ/snippet-parse-placeholder current-placeholder))
             (current-index (nth 0 options-list))
             (replacement (circ/snippet-replacement-interaction options-list)))
        (with-temp-buffer
          (insert snippet)
          (goto-char (point-min))
          (while (search-forward-regexp
                  ;; There are MULTIPLE places this regexp is!
                  (format "{{\\(%s\\)\\(:[A-Za-z0-9 \-_ !]*\\)*}}" current-index)
                  nil t)
            (replace-match replacement t t nil 0))
          (setq snippet  (buffer-substring (point-min) (point-max))))

        (delete-region start-point end-point)
        (insert snippet)
        (setq end-point (+ start-point (length snippet)))
        (setq placeholder-options (circ/snippet-find-options snippet))))

    ;; Find the {{0}} marker, remove it, and set the cursor there.
    (goto-char end-point)
    (when (search-backward "{{0}}" nil t)
      (delete-region (match-beginning 0) (match-end 0))
      (goto-char (match-beginning 0)))))

(defun circ/snippet-parse-placeholder (snippet-string)
  (split-string
   (replace-regexp-in-string
    "^{{" ""
    (replace-regexp-in-string
     "}}$" ""
     snippet-string)) ":"))

(defun circ/sort-snippets (snippet-list)
  (mapcar
   'cdr
   (sort
    (mapcar (lambda (x)
              (cons (string-to-number (car (circ/snippet-parse-placeholder x))) x))
            snippet-list)
    (lambda (a b)
      (< (car a) (car b))))))

(defun circ/snippet-replacement-interaction (options)
  (let* ((index (nth 0 options))
        (name (nth 1 options))
        (prompt (format "(%s) %s: " index (cond (name name) (t "")))))
  (cond ((string= (nth 2 options) "LIST")
         (let ((ivy-sort-functions-alist nil))
           (completing-read prompt (nthcdr 3 options))))
        ((string= (nth 2 options) "DEFAULT")
         (read-string prompt (nth 3 options)))
        (t
         (read-string prompt)))))

(defvar circ/snippet-directory "~/.emacs.d/snippets")
(defun circ/snippet-load-snippets ()
  (interactive)
  (setq circ/snippets nil)
  (dolist (file (directory-files-recursively circ/snippet-directory ""))
    (let* ((clean-file-name (replace-regexp-in-string
                             (regexp-quote (concat
                                            (expand-file-name circ/snippet-directory)
                                            "/"))
                             "" file))
           (file-list (split-string clean-file-name "/"))
           (mode (intern (car file-list)))
           (snippet-symbol (replace-regexp-in-string
                            "\.txt$" "" (cadr file-list)))
           (snippet (with-temp-buffer
                      (insert-file-contents file)
                      (buffer-substring (point-min) (point-max))))
           (entry (cons snippet-symbol snippet)))
      (unless (assoc mode circ/snippets)
        (setq circ/snippets (cons (cons mode '()) circ/snippets)))
      (setf (cdr (assq mode circ/snippets))
            (cons entry (cdr (assoc mode circ/snippets)))))))

(circ/snippet-load-snippets)
#+end_src
* Local variables
** Safe Local Eval Aliases
#+BEGIN_SRC emacs-lisp
(defun circ/file-local-eval-safe-auto-revert ()
  (interactive)
  (auto-revert-mode t))
#+END_SRC
** Safe Local Eval List
#+BEGIN_SRC emacs-lisp
(add-to-list 'safe-local-eval-forms '(circ/file-local-eval-safe-auto-revert))
#+END_SRC

* Package Specific
** ediff
#+BEGIN_SRC emacs-lisp
(setq ediff-split-window-function 'split-window-horizontally)
(setq ediff-window-setup-function 'ediff-setup-windows-plain)
#+END_SRC

Restore previous window config.
#+BEGIN_SRC emacs-lisp
(defvar circ/ediff-last-window-configuration nil)

(defun circ/ediff-store-window-configuration ()
  (setq circ/ediff-last-window-configuration (current-window-configuration)))

(defun circ/ediff-restore-window-configuration ()
  (set-window-configuration circ/ediff-last-window-configuration))

(add-hook 'ediff-before-setup-hook #'circ/ediff-store-window-configuration)
(add-hook 'ediff-quit-hook #'circ/ediff-restore-window-configuration)
#+END_SRC

Expand org files when comparing
#+BEGIN_SRC emacs-lisp
(add-hook 'ediff-prepare-buffer-hook #'outline-show-all)
#+END_SRC

Colours
#+BEGIN_SRC emacs-lisp
(custom-set-faces
 '(ediff-even-diff-A ((t (:background "dim gray"))))
 '(ediff-even-diff-B ((t (:background "dim gray"))))
 '(ediff-even-diff-C ((t (:background "dim gray"))))
 '(ediff-odd-diff-A ((t (:background "dim gray"))))
 '(ediff-odd-diff-B ((t (:background "dim gray"))))
 '(ediff-odd-diff-C ((t (:background "dim gray"))))
 )
#+END_SRC
** which-key
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/which-key-3.3.1")
(require 'which-key)
(which-key-mode)
#+END_SRC

** evil
Load evil, and its dependencies in it comes with.

#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/evil-1.2.14")
(add-to-list 'load-path "~/.emacs.d/packages/evil-1.2.14/lib")
(require 'evil)
(evil-mode 1)
#+END_SRC

Rebind the ~q~ and ~quit~ commands to make more sense.

#+BEGIN_SRC emacs-lisp
(evil-ex-define-cmd "q" 'circ/kill-this-buffer) ; :q should kill the buffer rather
                                           ; than quiting emacs
(evil-ex-define-cmd "quit" 'evil-quit-all) ; :quit to quit emacs

(evil-define-command evil-save-and-kill-buffer (file &optional bang)
  "Save current buffer and close buffer.
Override for :wq"
  :repeat nil
  (interactive "<f><!>")
  (evil-write nil nil nil file bang)
  (circ/kill-this-buffer))
(evil-ex-define-cmd "wq" 'evil-save-and-kill-buffer)

;; Deal with common mistakes
(evil-ex-define-cmd "W"  'evil-write)
(evil-ex-define-cmd "Wq" 'evil-save-and-kill-buffer)
(evil-ex-define-cmd "WQ" 'evil-save-and-kill-buffer)
#+END_SRC

** evil-leader
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/evil-leader-0.4.3")
(require 'evil-leader)
(global-evil-leader-mode)
#+END_SRC

** evil-org
#+BEGIN_SRC emacs-lisp
(add-to-list
 'load-path
 "~/.emacs.d/packages/evil-org-mode-b6d652a9163d3430a9e0933a554bdbee5244bbf6")
(require 'evil-org)
(add-hook 'org-mode-hook 'evil-org-mode)
(evil-org-set-key-theme '(navigation insert textobjects additional calendar shift todo heading))
(add-hook 'org-mode-hook
          (lambda () (setq evil-auto-indent nil)))
(require 'evil-org-agenda)
(evil-org-agenda-set-keys)

;; When using emacs in a terminal, many keys do not work.
;; Fix them here
(evil-define-key 'motion org-agenda-mode-map
  (kbd "RET") 'org-agenda-switch-to
  (kbd "TAB") 'org-agenda-goto
  "." 'circ/org-agenda-goto-today)

(evil-define-key '(normal visual) evil-org-mode-map
  (kbd "TAB") 'org-cycle
  (kbd "<backtab>") 'org-shifttab)
#+END_SRC

** evil-numbers
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/evil-numbers-0.4")
(require 'evil-numbers)
#+END_SRC

** evil-quickscope
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/evil-quickscope-0.1.4")
(require 'evil-quickscope)
(global-evil-quickscope-mode 1)
#+END_SRC

** ivy / swiper / counsel
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/swiper-0.11.0")
(require 'ivy)
(require 'swiper)
(require 'counsel)
(setq ivy-use-selectable-prompt t)
(setq ivy-use-virtual-buffers t)
(setq ivy-count-format "(%d/%d) ")
(ivy-mode 1)

;; Setting up more ivy completion
(setq org-outline-path-complete-in-steps nil)
(setq org-completion-use-ido nil)

;; Remove the Shift-SPACE shortcut.
;; I keep accidentally activating it.
(define-key ivy-minibuffer-map (kbd "S-SPC") nil)
#+END_SRC

*** initial input alist
#+BEGIN_SRC emacs-lisp
;; (setq ivy-initial-inputs-alist '((counsel-package . "^+ ")
;;                                  (org-refile . "^")
;;                                  (org-agenda-refile . "^")
;;                                  (org-capture-refile . "^")
;;                                  (counsel-M-x . "^")
;;                                  (counsel-describe-function . "^")
;;                                  (counsel-describe-variable . "^")
;;                                  (counsel-org-capture . "^")
;;                                  (Man-completion-table . "^")
;;                                  (woman . "^")))

(setq ivy-initial-inputs-alist '())
#+END_SRC
** projectile
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/projectile-2.0.0")
(require 'projectile)
(projectile-mode +1)
(setq projectile-project-search-path '("~/projects/")) ; where the projects are
(setq projectile-completion-system 'ivy)
#+END_SRC

** counsel-projectile
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/counsel-projectile-0.3.0")
(require 'counsel-projectile)
(setq counsel-projectile-grep-initial-input '(ivy-thing-at-point))
                                        ; this required a fix that was taken
                                        ; from commit a07ddc8
#+END_SRC

** rainbow-delimiters
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/rainbow-delimiters-2.1.3")
(require 'rainbow-delimiters)
#+END_SRC

Set the colours to be as distinct as possible.

#+BEGIN_SRC emacs-lisp
(set-face-attribute 'rainbow-delimiters-depth-1-face nil :foreground "#e6194b")
(set-face-attribute 'rainbow-delimiters-depth-2-face nil :foreground "#3cb44b")
(set-face-attribute 'rainbow-delimiters-depth-3-face nil :foreground "#ffe119")
(set-face-attribute 'rainbow-delimiters-depth-4-face nil :foreground "#4363d8")
(set-face-attribute 'rainbow-delimiters-depth-5-face nil :foreground "#f58231")
(set-face-attribute 'rainbow-delimiters-depth-6-face nil :foreground "#911eb4")
(set-face-attribute 'rainbow-delimiters-depth-7-face nil :foreground "#42d4f4")
(set-face-attribute 'rainbow-delimiters-depth-8-face nil :foreground "#f032e6")
(set-face-attribute 'rainbow-delimiters-depth-9-face nil :foreground "#bfef45")
(set-face-attribute 'rainbow-delimiters-unmatched-face nil
                    :background "#ff0000"
                    :foreground "#ffffff")
#+END_SRC

** beacon
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/beacon-1.3.4")
(require 'beacon)
(beacon-mode 1)
#+END_SRC

** json-mode
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/json-snatcher-1.0.0")
(add-to-list 'load-path "~/.emacs.d/packages/json-reformat-0.0.6")
(add-to-list 'load-path "~/.emacs.d/packages/json-mode-1.7.0")
(require 'json-mode)
#+END_SRC

** telephone-line
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/telephone-line-0.4")
(require 'telephone-line)
#+END_SRC

Telephone line customization.

#+BEGIN_SRC emacs-lisp
(setq-default header-line-format "| %b | %I | %f")
(telephone-line-defsegment* circ/telephone-line-indicator-segment
  `(""
    mode-line-mule-info
    mode-line-modified
    mode-line-client
    mode-line-remote
    mode-line-frame-identification))
(setq telephone-line-lhs
      '((evil   . (telephone-line-evil-tag-segment))
        (accent . (telephone-line-vc-segment
                   telephone-line-erc-modified-channels-segment
                   telephone-line-process-segment))
        (nil    . (circ/telephone-line-indicator-segment))))
(setq telephone-line-rhs
      '((nil    . (telephone-line-misc-info-segment))
        (accent . (telephone-line-major-mode-segment))
        (evil   . (telephone-line-airline-position-segment))))
(telephone-line-mode 1)
#+END_SRC

** nlinum-relative
nlinum is a dependency.

Delay is kinda required or else files with loads of lines tend to lag.

#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/nlinum-1.8.1")
(require 'nlinum)

(add-to-list
 'load-path
 "~/.emacs.d/packages/nlinum-relative-5b9950c97ba79a6f0683e38b13da23f39e01031c")
(require 'nlinum-relative)
(nlinum-relative-setup-evil)
(global-nlinum-relative-mode)
(setq nlinum-relative-redisplay-delay 0.2) ; delay
(setq nlinum-relative-current-symbol "") ; e.g. "->"
                                        ; "" for display current line number
(setq nlinum-relative-offset 0)          ; 1 if you want 0, 2, 3...
#+END_SRC

I want relative numbers to display when in evil operator mode.

#+BEGIN_SRC emacs-lisp
(add-hook 'evil-operator-state-entry-hook
          (lambda () (when (bound-and-true-p nlinum-relative-mode)
                       (nlinum-relative-on))))
(add-hook 'evil-operator-state-exit-hook
          (lambda () (when (bound-and-true-p nlinum-relative-mode)
                       (nlinum-relative-off))))
#+END_SRC

** diff-hl
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/diff-hl-1.8.6")
(require 'diff-hl)
(require 'diff-hl-flydiff)
(global-diff-hl-mode)
(diff-hl-flydiff-mode) ; Don't wait for save to calcualte diff
#+END_SRC

** erlang
#+BEGIN_SRC emacs-lisp
(defvar circ/enable-erlang t)
(when circ/enable-erlang
  (setq load-path (cons  "~/.emacs.d/packages/erlang-2.8.4" load-path))
  (setq erlang-root-dir "~/erl_rel/18.3")
  (setq exec-path (cons "~/erl_rel/18.3/bin" exec-path))
  (require 'erlang-start)
  (require 'erlang-flymake))
#+END_SRC

*** Use regular indenting for single '%' comments
#+BEGIN_SRC emacs-lisp
(defun circ/erlang-comment-indent ()
  (cond ((looking-at "%%%") 0)
        ((looking-at "%%")
         (or (erlang-calculate-indent)
             (current-indentation)))
        ((looking-at "%")
         (or (erlang-calculate-indent)
             (current-indentation)))
        (t
         (save-excursion
           (skip-chars-backward " \t")
           (max (if (bolp) 0 (1+ (current-column)))
                comment-column)))))

(advice-add
   'erlang-comment-indent
   :override
   (lambda (&rest r) (circ/erlang-comment-indent))
   '((name . "erlang-comment-indent-advice")))
#+END_SRC

** term mode
*** Settings
#+begin_src emacs-lisp
(setq term-suppress-hard-newline nil)
(setq term-prompt-regexp "^[0-9][0-9]:[0-9][0-9]:[0-9][0-9] .* >")
#+end_src

*** Evil keys
#+begin_src emacs-lisp
(evil-define-key 'normal term-mode-map
  "[[" 'term-previous-prompt
  "]]" 'term-next-prompt
)
#+end_src

*** Set colours to be more readable
#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'term
  (set-face-attribute 'term-color-green   nil :foreground "#55ff55")
  (set-face-attribute 'term-color-blue    nil :foreground "#5555ff")
  (set-face-attribute 'term-color-red     nil :foreground "#ff5555")
  (set-face-attribute 'term-color-magenta nil :foreground "#ff55ff")
  (set-face-attribute 'term-color-cyan    nil :foreground "#55ffff")
  (set-face-attribute 'term-color-yellow  nil :foreground "#ffff55"))
#+END_SRC

*** Disable line number mode for term mode.
Requires this hacky double add hook thing because the
global-nlinum-relative-mode hook is run after the term-mode-hook

#+BEGIN_SRC emacs-lisp
(defun setup-term-mode ()
  "Counteract global nlinum mode"
  (add-hook 'after-change-major-mode-hook
            (lambda () (nlinum-mode 0))
            :append :local))

(add-hook 'term-mode-hook 'setup-term-mode)
#+END_SRC

*** Set normal / visual / operator mode to be line mode.
Set insert mode to be char mode.

=ignore-errors= added because this crashes term-mode from starting up.
I don't know why.

#+BEGIN_SRC emacs-lisp
(defun term-mode-normal-visual-operator-switch ()
  (when (equal major-mode 'term-mode) (ignore-errors (term-line-mode))))
(defun term-mode-insert-switch ()
  (when (equal major-mode 'term-mode) (ignore-errors (term-char-mode)) (end-of-buffer)))

(add-hook 'evil-normal-state-entry-hook 'term-mode-normal-visual-operator-switch)
(add-hook 'evil-visual-state-entry-hook 'term-mode-normal-visual-operator-switch)
(add-hook 'evil-operator-state-entry-hook 'term-mode-normal-visual-operator-switch)
(add-hook 'evil-insert-state-entry-hook 'term-mode-insert-switch)
#+END_SRC

*** Have the term buffer close automatically when the process has finished.

Source: https://oremacs.com/2015/01/01/three-ansi-term-tips/

#+BEGIN_SRC emacs-lisp
(defun auto-exit-term-exec-hook ()
  (let* ((buff (current-buffer))
         (proc (get-buffer-process buff)))
    (set-process-sentinel
     proc
     `(lambda (process event)
        (if (not (process-live-p process))
            (kill-buffer ,buff))))))

(add-hook 'term-exec-hook 'auto-exit-term-exec-hook)
#+END_SRC

** man
Open man pages in current window
#+BEGIN_SRC emacs-lisp
(require 'man)
(setq Man-notify-method 'pushy)
#+END_SRC

#+begin_src emacs-lisp
(evil-set-initial-state 'Man-mode 'normal)
(evil-define-key 'normal Man-mode-map
  "q" 'circ/kill-this-buffer
  "r" 'Man-update-manpage
  "]" 'Man-next-manpage
  "[" 'Man-previous-manpage
  "J" 'Man-next-section
  "K" 'Man-previous-section
  "m" 'man
  "gR" 'Man-follow-manual-reference
  "gs" 'Man-goto-see-also-section
  (kbd "SPC") 'scroll-up-command
  (kbd "S-SPC") 'scroll-down-command
  (kbd "<tab>") 'forward-button
  (kbd "<backtab>") 'backward-button
)
#+end_src
** mpccp
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/mpccp")
(require 'mpccp)
(setq mpccp-playlist-directory "/mnt/slave/playlists")
(add-hook 'mpccp-mode-hook 'circ/disable-evil-quickscope-mode)
#+END_SRC
** Dashboard
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/dashboard")
(require 'dashboard)
(add-to-list 'dashboard-persistent-links "file:~/.emacs.d/configuration.org")
(add-to-list 'dashboard-persistent-links "file:~/.emacs.d/settings.org")
(add-to-list 'dashboard-persistent-links "file:~/.emacs.d/personalsettings.org")
(add-to-list 'dashboard-persistent-links "file:~/pims/reference/books/read_books_list.org")
(add-to-list 'dashboard-persistent-links "url:http://duckduckgo.com")
(setq initial-buffer-choice 'dashboard)
(add-hook 'dashboard-mode-hook 'circ/disable-evil-quickscope-mode)
#+END_SRC
** eww
Evil bindings for =eww=.
#+BEGIN_SRC emacs-lisp
(evil-define-key 'normal eww-mode-map
  (kbd "H") 'eww-back-url
  (kbd "L") 'eww-forward-url
  (kbd "[") 'shr-previous-link
  (kbd "]") 'shr-next-link
  (kbd "d") 'evil-scroll-down
  (kbd "u") 'evil-scroll-up
  (kbd "o") 'eww
  (kbd "r") 'eww-reload
  (kbd "R") 'eww-readable
  (kbd "q") 'circ/kill-this-buffer
  "go" 'eww-browse-with-external-browser
  "gh" 'eww-list-histories
  "yy" 'eww-copy-page-url
)
#+END_SRC

Rename buffers to allow for more than one =eww= buffer.
#+BEGIN_SRC emacs-lisp
(defun circ/rename-eww-hook ()
  "Rename eww buffer with page title for easier buffer finding and to allow
multiple eww buffers to be open"
  (let ((current-title (plist-get eww-data :title)))
    (rename-buffer (concat "*" "eww" " " "(" current-title ")" "*" )
                   t)))
(add-hook 'eww-mode-hook #'circ/rename-eww-hook)
(add-hook 'eww-after-render-hook #'circ/rename-eww-hook)
#+END_SRC
** elfeed
*** Setup
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/elfeed-7b2b6fadaa498fef2ba212a50da4a8afa2a5d305")
(require 'elfeed)
(setq elfeed-db-directory "~/rss_elfeed/elfeed/")
(add-hook 'elfeed-search-mode-hook 'circ/disable-evil-quickscope-mode)

(setq elfeed-show-unique-buffers t)
#+END_SRC

*** elfeed-org
To read rss feed links from an org file:
 #+BEGIN_SRC emacs-lisp
 ;; Dependencies
 (add-to-list 'load-path "~/.emacs.d/packages/dash.el-2.16.0")
 (add-to-list 'load-path "~/.emacs.d/packages/s.el-43ba8b563bee3426cead0e6d4ddc09398e1a349d")

 (add-to-list 'load-path "~/.emacs.d/packages/elfeed-org-77b6bbf222487809813de260447d31c4c59902c9")
 (require 'elfeed-org)
 (elfeed-org)
 (setq rmh-elfeed-org-files (list "~/pims/rss_feeds.org"))
 #+END_SRC

*** Load and Save DB on open and close
#+BEGIN_SRC emacs-lisp
(defun circ/elfeed-load-and-open ()
  (interactive)
;  (elfeed-db-load)
  (elfeed))
(defun circ/elfeed-save-and-close ()
  (interactive)
;  (elfeed-db-save)
  (circ/kill-this-buffer))
(defun circ/elfeed-db-reload ()
  (interactive)
;  (elfeed-db-load)
  (elfeed-search-update--force))
#+END_SRC
*** Open elfeed file
#+BEGIN_SRC emacs-lisp
(defun circ/open-rss-elfeed-file ()
  (interactive)
  (find-file (car rmh-elfeed-org-files)))
#+END_SRC
*** Open in custom application
 #+BEGIN_SRC emacs-lisp
  (defun circ/eww-readable (url &rest args)
    (interactive)
    (eww url)
    (add-hook 'eww-after-render-hook 'eww-readable nil t))

  (defun circ/open-in-mpv (url &rest args)
    (message "Opening in mpv: %s" url)
    (call-process "mpv" nil 0 nil url))

  (defun circ/elfeed-show-open-in-mpv ()
    (interactive)
    (let ((browse-url-browser-function 'circ/open-in-mpv)) (elfeed-show-visit)))
  (defun circ/elfeed-show-open-eww-readable()
    (interactive)
    (let ((browse-url-browser-function 'circ/eww-readable)) (elfeed-show-visit)))
  (defun circ/elfeed-show-open-eww()
    (interactive)
    (let ((browse-url-browser-function 'eww-browse-url)) (elfeed-show-visit)))

  (defun circ/elfeed-search-open-in-mpv ()
    (interactive)
    (let ((elfeed-search-remain-on-entry t)
          (browse-url-browser-function 'circ/open-in-mpv))
      (elfeed-search-browse-url)))
  (defun circ/elfeed-search-open-eww-readable()
    (interactive)
    (let ((elfeed-search-remain-on-entry t)
          (browse-url-browser-function 'circ/eww-readable))
      (elfeed-search-browse-url)))
  (defun circ/elfeed-search-open-eww()
    (interactive)
    (let ((elfeed-search-remain-on-entry t)
          (browse-url-browser-function 'eww-browse-url))
      (elfeed-search-browse-url)))
 (defun circ/elfeed-search-browse-url ()
   (interactive)
   (let ((elfeed-search-remain-on-entry t))
     (elfeed-search-browse-url)))
#+END_SRC

*** Saved tags
#+BEGIN_SRC emacs-lisp
(defun circ/elfeed-search-tag-saved ()
  (interactive)
  (let ((elfeed-search-remain-on-entry t))
    (elfeed-search-tag-all 'saved)
    (elfeed-search-untag-all 'unread))
  (forward-line))
(defun circ/elfeed-show-tag-saved ()
  (interactive)
  (elfeed-show-tag 'saved))

;; Unused
(defun circ/elfeed-search-untag-saved ()
  (interactive)
  (elfeed-search-untag-all 'saved))
(defun circ/elfeed-show-untag-saved ()
  (interactive)
  (elfeed-show-untag 'saved))

(defun circ/elfeed-search-untag-saved-unread ()
  (interactive)
  (let ((elfeed-search-remain-on-entry t))
    (elfeed-search-untag-all 'saved)
    (elfeed-search-untag-all 'unread))
  (forward-line))
(defun circ/elfeed-show-untag-saved-unread ()
  (interactive)
  (elfeed-show-untag 'saved)
  (elfeed-show-untag 'unread))
#+END_SRC
*** Tag filtering
Completing read tag editing
#+BEGIN_SRC emacs-lisp
(defun circ/elfeed-search-filter-tag ()
  (interactive)
  (unwind-protect
      (let* ((tags (mapcar 'symbol-name (elfeed-db-get-all-tags)))
             (current-filter elfeed-search-filter)
             (current-tags (plist-get (elfeed-search-parse-filter current-filter)
                                      :must-have))
             (tag-candidates (append
                              (mapcar (lambda (tag)
                                        (concat "+" tag))
                                      tags)
                              (mapcar (lambda (tag)
                                        (concat "-" tag))
                                      tags)))
             (new-tag (completing-read (format "[%s]: " current-filter) tag-candidates nil t))
             (filter-list (split-string elfeed-search-filter " " t)))
        (if (member new-tag filter-list)
            (circ/elfeed--remove-search-filter-tag new-tag)
          (circ/elfeed--add-search-filter-tag new-tag))))
  (circ/elfeed-search-filter-tag))

(defun circ/elfeed--add-search-filter-tag (tag)
  (let ((filter-list (split-string elfeed-search-filter " " t)))
    (setq elfeed-search-filter (string-join (append filter-list (list tag)) " "))
    (elfeed-search-update :force)))

(defun circ/elfeed--remove-search-filter-tag (tag)
  (let ((filter-list (split-string elfeed-search-filter " " t)))
    (setq elfeed-search-filter (string-join (delete tag filter-list) " "))
    (elfeed-search-update :force)))
#+END_SRC

*** Saved searches
#+BEGIN_SRC emacs-lisp
(defun circ/elfeed-search-saved ()
  (interactive)
  (setq elfeed-search-filter "+saved")
  (elfeed-search-update :force))
#+END_SRC
*** Auto tagging of length of videos
#+BEGIN_SRC emacs-lisp
(defun circ/elfeed-tag-yt-length ()
  (interactive)
  (dolist (entry (elfeed-search-selected))
    (let* ((link (elfeed-entry-link entry))
           (title (elfeed-entry-title entry))
           (len (split-string
                 (circ/strip-last-newline
                  (shell-command-to-string
                   (concat "youtube-dl --get-duration "
                           "\"" link "\"")))
                 ":"))
           (rlen (cond ((= (length len) 3)
                        (* (/ (+ (+ (* (string-to-number (car len)) 60)
                                    (string-to-number (cadr len))) 10) 10) 10))
                       ((= (length len) 2)
                        (* (/ (+ (string-to-number (car len)) 10) 10) 10))
                       (t -1)))
           (tag (concat (number-to-string rlen) "mins")))
      (when (> rlen 0)
        (elfeed-tag entry (intern tag))
        (message "Tagged \"%s\" as \"%s\"" title tag))))
  (elfeed-search-update--force))
#+END_SRC

*** Setting entry faces for tags
#+begin_src emacs-lisp
(defface circ/elfeed-search-unread-title-face
  '((t :weight bold))
  "Face used in search mode for unread entry titles."
  :group 'elfeed)

(defface circ/elfeed-search-saved-face
  '((t :background "#353500"))
  "Face for saved entries"
  :group 'elfeed)

(defface circ/elfeed-search-video-face
  '((t :foreground "#99ffff"))
  "Face for video entries"
  :group 'elfeed)

;; Define faces for tagged entries. Earlier faces take priority.
(setq elfeed-search-face-alist '((unread circ/elfeed-search-unread-title-face)
                                 (video circ/elfeed-search-video-face)
                                 (saved circ/elfeed-search-saved-face)))
#+end_src

*** Toggle Sorting Order
#+begin_src emacs-lisp
(defun circ/elfeed-toggle-sort-order ()
  (interactive)
  (cond ((eq elfeed-sort-order 'descending)
         (setq elfeed-sort-order 'ascending))
        ((eq elfeed-sort-order 'ascending)
         (setq elfeed-sort-order 'descending)))
  (elfeed-search-update--force)
  (goto-char (point-min)))
#+end_src

*** Evil Keybindings
#+BEGIN_SRC emacs-lisp
(evil-set-initial-state 'elfeed-search-mode 'motion)
(evil-define-key 'motion elfeed-search-mode-map
  (kbd "RET") 'elfeed-search-show-entry
  (kbd "S-<return>") 'elfeed-search-browse-url
  "b" 'circ/elfeed-search-browse-url
  "y" 'elfeed-search-yank
  (kbd "SPC") 'scroll-up-command
  (kbd "S-SPC") 'scroll-down-command
  (kbd "TAB") 'elfeed-show-next-link
  "/" 'elfeed-search-live-filter
  "r" 'elfeed-search-update--force
  "R" 'elfeed-search-fetch
  "gR" 'circ/elfeed-db-reload
  "f" 'circ/elfeed-search-filter-tag
  "F" 'elfeed/search-clear-filter
  "o" 'nil
  "or" 'circ/elfeed-search-open-eww-readable
  "oe" 'circ/elfeed-search-open-eww
  "ov" 'circ/elfeed-search-open-in-mpv
  "ob" 'elfeed-search-browse-url
  "gf" 'circ/open-rss-elfeed-file
  "gs" 'circ/elfeed-search-saved
  "C-d" 'evil-scroll-down
  "C-u" 'evil-scroll-up
  "t" 'circ/elfeed-toggle-sort-order
  "q" 'circ/elfeed-save-and-close)

(evil-define-key '(motion visual) elfeed-search-mode-map
  "+" 'elfeed-search-tag-all
  "-" 'elfeed-search-untag-all
  "u" 'circ/elfeed-search-untag-saved-unread
  "m" 'circ/elfeed-search-tag-saved)

(evil-set-initial-state 'elfeed-show-mode 'motion)
(evil-define-key 'motion elfeed-show-mode-map
  "b" 'elfeed-show-visit
  (kbd "SPC") 'scroll-up-command
  (kbd "S-SPC") 'scroll-down-command
  (kbd "<tab>") 'elfeed-show-next-link
  (kbd "TAB") 'elfeed-show-next-link
  "/" 'elfeed-show-new-live-search
  "+" 'elfeed-show-tag
  "-" 'elfeed-show-untag
  "]]" 'elfeed-show-next
  "[[" 'elfeed-show-prev
  "J" 'elfeed-show-next
  "K" 'elfeed-show-prev
  "n" 'elfeed-show-next
  "p" 'elfeed-show-prev
  "r" 'elfeed-show-refresh
  "q" 'elfeed-kill-buffer
  "o" 'nil
  "or" 'circ/elfeed-show-open-eww-readable
  "oe" 'circ/elfeed-show-open-eww
  "ov" 'circ/elfeed-show-open-in-mpv
  "ob" 'elfeed-show-visit
  "y" 'elfeed-show-yank
  "C-d" 'evil-scroll-down
  "C-u" 'evil-scroll-up
  "m" 'circ/elfeed-show-tag-saved
  "u" 'circ/elfeed-show-untag-saved)
#+END_SRC
** emux
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/emux")
(require 'emux)
#+END_SRC
** abbrev
#+BEGIN_SRC emacs-lisp
(setq abbrev-file-name "~/pims/abbrev_defs.el")
(setq-default abbrev-mode t)

(defun circ/add-abbrev ()
  (interactive)
  (let ((num-of-words (cond ((region-active-p) (count-words-region
                                                (region-beginning)
                                                (region-end)))
                            (t 1)))
        (mode-specific (y-or-n-p "Specific to mode? ")))
    (goto-char (region-end))
    (deactivate-mark)
    (if mode-specific
        (add-mode-abbrev num-of-words)
      (add-global-abbrev num-of-words)))
  (write-abbrev-file abbrev-file-name t))

(defun circ/reload-abbrevs ()
  (interactive)
  (kill-all-abbrevs)
  (read-abbrev-file))

(defun circ/open-abbrev-file ()
  (interactive)
  (find-file abbrev-file-name))
#+END_SRC
** avy
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/avy-0.5.0")
(require 'avy)
#+END_SRC
** go-mode
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/go-mode.el-fdf46fe0e110a8e0dddb5aac4ab20a93ee9c5d88")
(autoload 'go-mode "go-mode" nil t)
(add-to-list 'auto-mode-alist '("\\.go\\'" . go-mode))
(add-hook 'before-save-hook 'gofmt-before-save)
#+END_SRC
** doc-view
#+BEGIN_SRC emacs-lisp
(evil-set-initial-state 'doc-view-mode 'motion)

(evil-define-key 'motion doc-view-mode-map
  "q" 'image-kill-buffer

  "h" 'image-backward-hscroll
  "j" 'doc-view-next-line-or-next-page
  "k" 'doc-view-previous-line-or-previous-page
  "l" 'image-forward-hscroll

  "H" 'circ/doc-view-backward-hscroll-fast
  "J" 'circ/doc-view-next-line-or-next-page-fast
  "K" 'circ/doc-view-previous-line-or-previous-page-fast
  "L" 'circ/doc-view-forward-hscroll-fast

  "]" 'doc-view-next-page
  "[" 'doc-view-previous-page

  (kbd "SPC") 'doc-view-scroll-up-or-next-page
  (kbd "S-SPC") 'doc-view-scroll-down-or-previous-page
  "gg" 'doc-view-first-page
  "G" 'doc-view-last-page
  "gp" 'doc-view-goto-page
  (kbd "RET") 'image-next-line

  ;; zoom
  "+" 'doc-view-enlarge
  "=" 'doc-view-enlarge
  "0" 'doc-view-scale-reset
  "-" 'doc-view-shrink
  "_" 'doc-view-shrink

  "zw" 'doc-view-fit-width-to-window ; Like evil-image.
  "zh" 'doc-view-fit-height-to-window ; Like evil-image.
  "zp" 'doc-view-fit-page-to-window
  "X" 'doc-view-kill-proc

  "ss" 'doc-view-set-slice
  "sm" 'doc-view-set-slice-using-mouse
  "sb" 'doc-view-set-slice-from-bounding-box
  "sr" 'doc-view-reset-slice

  "n" 'doc-view-search-next-match
  "N" 'doc-view-search-previous-match
  "/" 'circ/doc-view-search
  "?" 'circ/doc-view-search-backward
  "C-t" 'doc-view-show-tooltip
  "C-c C-c" 'doc-view-toggle-display
  "C-c C-t" 'doc-view-open-text

  ;; refresh
  "r" 'doc-view-revert-buffer)
#+END_SRC
*** Faster scroll functions
#+BEGIN_SRC emacs-lisp
(defvar circ/doc-view-scroll-fast-rate 10)
(defun circ/doc-view-backward-hscroll-fast ()
  (interactive)
  (image-backward-hscroll circ/doc-view-scroll-fast-rate))
(defun circ/doc-view-forward-hscroll-fast ()
  (interactive)
  (image-forward-hscroll circ/doc-view-scroll-fast-rate))
(defun circ/doc-view-next-line-or-next-page-fast ()
  (interactive)
  (doc-view-next-line-or-next-page circ/doc-view-scroll-fast-rate))
(defun circ/doc-view-previous-line-or-previous-page-fast ()
  (interactive)
  (doc-view-previous-line-or-previous-page circ/doc-view-scroll-fast-rate))
#+END_SRC
*** Doc view search
#+BEGIN_SRC emacs-lisp
(defun circ/doc-view-search ()
  (interactive)
  (doc-view-search t))
(defun circ/doc-view-search-backward ()
  (interactive)
  (doc-view-search-backward t))
#+END_SRC
** image-mode
#+BEGIN_SRC emacs-lisp
(evil-set-initial-state 'image-mode 'motion)

(evil-define-key 'motion image-mode-map
  "q" 'image-kill-buffer

  "h" 'image-backward-hscroll
  "l" 'image-forward-hscroll
  "j" 'image-next-line
  "k" 'image-previous-line

  "H" 'circ/image-backward-hscroll-fast
  "L" 'circ/image-forward-hscroll-fast
  "J" 'circ/image-next-line-fast
  "K" 'circ/image-previous-line-fast

  "gg" 'image-bob
  "G" 'image-eob
  "RET" 'image-toggle-animation
  "a0" 'image-reset-speed
  "ar" 'image-reverse-speed
  "F" 'image-goto-frame
  "," 'image-previous-frame ; mplayer/mpv style
  "." 'image-next-frame ; mplayer/mpv style
  "{" 'image-decrease-speed ; mplayer/mpv style
  "}" 'image-increase-speed ; mplayer/mpv style

  "zh" 'image-transform-fit-to-height
  "zw" 'image-transform-fit-to-width

  "+" 'circ/image-mode-zoom-in
  "=" 'circ/image-mode-zoom-in
  "0" 'circ/image-mode-zoom-reset
  "-" 'circ/image-mode-zoom-out
  "_" 'circ/image-mode-zoom-out

  "[[" 'image-previous-file
  "]]" 'image-next-file
  "gk" 'image-previous-file
  "gj" 'image-next-file

  "C-c C-c" 'image-toggle-display)
#+END_SRC

*** Faster scroll functions
#+BEGIN_SRC emacs-lisp
(defvar circ/image-scroll-fast-rate 10)
(defun circ/image-backward-hscroll-fast ()
  (interactive)
  (image-backward-hscroll circ/image-scroll-fast-rate))
(defun circ/image-forward-hscroll-fast ()
  (interactive)
  (image-forward-hscroll circ/image-scroll-fast-rate))
(defun circ/image-next-line-fast ()
  (interactive)
  (image-next-line circ/image-scroll-fast-rate))
(defun circ/image-previous-line-fast ()
  (interactive)
  (image-previous-line circ/image-scroll-fast-rate))
#+END_SRC

*** Zoom functions
#+BEGIN_SRC emacs-lisp
(defun circ/image-mode-zoom-reset ()
  (interactive)
  (image-transform-set-scale 1))
(defun circ/image-mode-zoom-in ()
  (interactive)
  (image-transform-set-scale (* image-transform-scale 1.1)))
(defun circ/image-mode-zoom-out ()
  (interactive)
  (image-transform-set-scale (* image-transform-scale 0.9)))
#+END_SRC
** dired
*** Set up
#+begin_src emacs-lisp
(require 'dired-x)
(setq dired-dwim-target t)
(setq dired-omit-files "^\\.?#\\|^\\.$\\|^\\.\\.$\\|^\\.")
(setq dired-listing-switches "-Gghal")
(setq dired-guess-shell-alist-user '(("\\.flac\\'" "mpv")
                                     ("\\.mp3\\'" "mpv")))
#+end_src

*** reuse directory when going up directory
#+BEGIN_SRC emacs-lisp
(defun circ/dired-up-directory ()
  (interactive)
  (find-alternate-file ".."))
#+END_SRC
*** Get directory size
#+begin_src emacs-lisp
(defun circ/dired-du-current ()
  (interactive)
  (message "Directory size: %s"
           (circ/strip-last-newline
            (shell-command-to-string
             "du -h --max-depth 0"))))

(defun circ/dired-du ()
  (interactive)
  (let ((dir (dired-get-file-for-visit)))
    (when (file-directory-p dir)
      (message "Directory size: %s"
               (circ/strip-last-newline
                (shell-command-to-string
                 (format "du -h --max-depth 0 '%s'" dir)))))))
#+end_src

*** Maybe open with external application
#+begin_src emacs-lisp
(setq circ/dired-external-app-extensions
      '("mp3" "flac"
        "mkv" "mp4" "flv" "avi" "wmv"
        "odt" "ods"))
(defun circ/dired-maybe-open-with-external-app ()
  "If file extension matches with any in
`circ/dired-external-app-extensions' then open with
`browse-url-of-dired-file' else open with `dired-find-file'"
  (interactive)
  (cond ((member (file-name-extension (dired-get-file-for-visit))
                 circ/dired-external-app-extensions)
          (browse-url-of-dired-file))
         (t
          (dired-find-file))))
(defun circ/dired-maybe-open-with-external-app-other-window ()
  "If file extension matches with any in
`circ/dired-external-app-extensions' then open with
`browse-url-of-dired-file' else open with `dired-find-file-other-window'"
  (interactive)
  (cond ((member (file-name-extension (dired-get-file-for-visit))
                 circ/dired-external-app-extensions)
          (browse-url-of-dired-file))
         (t
          (dired-find-file-other-window))))
#+end_src

*** Keybindings
#+BEGIN_SRC emacs-lisp
(evil-define-key 'normal dired-mode-map
  "q" 'circ/kill-this-buffer
  "r" 'revert-buffer

  "/" 'dired-isearch-filenames
  "gg" 'evil-goto-first-line
  "G" 'evil-goto-line

  "h" 'dired-up-directory
  "j" 'dired-next-line
  "k" 'dired-previous-line
  "l" 'dired-find-file
  "L" 'dired-find-file-other-window

  "i" 'dired-maybe-insert-subdir
  "I" 'dired-kill-subdir
  (kbd "TAB") 'dired-hide-subdir

  "o" 'circ/dired-maybe-open-with-external-app
  "O" 'circ/dired-maybe-open-with-external-app-other-window
  "W" 'browse-url-of-dired-file

  "v" 'dired-view-file

  "m" 'dired-mark
  "d" 'dired-flag-file-deletion
  "u" 'dired-unmark
  "U" 'dired-unmark-all-marks
  "t" 'dired-toggle-marks
  "x" 'dired-do-flagged-delete

  "!" 'dired-do-shell-command
  "&" 'dired-do-async-shell-command
  "=" 'ediff

  "eM" 'dired-do-chmod
  "eO" 'dired-do-chown
  "eG" 'dired-do-chgrp
  "eT" 'dired-do-touch
  "eZ" 'dired-do-compress
  "eS" 'dired-do-symlink
  "em" 'dired-do-rename
  "ec" 'dired-do-copy
  "er" 'dired-do-rename-regexp
  "et" 'dired-show-file-type
  "ed" 'circ/dired-du
  "eD" 'circ/dired-du-current

  "ad" 'dired-create-directory

  "E" 'dired-toggle-read-only
  )
(evil-set-initial-state 'wdired-mode 'normal)
(evil-define-key 'normal wdired-mode-map
  "ZQ" 'wdired-abort-changes
  "ZZ" 'wdired-finish-edit
  (kbd "<escape>") 'wdired-exit
  "q" 'wdired-exit
)
#+END_SRC

** View mode
#+begin_src emacs-lisp
(evil-define-key 'normal view-mode-map
  "q" 'View-quit)
(add-hook 'view-mode-hook 'evil-normalize-keymaps)
#+end_src
** ibuffer
#+begin_src emacs-lisp
(evil-set-initial-state 'ibuffer-mode 'normal)
(evil-define-key 'normal ibuffer-mode-map
  "q" 'circ/kill-this-buffer
  "r" 'ibuffer-update
  "R" 'ibuffer-redisplay

  "o" 'ibuffer-visit-buffer
  (kbd "RET") 'ibuffer-visit-buffer

  "m" 'ibuffer-mark-forward
  "u" 'ibuffer-unmark-forward
  "U" 'ibuffer-unmark-all-marks
  "d" 'ibuffer-mark-for-delete
  "D" 'ibuffer-do-delete

  "MM" 'ibuffer-mark-by-mode
  "Mm" 'ibuffer-mark-modified-buffers
  "Mu" 'ibuffer-mark-unsaved-buffers
  "Ms" 'ibuffer-mark-special-buffers
  "Mr" 'ibuffer-mark-read-only-buffers
  "M/" 'ibuffer-mark-dired-buffers
  "Me" 'ibuffer-mark-dissociated-buffers
  "Mh" 'ibuffer-mark-help-buffers
  "Mz" 'ibuffer-mark-compressed-file-buffers
  "Mo" 'ibuffer-mark-old-buffers

  "es" 'ibuffer-do-save
  "ex" 'ibuffer-do-shell-command-file
  "eX" 'ibuffer-do-shell-command-pipe
  "ed" 'ibuffer-do-delete

  (kbd "f RET") 'ibuffer-filter-by-mode
  "fq" 'ibuffer-filter-disable
  "fm" 'ibuffer-filter-by-used-mode
  "fM" 'ibuffer-filter-by-derived-mode
  "fn" 'ibuffer-filter-by-name
  "f*" 'ibuffer-filter-by-starred-name
  "ff" 'ibuffer-filter-by-filename
  "fb" 'ibuffer-filter-by-basename
  "f." 'ibuffer-filter-by-file-extension
  "f<" 'ibuffer-filter-by-size-lt
  "f>" 'ibuffer-filter-by-size-gt
  "fi" 'ibuffer-filter-by-modified
  "fv" 'ibuffer-filter-by-visiting-file
  "fc" 'ibuffer-filter-by-content
  "fe" 'ibuffer-filter-by-predicate

  "," 'ibuffer-toggle-sorting-mode
  "si" 'ibuffer-invert-sorting
  "sa" 'ibuffer-do-sort-by-alphabetic
  "sv" 'ibuffer-do-sort-by-recency
  "ss" 'ibuffer-do-sort-by-size
  "sf" 'ibuffer-do-sort-by-filename/process
  "sm" 'ibuffer-do-sort-by-major-mode
)
#+end_src
** image-dired
#+begin_src emacs-lisp
(evil-define-key 'normal image-dired-thumbnail-mode-map
  "q" 'circ/kill-this-buffer

  "h" 'image-dired-backward-image
  "l" 'image-dired-forward-image
  "j" 'image-dired-next-line
  "k" 'image-dired-previous-line

  (kbd "RET") 'image-dired-display-thumbnail-original-image
  "o" 'image-dired-display-thumbnail-original-image
  "[" 'image-dired-display-previous-thumbnail-original
  "]" 'image-dired-display-next-thumbnail-original
)
(evil-define-key 'normal image-dired-display-image-mode-map
  "q" 'circ/kill-this-buffer
)
(add-hook 'image-dired-display-image-mode-hook 'evil-normalize-keymaps)
#+end_src
** vc-annotate-mode
*** History for jumping around revisions
When jumping through revisions, there is no history, and therefore no way to go
back to the previous revision you were looking at. Implement this.
#+begin_src emacs-lisp
(defvar-local circ/vc-annotate-version-history '())
(defvar-local circ/vc-annotate-version-history-index 0)

(defun circ/vc-annotate ()
  "Push the current revision onto the vc-annotate history
stack. Usually I would use the hook, but using the hook doesn't
work as the `vc-annotate-parent-rev' variable isn't set properly
at the time of running the hook."
  (interactive)
  (call-interactively 'vc-annotate)
  (circ/vc-annotate-push-version-to-history))

(defun circ/vc-annotate-push-version-to-history ()
  (interactive)
  (setq circ/vc-annotate-version-history
        (cons vc-annotate-parent-rev
              (subseq circ/vc-annotate-version-history
                      circ/vc-annotate-version-history-index)))
  (setq circ/vc-annotate-version-history-index 0))

(defun circ/vc-annotate-history-back ()
  (interactive)
  (let ((history circ/vc-annotate-version-history)
        (index (1+ circ/vc-annotate-version-history-index)))
    (when (<= (length history) index)
      (error "Already at earliest history revision"))
    (vc-annotate-warp-revision (nth index history))
    (setq circ/vc-annotate-version-history history)
    (setq circ/vc-annotate-version-history-index index)))

(defun circ/vc-annotate-history-forward ()
  (interactive)
  (let ((history circ/vc-annotate-version-history)
        (index (1- circ/vc-annotate-version-history-index)))
    (when (< index 0)
      (error "Already at latest history revision"))
    (vc-annotate-warp-revision (nth index history))
    (setq circ/vc-annotate-version-history history)
    (setq circ/vc-annotate-version-history-index index)))

;; TODO: I think this should be a macro, but I don't know how macros work.
(defun circ/new-history-branch (fun)
  (let ((history circ/vc-annotate-version-history)
        (index circ/vc-annotate-version-history-index))

    (funcall fun)

    (setq circ/vc-annotate-version-history history)
    (setq circ/vc-annotate-version-history-index index)
    (circ/vc-annotate-push-version-to-history)))

(defun circ/vc-annotate-revision-previous-to-line ()
  (interactive)
  (circ/new-history-branch 'vc-annotate-revision-previous-to-line))

(defun circ/vc-annotate-revision-at-line ()
  (interactive)
  (circ/new-history-branch 'vc-annotate-revision-at-line))

(defun circ/vc-annotate-working-revision ()
  (interactive)
  (circ/new-history-branch 'vc-annotate-working-revision))
#+end_src
*** Keybindings
#+BEGIN_SRC emacs-lisp
(evil-set-initial-state 'vc-annotate-mode 'motion)
(evil-define-key 'motion vc-annotate-mode-map
  "q" 'circ/kill-this-buffer

  "a" 'circ/vc-annotate-revision-previous-to-line
  "J" 'circ/vc-annotate-revision-at-line
  "W" 'circ/vc-annotate-working-revision

  "d" 'vc-annotate-show-diff-revision-at-line
  "=" 'vc-annotate-show-diff-revision-at-line
  "D" 'vc-annotate-show-changeset-diff-revision-at-linee

  "F" 'vc-annotate-find-revision-at-line

  "gl" 'vc-annotate-show-log-revision-at-line

  (kbd "RET") 'vc-annotate-goto-line
  "o" 'vc-annotate-goto-line

  "]" 'vc-annotate-next-revision
  "[" 'vc-annotate-prev-revision

  "H" 'circ/vc-annotate-history-back
  "L" 'circ/vc-annotate-history-forward
)
(add-hook 'vc-annotate-mode-hook 'circ/disable-evil-quickscope-mode)
#+END_SRC

** Diff
#+begin_src emacs-lisp
(evil-set-initial-state 'diff-mode 'motion)
(evil-define-key 'motion diff-mode-map
  "q" 'circ/kill-this-buffer
)
#+end_src

** git log view mode
#+begin_src emacs-lisp
(evil-set-initial-state 'vc-git-log-view-mode 'motion)
(evil-define-key 'motion vc-git-log-view-mode-map
  "q" 'circ/kill-this-buffer
)
#+end_src

** proced
#+begin_src emacs-lisp
(evil-set-initial-state 'proced-mode 'motion)
(evil-define-key 'motion proced-mode-map
  "q" 'circ/kill-this-buffer
  "r" 'revert-buffer

  "m" 'proced-mark
  "M" 'proced-mark-all
  ;"u" 'proced-unmark ;; Think of a better key
  "U" 'proced-unmark-all
  "t" 'proced-toggle-marks
  "c" 'proced-mark-children
  "p" 'proced-mark-parents

  "u" 'proced-undo

  "x" 'proced-send-signal
  "n" 'proced-renice

  "O" 'proced-omit-processes

  "sO" 'proced-sort-interactive
  "sc" 'proced-sort-pcpu
  "sm" 'proced-sort-pmem
  "sp" 'proced-sort-pid
  "ss" 'proced-sort-start
  "st" 'proced-sort-time
  "su" 'proced-sort-user

  "f" 'proced-filter-interactive
  "F" 'proced-format-interactive
)
#+end_src
** Bookmarks
#+begin_src emacs-lisp
(evil-set-initial-state 'bookmark-bmenu-mode 'normal)
(evil-define-key 'normal bookmark-bmenu-mode-map
  "q" 'circ/kill-this-buffer
  "r" 'revert-buffer

  "j" 'next-line
  "k" 'previous-line

  "o" 'bookmark-bmenu-this-window
  "O" 'bookmark-bmenu-switch-other-window

  "m" 'bookmark-bmenu-mark
  "M" 'bookmark-bmenu-mark-all
  "u" 'bookmark-bmenu-unmark
  "U" 'bookmark-bmenu-unmark-all
  "d" 'bookmark-bmenu-delete
  "x" 'bookmark-bmenu-execute-deletions
  "/" 'bookmark-bmenu-search
  (kbd "DEL") 'bookmark-bmenu-backup-unmark

  "s" 'bookmark-bmenu-save
  "l" 'bookmark-bmenu-load

  "er" 'bookmark-bmenu-rename
  "eR" 'bookmark-bmenu-relocate
  "ea" 'bookmark-bmenu-show-annotation
  "eA" 'bookmark-bmenu-show-all-annotations
  "ee" 'bookmark-bmenu-edit-annotation
)
(add-hook 'bookmark-bmenu-mode-hook 'circ/disable-evil-quickscope-mode)

(evil-set-initial-state 'bookmark-edit-annotation-mode 'normal)
(evil-define-key 'normal bookmark-edit-annotation-mode-map
  "q" 'circ/bookmark-send-edited-annotation
  (kbd "<escape>") 'circ/bookmark-send-edited-annotation
  "ZQ" 'circ/kill-this-buffer
  "ZZ" 'bookmark-send-edited-annotation
)
#+end_src
*** Save annotations
#+begin_src emacs-lisp
(defun circ/bookmark-send-edited-annotation ()
  (interactive)
  (if (y-or-n-p "Save changes?")
      (bookmark-send-edited-annotation)
    (circ/kill-this-buffer)))
#+end_src
*** Annotation comment
#+begin_src emacs-lisp
(defun circ/bookmark-default-annotation-text (bookmark-name)
  (concat (format-message
           "#  Type the annotation for bookmark `%s' here.\n" bookmark-name)
          (format-message
           "#  All lines which start with a `#' will be deleted.\n")
          "#  Type [q] in normal mode when done.\n"
          "#\n"
          "#  Date:    " (current-time-string) "\n"))
(advice-add 'bookmark-default-annotation-text :override
            #'circ/bookmark-default-annotation-text)
#+end_src
** Help
#+begin_src emacs-lisp
(defun circ/disable-linum-mode ()
  "Counteract global nlinum mode"
  (add-hook 'after-change-major-mode-hook
            (lambda () (nlinum-mode 0))
            :append :local))

(add-hook 'help-mode-hook 'circ/disable-linum-mode)
#+end_src
** Undo tree
#+begin_src emacs-lisp
(setq undo-tree-visualizer-diff t)
#+end_src
** mu4e
Email

*** When
#+begin_src emacs-lisp
(defvar circ/require-mu4e nil)
(when circ/require-mu4e
#+end_src
*** Set up
#+begin_src emacs-lisp
(add-to-list 'load-path "/usr/share/emacs/site-lisp/mu4e")
(require 'mu4e)
(require 'mu4e-contrib)
(require 'org-mu4e)
#+end_src
*** Settings
#+begin_src emacs-lisp
(setq mail-user-agent 'mu4e-user-agent)

(setq mu4e-change-filenames-when-moving t)
(setq mu4e-update-interval (* 10 60)) ; 10 mins
(setq mu4e-get-mail-command "mbsync -a")
(setq mu4e-maildir "~/mail")

(setq mu4e-view-show-addresses t)
(setq mu4e-view-show-images t)
(setq mu4e-split-view 'horizontal)
; This mostly just clutters up the inbox. So turn it off
(setq mu4e-headers-include-related nil)
(setq mu4e-headers-show-threads nil)

(setq mu4e-view-html-plaintext-ratio-heuristic most-positive-fixnum)
(setq mu4e-headers-date-format "%Y-%m-%d")
(setq mu4e-headers-time-format "%H:%M:%S")
(setq mu4e-headers-fields '((:human-date . 12)
                            (:flags . 4)
                            (:from . 22)
                            (:size . 10)
                            (:subject)))

;;; Contexts in personalsettings.org
(circ/set-mu4e-contexts)

(setq message-send-mail-function 'smtpmail-send-it)
(setq mu4e-compose-context-policy 'ask)
(setq mu4e-compose-format-flowed t)
(setq mu4e-compose-signature 'circ/mu4e-compose-signature)

; On 01/05/2021 19:11, Joe Bloggs <joe.bloggs@domain.com> wrote:
(setq message-citation-line-format "On %d/%m/%Y %R, %f wrote:\n")

(setq message-citation-line-function 'message-insert-formatted-citation-line)

(defun circ/mu4e-compose-signature ()
  (format (concat "Leslie Hor\n"
                  "\n"
                  "Mobile: %s\n"
                  "Email: %s")
          (circ/pass/get-value "leslie_mobile_number" "mobilenumber")
          user-mail-address))

(defun circ/mu4e-get-my-addresses (&optional context)
  (let ((context (if context context (mu4e-context-name (mu4e-context-current)))))
    (split-string (circ/pass/get-value "leslie_email_addresses" context)
                  ";")))

(defun circ/mu4e-choose-from-address ()
  (setq user-mail-address
        (completing-read "From address: "
                         (circ/mu4e-get-my-addresses)
                         nil t nil nil
                         user-mail-address)))

(add-hook 'mu4e-compose-pre-hook 'circ/mu4e-choose-from-address)

(setq mu4e-view-actions '(("capture message" . mu4e-action-capture-message)
                          ("view as pdf" . mu4e-action-view-as-pdf)
                          ("show this thread" . mu4e-action-show-thread)
                          ("b view in browser" . mu4e-action-view-in-browser)))

;; Don't render html colours.
(setq shr-use-colors nil)
#+end_src
*** Notifications
#+begin_src emacs-lisp
;; Functions to send desktop notifications for new messages in mu4e.
(defun circ/mu4e-unread-messages ()
  (let* ((query "flag:unread AND NOT flag:trashed AND NOT maildir:/gmail/[Gmail]/Spam")
         (command (concat mu4e-mu-binary " find --format xml \"" query "\"")))
    (string-trim (shell-command-to-string command))))

(defun circ/parse-xml (xml)
  (with-temp-buffer
    (insert (circ/mu4e-unread-messages))
    (libxml-parse-xml-region (point-min) (point-max))))

(defun circ/mu4e-get-message-ids ()
  (let* ((xml (circ/parse-xml (circ/mu4e-unread-messages)))
         (messages (dom-children (dom-by-tag xml 'messages))))
    (mapcar (lambda (msg)
              (dom-text (dom-by-tag msg 'msgid)))
            messages)))

(defun circ/mu4e-get-new-messages ()
  (let* ((xml (circ/parse-xml (circ/mu4e-unread-messages)))
         (messages (dom-children (dom-by-tag xml 'messages))))
    (mapcar (lambda (msg)
              (list
               (cons 'msgid  (dom-text (dom-by-tag msg 'msgid)))
               (cons 'from (dom-text (dom-by-tag msg 'from)))
               (cons 'to (dom-text (dom-by-tag msg 'to)))
               (cons 'date (dom-text (dom-by-tag msg 'date)))
               (cons 'subject (dom-text (dom-by-tag msg 'subject)))))
            messages)))

(defvar circ/mu4e-known-messages nil
  "Used to store the ids of messages we already know about, so we
don't double notify them")

(defun circ/mu4e-store-known-messages ()
  (setq circ/mu4e-known-messages (circ/mu4e-get-message-ids)))

(defun circ/mu4e-notify-new-messages ()
  (mapcar (lambda (msg)
            (when (not (member (cdr (assoc 'msgid msg)) circ/mu4e-known-messages))
              (circ/notify
               (format "New Email @ %s\n\nFrom: %s\nTo: %s"
                       (format-time-string "%Y-%m-%d %H:%M:%S"
                                           (seconds-to-time
                                            (string-to-number
                                             (cdr (assoc 'date msg)))))
                       (cdr (assoc 'from msg))
                       (cdr (assoc 'to msg)))
               (format "\n\n%s" (cdr (assoc 'subject msg)))
               0)))
          (circ/mu4e-get-new-messages))
  (setq circ/mu4e-known-messages nil))

(add-hook 'mu4e-update-pre-hook 'circ/mu4e-store-known-messages)
(add-hook 'mu4e-index-updated-hook 'circ/mu4e-notify-new-messages)
#+end_src
*** Signature above reply:
#+begin_src emacs-lisp
(defun circ/mu4e-insert-signature ()
  (interactive)
  (cond ((stringp mu4e-compose-signature)
         (insert mu4e-compose-signature))
        ((functionp mu4e-compose-signature)
         (insert (funcall mu4e-compose-signature)))))

(defun circ/mu4e-insert-signature-before-reply ()
  "Mimics the way outlook and gmail do signatures. Which is
unfortunately the standard these days. Call this immediately on
composing a message."
  (search-forward "--text follows this line--" nil t)
  (insert "\n")
  (circ/mu4e-insert-signature)
  (insert "\n")
  (goto-char (point-min))
  (search-forward "--text follows this line--" nil t)
  (insert "\n"))

;; If you want to use this style, make sure to disable the native mu4e signature
;; insert function
;; TODO: Bug - Causes point to end up in message instead of To field
(setq mu4e-compose-signature-auto-include nil)
(add-hook 'mu4e-compose-mode-hook 'circ/mu4e-insert-signature-before-reply)

;; If you tried it, and want to disable, run these:
(setq mu4e-compose-signature-auto-include t)
(remove-hook 'mu4e-compose-mode-hook 'circ/mu4e-insert-signature-before-reply)
#+end_src
*** Evil Keybindings
#+begin_src emacs-lisp
(evil-set-initial-state 'mu4e-main-mode 'normal)
(evil-set-initial-state 'mu4e-view-mode 'normal)
(evil-set-initial-state 'mu4e-org-mode 'normal)
;; I don't know why, but if I start mu4e in normal mode, I get a bunch of
;; telephone line errors. So start in insert mode instead.
(evil-set-initial-state 'mu4e-compose-mode 'normal)
(evil-set-initial-state 'mu4e-headers-mode 'normal)
(add-hook 'mu4e-compose-mode-hook 'circ/mu4e-enable-nlinum-mode)

;; Hacky workaround for a error when global-nlinum-relative-mode is on
;; Change the global-nlinum-relative-mode to ignore mu4e-compose-mode
(define-globalized-minor-mode global-nlinum-relative-mode nlinum-relative-mode
  (lambda () (unless (or (minibufferp)
                         (eq major-mode 'mu4e-compose-mode))
               (nlinum-relative-mode))))

;; Enable the nlinum-mode for compose again.
(defun circ/mu4e-enable-nlinum-mode ()
  (nlinum-mode 1))

(evil-define-key 'normal mu4e-main-mode-map
  "q" 'mu4e-quit
  "j" 'mu4e~headers-jump-to-maildir
  "s" 'mu4e-headers-search
  "C" 'mu4e-compose-new
  "c" 'mu4e-compose-new
  "b" 'mu4e-headers-search-bookmark
  "B" 'mu4e-headers-search-bookmark-edit
  ";" 'mu4e-context-switch
  "U" 'mu4e-update-mail-and-index
  "u" 'mu4e-update-mail-and-index
  "N" 'mu4e-news
  "A" 'mu4e-about
  "H" 'mu4e-display-manual

  "f" 'smtpmail-send-queued-mail
  "m" 'mu4e~main-toggle-mail-sending-mode
  "x" 'mu4e-kill-update-mail
)

(defun circ/mu4e-mark-as-read ()
  (interactive)
  (mu4e-headers-mark-thread nil '(read)))

(evil-define-key 'normal mu4e-headers-mode-map
  "q"  'mu4e~headers-quit-buffer
  "J"  'mu4e~headers-jump-to-maildir
  "C"  'mu4e-compose-new
  "E"  'mu4e-compose-edit
  "F"  'mu4e-compose-forward
  "R"  'mu4e-compose-reply
  "cc" 'mu4e-compose-new
  "ce" 'mu4e-compose-edit
  "cf" 'mu4e-compose-forward
  "cr" 'mu4e-compose-reply
  "o"  'mu4e-headers-change-sorting
  "j"  'mu4e-headers-next
  "k"  'mu4e-headers-prev
  "gr" 'mu4e-headers-rerun-search
  "b"  'mu4e-headers-search-bookmark
  "B"  'mu4e-headers-search-bookmark-edit
  ";"  'mu4e-context-switch
  (kbd "RET") 'mu4e-headers-view-message
  "/"  'mu4e-headers-search-narrow
  "s"  'mu4e-headers-search
  "S"  'mu4e-headers-search-edit
  "x"  'mu4e-mark-execute-all
  "a"  'mu4e-headers-action
  "*"  'mu4e-headers-mark-for-something ; TODO: Don't override evil-seach-word-forward?
  "&"  'mu4e-headers-mark-custom
  "A"  'mu4e-headers-mark-for-action
  "m"  'mu4e-headers-mark-for-move
  "r"  'mu4e-headers-mark-for-refile
  "D"  'mu4e-headers-mark-for-delete
  "d"  'mu4e-headers-mark-for-trash
  "="  'mu4e-headers-mark-for-untrash
  "u"  'mu4e-headers-mark-for-unmark
  "U"  'mu4e-mark-unmark-all
  "?"  'mu4e-headers-mark-for-unread
  "!"  'mu4e-headers-mark-for-read
  "%"  'mu4e-headers-mark-pattern
  "+"  'mu4e-headers-mark-for-flag
  "-"  'mu4e-headers-mark-for-unflag
  "["  'mu4e-headers-prev-unread
  "]"  'mu4e-headers-next-unread
  "gk" 'mu4e-headers-prev-unread
  "gj" 'mu4e-headers-next-unread
  "\C-j" 'mu4e-headers-next
  "\C-k" 'mu4e-headers-prev
  "zr" 'mu4e-headers-toggle-include-related
  "zt" 'mu4e-headers-toggle-threading
  "zd" 'mu4e-headers-toggle-skip-duplicates
  "gl" 'mu4e-show-log
  "gv" 'mu4e-select-other-view
  "T"  'circ/mu4e-mark-as-read
  "M"  'mu4e-headers-mark-all
)

(defun circ/mu4e-compose-quit ()
  (interactive)
  (let ((action (completing-read "Action " '("send and exit"
                                             "save as draft and exit"
                                             "don't save and exit"))))
    (cond ((string= action "send and exit")
           (message-send-and-exit))
          ((string= action "save as draft and exit")
           (message-dont-save))
          ((string= action "don't save and exit")
           (mu4e-message-kill-buffer))
          (t
           (message "No choice selected")))))

(evil-define-key 'normal mu4e-compose-mode-map
  "gg" 'mu4e-compose-goto-top
  "G"  'mu4e-compose-goto-bottom
)

(evil-define-key 'normal mu4e-view-mode-map
  " "  'mu4e-view-scroll-up-or-next
  [tab] 'shr-next-link
  [backtab] 'shr-previous-link
  "q"  'mu4e~view-quit-buffer
  "gx" 'mu4e-view-go-to-url
  "gX" 'mu4e-view-fetch-url
  "C"  'mu4e-compose-new
  "H"  'mu4e-view-toggle-html
  ;; "E"               mu4e-compose-edit
  ;; "F"               mu4e-compose-forward
  "R"  'mu4e-compose-reply
  "cc" 'mu4e-compose-new
  "ce" 'mu4e-compose-edit
  "cf" 'mu4e-compose-forward
  "cr" 'mu4e-compose-reply
  "p"  'mu4e-view-save-attachment
  "P"  'mu4e-view-save-attachment-multi ; Since mu4e 1.0, -multi is same as normal.
  "O"  'mu4e-headers-change-sorting
  "o"  'mu4e-view-open-attachment
  "A"  'mu4e-view-attachment-action
  "a"  'mu4e-view-action
  "J"  'mu4e~headers-jump-to-maildir
  "[[" 'mu4e-view-headers-prev-unread
  "]]" 'mu4e-view-headers-next-unread
  "gk" 'mu4e-view-headers-prev-unread
  "gj" 'mu4e-view-headers-next-unread
  "\C-j" 'mu4e-view-headers-next
  "\C-k" 'mu4e-view-headers-prev
  "x"  'mu4e-view-marked-execute
  "&"  'mu4e-view-mark-custom
  "*"  'mu4e-view-mark-for-something   ; TODO: Don't override "*".
  "m"  'mu4e-view-mark-for-move
  "r"  'mu4e-view-mark-for-refile
  "D"  'mu4e-view-mark-for-delete
  "d"  'mu4e-view-mark-for-trash
  "="  'mu4e-view-mark-for-untrash
  "u"  'mu4e-view-unmark
  "U"  'mu4e-view-unmark-all
  "?"  'mu4e-view-mark-for-unread
  "!"  'mu4e-view-mark-for-read
  "%"  'mu4e-view-mark-pattern
  "+"  'mu4e-view-mark-for-flag
  "-"  'mu4e-view-mark-for-unflag
  "zr" 'mu4e-headers-toggle-include-related
  "zt" 'mu4e-headers-toggle-threading
  "za" 'mu4e-view-toggle-hide-cited
  "gl" 'mu4e-show-log
  "s"  'mu4e-view-search-edit
  "|"  'mu4e-view-pipe
  "."  'mu4e-view-raw-message
  (kbd "C--") 'mu4e-headers-split-view-shrink
  (kbd "C-+") 'mu4e-headers-split-view-grow
  "T" 'circ/mu4e-mark-as-read
  (kbd "<home>") 'move-beginning-of-line
  (kbd "<end>") 'move-end-of-line
)
#+end_src
*** When
#+begin_src emacs-lisp
)
#+end_src
** rcirc
*** Set up
#+begin_src emacs-lisp
(require 'rcirc)

;; rcirc-default-nick in personalsettings.org
(setq rcirc-default-full-name "unknown")
(setq rcirc-omit-responses '("JOIN" "PART" "QUIT" "NICK"))
(setq rcirc-fill-column 80)
;; If a user has been active within X messages, don't omit messages from them
(setq rcirc-omit-threshold 100)
;; rcirc-omit-mode is buffer local

;; rcirc-server-alist in personalsettings.org

;; Users to highlight / dim/ ignore
;; rcirc-bright-nicks
;; rcirc-dim-nicks
;; rcirc-ignore-list
;; In personalsettings.org

(add-hook 'rcirc-mode-hook 'circ/disable-linum-mode)
#+end_src
*** Connection functions
#+begin_src emacs-lisp
;; Connection functions in personalsettings.org
#+end_src
*** Colourise nicks
#+begin_src emacs-lisp
;; Colour the nicks
(setq circ/rcirc-colours-list
  '("#404040" "#404080" "#4040C0" "#4040FF" "#408040" "#408080" "#4080C0" "#4080FF"
    "#40C040" "#40C080" "#40C0C0" "#40C0FF" "#40FF40" "#40FF80" "#40FFC0" "#40FFFF"
    "#804040" "#804080" "#8040C0" "#8040FF" "#808040" "#808080" "#8080C0" "#8080FF"
    "#80C040" "#80C080" "#80C0C0" "#80C0FF" "#80FF40" "#80FF80" "#80FFC0" "#80FFFF"
    "#C04040" "#C04080" "#C040C0" "#C040FF" "#C08040" "#C08080" "#C080C0" "#C080FF"
    "#C0C040" "#C0C080" "#C0C0C0" "#C0C0FF" "#C0FF40" "#C0FF80" "#C0FFC0" "#C0FFFF"
    "#FF4040" "#FF4080" "#FF40C0" "#FF40FF" "#FF8040" "#FF8080" "#FF80C0" "#FF80FF"
    "#FFC040" "#FFC080" "#FFC0C0" "#FFC0FF" "#FFFF40" "#FFFF80" "#FFFFC0" "#FFFFFF"))

(defun circ/rcirc-get-colour-for-nick (nick)
  "Given a nick string, use md5 to pick and return a colour from
`circ/rcirc-colours-list'"
  (nth
   (mod (string-to-number
         (substring (md5 (downcase nick)) 0 6) 16)
        (length circ/rcirc-colours-list))
   circ/rcirc-colours-list))

(defun circ/rcirc-colour-nicks (sender response)
  "rcirc markup function to set a colour for the nick of the
message sender, based on `circ/rcirc-colours-list'"
  (save-excursion
    (goto-char (point-min))
    (re-search-forward "<\\([^>]*\\)>" nil t)
    (let ((nick (match-string 1)))
      (when nick
        (rcirc-add-face (match-beginning 1) (match-end 1)
                        (cons 'foreground-color (circ/rcirc-get-colour-for-nick nick)))))))
(add-to-list 'rcirc-markup-text-functions 'circ/rcirc-colour-nicks)
#+end_src
*** Line up usernames
#+begin_src emacs-lisp
;; Line up usernames
(defvar circ/rcirc-nick-length 15
  "Length to pad nicks in rcirc. Set to 0 to disable")
(defun circ/rcirc-pad-nick (nick)
  "Pad the nick string with spaces so it is at least
`circ/rcirc-nick-lenght' long"
  (cond ((< (length nick) circ/rcirc-nick-length)
         (concat (make-string (- circ/rcirc-nick-length (length nick)) ?\s)
                 nick))
        (t nick)))

(defun circ/rcirc-align-nicks (sender response)
  "rcirc markup function to align nicks so that the messages
appear lined up. Similar to ERC's center option"
  (save-excursion
    (goto-char (point-min))
    (re-search-forward "\\(<[^>]*>\\)" nil t)
    (let ((nick (match-string 1)))
      (when nick
        (replace-match (circ/rcirc-pad-nick nick) t t)))))
(add-to-list 'rcirc-markup-text-functions 'circ/rcirc-align-nicks)
#+end_src
*** Authentication
#+begin_src emacs-lisp
;; Auth without keeping password in config or memory
;; Auth functions in personalsettings.org
(advice-add 'rcirc-authenticate :before 'circ/rcirc-set-authinfo)
(advice-add 'rcirc-authenticate :after 'circ/rcirc-clear-authinfo)
#+end_src
*** Omit based on channel
#+begin_src emacs-lisp
;; Auto omit on certain server channels
(defvar circ/rcirc-channels-auto-omit '())
;; circ/rcirc-channels-auto-omit in personal-settings.org

(defun circ/rcirc-server-channel-in-list-p (list)
  (let* ((server (process-name (rcirc-buffer-process)))
         (channel rcirc-target)
         (omit-channels (cdr (assoc server list))))
    (when (and server channel)
      (member channel omit-channels))))

(defun circ/rcirc-channel-auto-omit ()
  "Checks the current server and channel, and enables
`rcirc-omit-mode' if the server and channel are in
`circ/rcirc-channels-auto-omit'"
  (interactive)
  (message "Checking omit mode")
  ;; TODO: Bug. Sometimes the `rcirc-target' is not set when this function is run
  ;; I don't know why.
  (unless rcirc-target
    (message "No channel in rcirc-target: %s" rcirc-target))
  (when (and (rcirc-buffer-process)
             rcirc-target
             (circ/rcirc-server-channel-in-list-p circ/rcirc-channels-auto-omit))
    (message "Enabling omit-mode for %s" rcirc-target)
    (rcirc-omit-mode 1)))
(add-hook 'rcirc-mode-hook 'circ/rcirc-channel-auto-omit)

;; Used to determine if the message is worth tracking.
;; Omitted messages shouldn't trigger tracking.
(defun circ/rcirc-omit-message-p (process sender response target)
  "Check if the message should be omitted based on the server,
channel, and message type"
  (when rcirc-omit-mode
    (let ((last-activity-lines (rcirc-elapsed-lines process sender target)))
      (and (not (string= (rcirc-nick process) sender))
           (member response rcirc-omit-responses)
           (or (not last-activity-lines)
               (< rcirc-omit-threshold last-activity-lines))))))
#+end_src
*** Tracking
#+begin_src emacs-lisp
;; Tracking
(rcirc-track-minor-mode 0)
(defvar circ/rcirc-channels-no-track '())
;; circ/rcirc-channels-no-track set in personalsettings.org

;; Set tracking name to full channel name
(defun circ/rcirc-set-short-buffer-name ()
  "Set the current buffers name to the channel"
  (interactive)
  (setq rcirc-short-buffer-name rcirc-target))
(defun circ/rcirc-set-all-short-buffer-names ()
  "Set all rcirc buffer names to the full channel name"
  (let ((bufalist
         (apply 'append (mapcar (lambda (process)
                                  (with-rcirc-process-buffer process
                                    rcirc-buffer-alist))
                                (rcirc-process-list)))))
    (dolist (i bufalist)
      (when (buffer-live-p (cdr i))
	(with-current-buffer (cdr i)
	  (setq rcirc-short-buffer-name (car i)))))))
(advice-add 'rcirc-update-short-buffer-names :after 'circ/rcirc-set-all-short-buffer-names)

(defun circ/update-rcirc-tracking (process sender response target text)
  "On a new message, check if the window is selected. If not, and
if the message is NOT ommitted, add it to the
tracking (`rcirc-activity') variable."
  (unless (or (circ/rcirc-omit-message-p process sender response target)
              (circ/rcirc-server-channel-in-list-p circ/rcirc-channels-no-track))
    (let ((server (process-name process))
          (channel target)
          (window-in-view (eq (selected-window) (get-buffer-window nil t))))
      (when (and (not window-in-view)
                 (bufferp (rcirc-get-buffer process target))
                 server channel)
        (add-to-list 'rcirc-activity (rcirc-get-buffer process target)))
      (when window-in-view
        (setq rcirc-activity
              (delete (rcirc-get-buffer process target) rcirc-activity)))
      (rcirc-update-activity-string))))
(add-hook 'rcirc-print-functions 'circ/update-rcirc-tracking)

(defun circ/rcirc-clear-buffer-tracking ()
  "Clears the current buffer from `rcirc-activity' tracking
variable and clears the unread line from the buffer"
  (interactive)
  (when (equal major-mode 'rcirc-mode)
    ;; (setq rcirc-activity
    ;;       (delete (rcirc-get-buffer (rcirc-buffer-process) rcirc-target) rcirc-activity)))
    (setq rcirc-activity
          (delete (get-buffer (buffer-name)) rcirc-activity)))
  (rcirc-update-activity-string)
  (circ/rcirc-clear-unread-line))

(defun circ/rcirc-get-all-rcirc-buffers ()
  (let (rcirc-buffers)
    (dolist (buffer (buffer-list))
      (with-current-buffer buffer
          (when (eq major-mode 'rcirc-mode)
            (setq rcirc-buffers (cons buffer rcirc-buffers)))))
    rcirc-buffers))

(defun circ/rcirc-clear-all-buffer-tracking ()
  "Go through all rcirc buffers and clear all their tracking"
  (interactive)
  (dolist (buffer (circ/rcirc-get-all-rcirc-buffers))
    (with-current-buffer buffer
      (circ/rcirc-clear-buffer-tracking))
  (rcirc-update-activity-string)))

(setq global-mode-string (append global-mode-string '(rcirc-activity-string)))
#+end_src
*** Unread line marker
#+begin_src emacs-lisp
(defvar-local circ/rcirc-unread-line-p nil
  "Variable to keep track of if the unread line was added")
(defun circ/rcirc-add-unread-line (sender response)
  "rcirc markup function that adds a red line before a new message if the window
is not selected and the message is a message is one that is not omitted. Only do
this once. Keep tracking using `circ/rcirc-unread-line-p'"
  ;; If you are in omit mode and the message is one of the omitted messages, skip
  (unless (circ/rcirc-omit-message-p (rcirc-buffer-process) sender response rcirc-target)
    (save-excursion
      ;; When window is NOT in view
      (unless (or (eq (selected-window) (get-buffer-window nil t))
                  circ/rcirc-unread-line-p)
        (let ((string (concat (make-string rcirc-fill-column ?-) "\n")))
          (goto-char (point-min))
          (insert string)
          (goto-char (point-min))
          (search-forward string)
          (rcirc-add-face (match-beginning 0) (match-end 0)
                          (cons 'foreground-color "red"))
          (setq circ/rcirc-unread-line-p t))))))
(add-to-list 'rcirc-markup-text-functions 'circ/rcirc-add-unread-line)

(defun circ/rcirc-clear-unread-line ()
  "Remove the red unread line and unsets `circ/rcirc-unread-line-p'"
  (interactive)
  (save-excursion
    (let ((inhibit-read-only t)
          (string (concat (make-string rcirc-fill-column ?-) "\n")))
      (when (search-backward string nil t)
        (replace-match "" nil nil nil 0))))
  (setq circ/rcirc-unread-line-p nil))
#+end_src
*** Highlight and dim user messages
#+begin_src emacs-lisp
(defun circ/rcirc-highlight-bright-nick-message (sender response)
  "rcirc markup function to highlight the entire message for nicks that have
bright enabled."
  (when (member sender rcirc-bright-nicks)
    (save-excursion
      (goto-char (point-min))
      (re-search-forward "<[^>]*> \\(.*\\)" nil t)
      (rcirc-add-face (match-beginning 1) (match-end 1)
                      (cons 'foreground-color "Aquamarine")))))
(add-to-list 'rcirc-markup-text-functions 'circ/rcirc-highlight-bright-nick-message)

(defun circ/rcirc-highlight-dim-nick-message (sender response)
  "rcirc markup function to dim the entire message for nicks that have
dim enabled."
  (when (member sender rcirc-dim-nicks)
    (save-excursion
      (goto-char (point-min))
      (re-search-forward "<[^>]*> \\(.*\\)" nil t)
      (rcirc-add-face (match-beginning 1) (match-end 1)
                      (cons 'foreground-color "#555555")))))
(add-to-list 'rcirc-markup-text-functions 'circ/rcirc-highlight-dim-nick-message)
#+end_src
*** Open urls
#+begin_src emacs-lisp
(defun circ/rcirc-open-url ()
  (interactive)
  (let (urls
        ;; Disable ivy default sorting
        (ivy-sort-functions-alist nil))
    (save-excursion
      (goto-char (point-min))
      (while (re-search-forward rcirc-url-regexp nil t)
        (setq urls (cons (match-string-no-properties 0) urls))))
    (browse-url (completing-read "Select URL: " urls))))
#+end_src
*** Count users in channel
#+begin_src emacs-lisp
(defun circ/rcirc-show-user-count ()
  (interactive)
  (when (and rcirc-target (rcirc-buffer-process)
             (message "User count in %s: %s" rcirc-target
                      (length (rcirc-channel-nicks (rcirc-buffer-process) rcirc-target))))))
#+end_src
*** Evil
#+begin_src emacs-lisp
(evil-set-initial-state 'rcirc-mode 'normal)

(evil-define-key 'normal rcirc-mode-map
  "gr" 'circ/rcirc-clear-buffer-tracking
  "gR" 'circ/rcirc-clear-all-buffer-tracking
  "gc" 'circ/rcirc-clear-all-buffer-tracking
  "f" 'circ/rcirc-open-url
  )
#+end_src
** elpher
*** Set up
#+begin_src emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/elpher-20200919.1025")
(require 'elpher)
#+end_src

*** Evil keybindings
#+begin_src emacs-lisp
(evil-define-key 'motion elpher-mode-map
  "q" 'circ/kill-this-buffer
  "H" 'elpher-back
  "f" 'elpher-jump
  "o" 'elpher-go
  "O" 'elpher-go-current
  "]" 'elpher-next-link
  "[" 'elpher-prev-link
  "n" 'elpher-next-link
  "p" 'elpher-prev-link
)

(add-hook 'elpher-mode-hook 'circ/disable-evil-quickscope-mode)
#+end_src
** vc-diff
*** Evil Bindings
#+begin_src emacs-lisp
(evil-set-initial-state 'vc-dir-mode 'motion)
(evil-define-key 'motion vc-dir-mode-map
  "q" 'circ/kill-this-buffer
  "r" 'revert-buffer

  "c" 'vc-next-action
  "d" 'vc-diff
  "D" 'vc-root-diff

  "s" 'circ-git/add ;; add new file

  "m" 'vc-dir-mark
  "M" 'vc-dir-mark-all-files
  "u" 'vc-dir-unmark
  "U" 'vc-dir-unmark-all-files
)
#+end_src
** Magit
*** Set up
#+begin_src emacs-lisp
;; Dependencies
(add-to-list 'load-path "~/.emacs.d/packages/dash.el-2.16.0") ;; Already used for elfeed
(add-to-list 'load-path "~/.emacs.d/packages/ghub-3.5.1")
(add-to-list 'load-path "~/.emacs.d/packages/graphql.el-0.1.1")
(add-to-list 'load-path "~/.emacs.d/packages/magit-popup-2.13.3")
(add-to-list 'load-path "~/.emacs.d/packages/treepy.el-0.1.2")
(add-to-list 'load-path "~/.emacs.d/packages/with-editor-3.0.4")


(add-to-list 'load-path "~/.emacs.d/packages/magit-2.90.1/lisp")
(require 'magit)

(with-eval-after-load 'info
  (info-initialize)
  (add-to-list 'Info-directory-list
                "~/.emacs.d/packages/magit-2.90.1/Documentation/"))
#+end_src
*** Display mode
#+begin_src emacs-lisp
;; Display the magit buffer in the current window, unless it is a diff
(setq magit-display-buffer-function 'magit-display-buffer-same-window-except-diff-v1)

;; Quit the magit window and do not restore the previous window config
(setq magit-bury-buffer-function 'quit-window)
#+end_src

** Evil magit
*** Set up
#+begin_src emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/evil-magit-0.4.2")
(require 'evil-magit)
#+end_src
*** Kill Magit Buffer
#+begin_src emacs-lisp
(defun circ/magit-mode-kill-buffer () (interactive) (magit-mode-bury-buffer t))
(defun circ/magit-log-kill-buffer () (interactive) (magit-log-bury-buffer 2))
#+end_src
*** Evil keybindings
#+begin_src emacs-lisp
;; Removed in favour of evil-magit
;; (evil-set-initial-state 'magit-mode 'normal)
;; (evil-define-key 'normal magit-mode-map
;;   "g" 'magit-refresh

;;   "r" 'magit-rebase-popup
;;   "?" 'magit-dispatch-popup
;;   "c" 'magit-commit-popup
;;   "l" 'magit-log-popup
;;   "d" 'magit-diff-popup

;;   "j" 'magit-section-forward
;;   "k" 'magit-section-backward
;;   "\C-J" 'magit-section-forward-sibling
;;   "\C-K" 'magit-section-backward-sibling

;;   "1" 'magit-section-show-level-1
;;   "2" 'magit-section-show-level-2
;;   "3" 'magit-section-show-level-3
;;   "4" 'magit-section-show-level-4

;;   "\M-1" 'magit-section-show-level-1-all
;;   "\M-2" 'magit-section-show-level-2-all
;;   "\M-3" 'magit-section-show-level-3-all
;;   "\M-4" 'magit-section-show-level-4-all

;;   (kbd "TAB") 'magit-section-toggle
;; )

;; (evil-set-initial-state 'magit-status-mode 'normal)
;; (evil-define-key 'normal magit-status-mode-map
;;   "q" 'circ/magit-mode-kill-buffer

;;   "J" 'nil
;;   "Jfp" 'magit-jump-to-unpulled-from-pushremote
;;   "Jfu" 'magit-jump-to-unpulled-from-upstream
;;   "Jn" 'magit-jump-to-untracked
;;   "Jpp" 'magit-jump-to-unpushed-to-pushremote
;;   "Jpu" 'magit-jump-to-unpushed-to-upstream
;;   "Js" 'magit-jump-to-staged
;;   "Jt" 'magit-jump-to-tracked
;;   "Ju" 'magit-jump-to-unstaged
;;   "Jz" 'magit-jump-to-stashes

;;   (kbd "RET") 'magit-diff-visit-file
;; )

;; (evil-set-initial-state 'magit-log-mode 'normal)
;; (evil-define-key 'normal magit-log-mode-map
;;   "q" 'circ/magit-log-kill-buffer

;;   (kbd "RET") 'magit-show-commit
;; )

;; (evil-set-initial-state 'magit-diff-mode 'normal)
;; (evil-define-key 'normal magit-log-mode-map
;;   "q" 'circ/magit-mode-kill-buffer
;; )
#+end_src
** general
#+BEGIN_SRC emacs-lisp
(add-to-list
 'load-path
 "~/.emacs.d/packages/general-2d2dd1d532fa75c1ed0c010d50e817ce43e58066/")
(require 'general)
(general-auto-unbind-keys)
#+END_SRC

* Keybindings
** Aliases
To keep the code nice and clean.
#+BEGIN_SRC emacs-lisp
(defun circ/alias-text-scale-down () (interactive) (text-scale-adjust -1))
(defun circ/alias-text-scale-up   () (interactive) (text-scale-adjust +1))

(defun circ/alias-search-buffer () (interactive) (swiper (ivy-thing-at-point)))

(defun circ/alias-transpose-buffer-left  () (interactive) (circ/transpose-buffers-left t))
(defun circ/alias-transpose-buffer-down  () (interactive) (circ/transpose-buffers-down t))
(defun circ/alias-transpose-buffer-up    () (interactive) (circ/transpose-buffers-up t))
(defun circ/alias-transpose-buffer-right () (interactive) (circ/transpose-buffers-right t))

(defun circ/alias-cast-buffer-left  () (interactive) (circ/cast-buffer-left t))
(defun circ/alias-cast-buffer-down  () (interactive) (circ/cast-buffer-down t))
(defun circ/alias-cast-buffer-up    () (interactive) (circ/cast-buffer-up t))
(defun circ/alias-cast-buffer-right () (interactive) (circ/cast-buffer-right t))

(defun circ/alias-duplicate-buffer-left  () (interactive) (circ/duplicate-buffer-left t))
(defun circ/alias-duplicate-buffer-down  () (interactive) (circ/duplicate-buffer-down t))
(defun circ/alias-duplicate-buffer-up    () (interactive) (circ/duplicate-buffer-up t))
(defun circ/alias-duplicate-buffer-right () (interactive) (circ/duplicate-buffer-right t))

(defun circ/alias-erlang-find-tag () (interactive) (erlang-find-tag (erlang-default-function-or-module)))

(defun circ/alias-bash-shell () (interactive) (ansi-term "/bin/bash"))
(defun circ/alias-clip-shell () (interactive) (ansi-term "/usr/bin/clisp"))
(defun circ/alias-python-shell () (interactive) (ansi-term "/usr/bin/python"))

(defun circ/alias-org-force-publish () (interactive) (org-publish-current-project t))

(defun circ/alias-org-agenda-agenda () (interactive) (org-agenda nil "A"))
(defun circ/alias-org-agenda-tasks  () (interactive) (org-agenda nil "T"))

(defun circ/alias-sh-cmd-whole-buffer () (interactive) (circ/sh-cmd nil t nil))
(defun circ/alias-sh-cmd-split-lines () (interactive) (circ/sh-cmd nil nil t))
(defun circ/alias-sh-cmd-whole-buffer-split-lines () (interactive) (circ/sh-cmd nil t t))

(setq circ/vert-resize-delta 5)
(setq circ/horz-resize-delta 10)

(defvar circ/vert-resize-delta 1)
(defvar circ/horz-resize-delta 1)
(defun circ/alias-shrink-win-horz  () (interactive) (shrink-window-horizontally circ/horz-resize-delta))
(defun circ/alias-enlarge-win-horz () (interactive) (enlarge-window-horizontally circ/horz-resize-delta))
(defun circ/alias-shrink-win-vert  () (interactive) (shrink-window circ/vert-resize-delta))
(defun circ/alias-enlarge-win-vert () (interactive) (enlarge-window circ/vert-resize-delta))
#+END_SRC

** Helper Functions
#+BEGIN_SRC emacs-lisp
(setq circ/p1-prefix-normal   "C-M-S-")
(setq circ/p1-prefix-special  "C-M-")
(setq circ/p1-prefix-standard "M-f")

(setq circ/p2-prefix-normal   "s-M-S-")
(setq circ/p2-prefix-special  "s-M-")
(setq circ/p2-prefix-standard "M-d")

(setq circ/p3-prefix-normal   "s-C-S-")
(setq circ/p3-prefix-special  "s-C-")
(setq circ/p3-prefix-standard "M-s")

(setq circ/p4-prefix-normal   "s-C-M-")
(setq circ/p4-prefix-special  "s-C-M-")
(setq circ/p4-prefix-standard "M-a")

(defun circ/p1 (key command description &optional keymap)
  (let* ((prefix-normal   circ/p1-prefix-normal)
         (prefix-special  circ/p1-prefix-special)
         (standard-prefix circ/p1-prefix-standard)
         (prefix-key (cond ((string= key ";") (concat prefix-special ":"))
                           ((string= key "-") (concat prefix-special "_"))
                           ((string= key "=") (concat prefix-special "+"))
                           ((string= key ",") (concat prefix-special "<"))
                           ((string= key ".") (concat prefix-special ">"))
                           ((string= key "/") (concat prefix-special "?"))
                           (t (concat prefix-normal key))))
         (standard-prefix-key (concat standard-prefix " " key)))
    (circ/set-keys prefix-key standard-prefix-key command description keymap)))

(defun circ/p2 (key command description &optional keymap)
  (let* ((prefix-normal   circ/p2-prefix-normal)
         (prefix-special  circ/p2-prefix-special)
         (standard-prefix circ/p2-prefix-standard)
         (prefix-key (cond (t (concat prefix-special (upcase (substring key 0 1)) (substring key 1)))))
         (standard-prefix-key (concat standard-prefix " " key)))
    (circ/set-keys prefix-key standard-prefix-key command description keymap)))

(defun circ/p3 (key command description &optional keymap)
  (let* ((prefix-normal   circ/p3-prefix-normal)
         (prefix-special  circ/p3-prefix-special)
         (standard-prefix circ/p3-prefix-standard)
         (prefix-key (cond (t (concat prefix-special (upcase (substring key 0 1)) (substring key 1)))))
         (standard-prefix-key (concat standard-prefix " " key)))
    (circ/set-keys prefix-key standard-prefix-key command description keymap)))

(defun circ/p4 (key command description &optional keymap)
  (let* ((prefix-normal   circ/p4-prefix-normal)
         (prefix-special  circ/p4-prefix-special)
         (standard-prefix circ/p4-prefix-standard)
         (prefix-key (cond (t (concat prefix-normal key ))))
         (standard-prefix-key (concat standard-prefix " " key)))
    (circ/set-keys prefix-key standard-prefix-key command description keymap)))

(defun circ/set-keys (prefix-key standard-prefix-key command description &optional keymap)
  (cond (command
         (circ/set-key prefix-key command description keymap)
         (circ/set-key standard-prefix-key command description keymap))
        (t
         (circ/set-prefix prefix-key description keymap)
         (circ/set-prefix standard-prefix-key description keymap))))

(defun circ/set-prefix (key description &optional keymap)
  (cond (keymap
         (general-define-key
           :keymaps keymap
           :states '(normal insert visual operator motion emacs)
           key (list :ignore t :which-key description)))
        (t
         (general-define-key
           :states '(normal insert visual operator motion emacs)
           key (list :ignore t :which-key description)))))

(defun circ/set-key (key command description &optional keymap)
  (cond (keymap
         (general-define-key
          :keymaps keymap
          :states '(normal insert visual operator motion emacs)
          key (list command :which-key description)))
        (t
         (general-define-key
          :states '(normal insert visual operator motion emacs)
          key (list command :which-key description)))))

#+END_SRC

** Term Mode Keys
Evil-mode interferes with the normal bash bindings. They must be dealt with.

*** C-a     - Go to beginning of line
#+BEGIN_SRC emacs-lisp
(evil-define-key 'insert term-raw-map (kbd "C-a") 'term-send-raw)
#+END_SRC

*** C-e     - Go to end of line
#+BEGIN_SRC emacs-lisp
(evil-define-key 'insert term-raw-map (kbd "C-e") 'term-send-raw)
#+END_SRC

*** M-f     - Go to next word
Interferes with my custom invokers.

*** M-b     - Go to previous word
Already build in.

*** C-x x   - Toggle point between current position and start of line
C-x interferes with emacs a lot. I am leaving this out one.

*** M-d     - Delete next word
Interferes with my custom invokers.

*** C-x C-e - Edit the current command in your text editor
Danger! Having this makes it too easy to invoke vim from within emacs.

Bad idea.

*** C--     - Undo previous action(s)
Does anyone use this? I won't. Leaving it out.

*** C-w     - Cut current word before the cursor
#+BEGIN_SRC emacs-lisp
(evil-define-key 'insert term-raw-map (kbd "C-w") 'term-send-raw)
#+END_SRC

*** C-k     - Cut from cursor to end of line
#+BEGIN_SRC emacs-lisp
(evil-define-key 'insert term-raw-map (kbd "C-k") 'term-send-raw)
#+END_SRC

*** C-u     - Cut from cursor to start of line
#+BEGIN_SRC emacs-lisp
(evil-define-key 'insert term-raw-map (kbd "C-u") 'term-send-raw)
#+END_SRC

*** C-y     - Paste the cut buffer at current position
#+BEGIN_SRC emacs-lisp
(evil-define-key 'insert term-raw-map (kbd "C-y") 'term-send-raw)
#+END_SRC

*** C-d     - Send EOF / Delete current character
#+BEGIN_SRC emacs-lisp
(evil-define-key 'insert term-raw-map (kbd "C-d") 'term-send-raw)
#+END_SRC

*** C-l     - Clear the terminal screen
Already built-in.

*** C-z     - Send current command to the background.
#+BEGIN_SRC emacs-lisp
;; C-z is more useful as a switch between evil and emacs states
;; So a command is available instead
(defun term-send-current-command-to-background ()
  (interactive)
  (term-send-raw-string "\C-z"))
#+END_SRC

*** C-r - Search history
#+BEGIN_SRC emacs-lisp
;(evil-define-key 'insert term-raw-map (kbd "C-r") 'term-send-raw)
(evil-define-key 'insert term-raw-map (kbd "C-r") 'circ/bash-history-search)
#+END_SRC

*** <delete> - Delete forward
#+begin_src emacs-lisp
(evil-define-key 'insert term-raw-map (kbd "<delete>") 'term-send-del)
#+end_src
*** C-<backspace> - Delete prevous word
Not strictly a bash thing, but I'm putting it in anyway.
Simply send C-w instead
#+BEGIN_SRC emacs-lisp
(evil-define-key 'insert term-raw-map (kbd "C-<backspace>")
  'circ/term/delete-previous-word)
#+END_SRC

*** C-<delete> - Delete next word
Not strictly a bash thing, but I'm putting it in anyway.
Simply send M-d instead
#+BEGIN_SRC emacs-lisp
(evil-define-key 'insert term-raw-map (kbd "C-<delete>")
  'circ/term/delete-next-word)
#+END_SRC

*** C-<left> - Go to previous word
Not strictly a bash thing, but I'm putting it in anyway.
Simply send M-b instead
#+BEGIN_SRC emacs-lisp
(evil-define-key 'insert term-raw-map (kbd "C-<left>")
  'circ/term/go-to-previous-word)
#+END_SRC

*** C-<right> - Go to next word
Not strictly a bash thing, but I'm putting it in anyway.
Simply send M-f instead
#+BEGIN_SRC emacs-lisp
(evil-define-key 'insert term-raw-map (kbd "C-<right>")
  'circ/term/go-to-next-word)
#+END_SRC

** mu4e
#+begin_src emacs-lisp
(general-define-key
  :keymaps 'mu4e-compose-mode-map
  :states '(normal)
  "q" 'nil :which-key "Quit"
  "qq" '(mu4e-message-kill-buffer :which-key "Cancel message and quit")
  "qd" '(message-dont-save :which-key "Save as draft and quit")
  "qs" '(message-send-and-exit :which-key "Send message and quit")
)
#+end_src
** Unbinding Keys
#+BEGIN_SRC emacs-lisp
;(general-unbind
;  '(normal insert visual operator)
;  '(global-map org-mode-map evil-org-mode-map)
  ;"C-S-h"
  ;"C-S-j"
  ;"C-S-k"
  ;"C-S-l"
  ;"C-M-S-d"
;)

;; Prevent these from appearing in the standard keymap
(global-unset-key (kbd "M-s ESC"))
(global-unset-key (kbd "M-s ."))
(global-unset-key (kbd "M-s _"))
(global-unset-key (kbd "M-s o"))
(global-unset-key (kbd "M-s w"))
#+END_SRC

** P1
#+BEGIN_SRC emacs-lisp
;;FUN    KEY    FUNCTION                              DESCRIPTION                           MODE
(circ/p1 ","    'previous-buffer                      "prev buffer")
(circ/p1 "-"    'circ/alias-text-scale-down           "text scale down")
(circ/p1 "."    'next-buffer                          "next buffer")
(circ/p1 "/"    'circ/alias-search-buffer             "search buffer")
(circ/p1 ";"    'counsel-M-x                          "M-x")
(circ/p1 "="    'circ/alias-text-scale-up             "text scale up")
(circ/p1 "a"    'nil                                  "abbrevs / snippets")
(circ/p1 "a a"  'circ/add-abbrev                      "add abbrev")
(circ/p1 "a e"  'circ/snippet-expand                  "snippet expand")
(circ/p1 "a r"  'circ/snippet-load-snippets           "load snippets")
(circ/p1 "a l"  'circ/snippet-select                  "select snippets")
(circ/p1 "b b"  'ivy-switch-buffer                    "switch buffers")
(circ/p1 "b c"  'nil                                  "cast buffers")
(circ/p1 "b ch" 'circ/alias-cast-buffer-left          "cast buffer left")
(circ/p1 "b cj" 'circ/alias-cast-buffer-down          "cast buffer down")
(circ/p1 "b ck" 'circ/alias-cast-buffer-up            "cast buffer up")
(circ/p1 "b cl" 'circ/alias-cast-buffer-right         "cast buffer right")
(circ/p1 "b d"  'nil                                  "duplicate buffers")
(circ/p1 "b dh" 'circ/alias-duplicate-buffer-left     "duplicate buffer left")
(circ/p1 "b dj" 'circ/alias-duplicate-buffer-down     "duplicate buffer down")
(circ/p1 "b dk" 'circ/alias-duplicate-buffer-up       "duplicate buffer up")
(circ/p1 "b dl" 'circ/alias-duplicate-buffer-right    "duplicate buffer right")
(circ/p1 "b f"  'circ/show-file-path                  "show file path")
(circ/p1 "b o"  'open-in-new-config                   "open buffer in a new window config")
(circ/p1 "b n"  'circ/show-buffer-name                "show buffer name")
(circ/p1 "b p"  'circ/buffer-paste                    "paste buffer")
(circ/p1 "b r"  'rename-buffer                        "rename buffer")
(circ/p1 "b t"  'nil                                  "transpose buffers")
(circ/p1 "b th" 'circ/alias-transpose-buffer-left     "transpose windows left")
(circ/p1 "b tj" 'circ/alias-transpose-buffer-down     "transpose windows down")
(circ/p1 "b tk" 'circ/alias-transpose-buffer-up       "transpose windows up")
(circ/p1 "b tl" 'circ/alias-transpose-buffer-right    "transpose windows right")
(circ/p1 "b x"  'circ/smart-clear-buffer              "clear buffer")
(circ/p1 "b y"  'circ/buffer-yank                     "yank buffer")
(circ/p1 "b"    'nil                                  "buffers")
(circ/p1 "c"    'delete-window                        "close window")
(circ/p1 "d"    'circ/alias-erlang-find-tag           "goto definition"                     'erlang-mode-map)
(circ/p1 "d"    'evil-goto-definition                 "goto definition")
(circ/p1 "d"    'org-open-at-point                    "open link"                           'org-agenda-mode-map)
(circ/p1 "d"    'org-open-at-point                    "open link"                           'org-mode-map)
(circ/p1 "d"    'circ/rcirc-open-url                  "open link"                           'rcirc-mode-map)
(circ/p1 "e #"  'nil                                  "number increment / decrement")
(circ/p1 "e #a" 'evil-numbers/inc-at-pt               "increment")
(circ/p1 "e #x" 'evil-numbers/dec-at-pt               "decrement")
(circ/p1 "e a"  'nil                                  "align")
(circ/p1 "e aH" 'circ/align-repeat-head               "regex ahead of match repeatedly")
(circ/p1 "e aT" 'circ/align-repeat-tail               "regex to tail of match repeatedly")
(circ/p1 "e aa" 'erlang-align-arrows                  "align arrows"                        'erlang-mode-map)
(circ/p1 "e ah" 'circ/align-once-head                 "regex ahead of match")
(circ/p1 "e at" 'circ/align-once-tail                 "regex to tail of match")
(circ/p1 "e c"  'dabbrev-completion                   "dabbrev completion")
(circ/p1 "e C"  'capitalize-dwim                      "capitalise")
(circ/p1 "e d"  'erlang-clone-arguments               "duplicate arguments"                 'erlang-mode-map)
(circ/p1 "e f"  'nil                                  "formatting")
(circ/p1 "e fb" 'json-mode-beautify                   "json beautify"                       'json-mode-map)
(circ/p1 "e fi" 'indent-region                        "indent region")
(circ/p1 "e fp" 'fill-paragraph                       "fill paragraph")
(circ/p1 "e fr" 'fill-region                          "fill region")
(circ/p1 "e i"  'erlang-indent-region                 "indent region"                       'erlang-mode-map)
(circ/p1 "e j"  'erlang-generate-new-clause           "new clause"                          'erlang-mode-map)
(circ/p1 "e s"  'nil                                  "surround")
(circ/p1 "e s'" 'circ/surround-s-quote                "single quote '")
(circ/p1 "e s(" 'circ/surround-parentheses            "parentheses ( )")
(circ/p1 "e s)" 'circ/surround-parentheses            "parentheses ( )")
(circ/p1 "e s*" 'circ/surround-asterisk               "asterisk *")
(circ/p1 "e s+" 'circ/surround-plus                   "plus +")
(circ/p1 "e s-" 'circ/surround-minus                  "minus -")
(circ/p1 "e s/" 'circ/surround-slash                  "slash /")
(circ/p1 "e s=" 'circ/surround-equals                 "equals =")
(circ/p1 "e s[" 'circ/surround-brackets               "brackets [ ]")
(circ/p1 "e s\"" 'circ/surround-d-quote               "double quote \"")
(circ/p1 "e s]" 'circ/surround-brackets               "brackets [ ]")
(circ/p1 "e ss" 'circ/surround-region                 "surround region")
(circ/p1 "e s{" 'circ/surround-braces                 "braces { }")
(circ/p1 "e s}" 'circ/surround-braces                 "braces { }")
(circ/p1 "e"    'nil                                  "edits")
(circ/p1 "f b"  'ivy-switch-buffer                    "buffers")
(circ/p1 "f f"  'counsel-find-file                    "find file")
(circ/p1 "f h"  'org-html-export-to-html              "export to html"                      'org-mode-map)
(circ/p1 "f r"  'counsel-recentf                      "find recent file")
(circ/p1 "f s"  'nil                                  "scratch buffers")
(circ/p1 "f sj" 'new-scratch-json-mode                "json scratch buffer")
(circ/p1 "f so" 'new-scratch-org-mode                 "org scratch buffer")
(circ/p1 "f st" 'new-scratch-text-mode                "text scratch buffer")
(circ/p1 "f ss" 'new-scratch-shell-script-mode        "shell script scratch buffer")
(circ/p1 "f sp" 'new-scratch-python-mode              "python scratch buffer")
(circ/p1 "f t"  'nil                                  "tramp")
(circ/p1 "f tB" 'tramp-cleanup-all-buffers            "tramp clean all buffers")
(circ/p1 "f tc" 'tramp-cleanup-this-connection        "tramp clean this connection")
(circ/p1 "f tC" 'tramp-cleanup-all-connections        "tramp clean all connection")
(circ/p1 "f"    'nil                                  "files")
(circ/p1 "g"    'nil                                  "goto")
(circ/p1 "g 1"  'avy-goto-char                        "goto char 1")
(circ/p1 "g 2"  'avy-goto-char-2                      "goto char 2")
(circ/p1 "g t"  'avy-goto-char-timer                  "goto char timer")
(circ/p1 "g l"  'avy-goto-line                        "goto line")
(circ/p1 "g w"  'avy-goto-word-1                      "goto word 1")
(circ/p1 "g h"  'avy-org-goto-heading-timer           "goto org heading timer"              'org-mode-map)
(circ/p1 "h"    'windmove-left                        "win left")
(circ/p1 "j"    'windmove-down                        "win down")
(circ/p1 "k"    'windmove-up                          "win up")
(circ/p1 "l"    'windmove-right                       "wind right")
(circ/p1 "m"    'nil                                  "bookmarks")
(circ/p1 "m a"  'bookmark-set                         "set bookmark")
(circ/p1 "m A"  'bookmark-set-no-overwrite            "set bookmark (no overwrite)")
(circ/p1 "m b"  'bookmark-jump                        "open bookmark")
(circ/p1 "m l"  'bookmark-bmenu-list                  "open bookmark")
(circ/p1 "o b"  'ibuffer                              "ibuffer")
(circ/p1 "o c"  'copy-buffer                          "copy buffer")
(circ/p1 "o d"  'dired-jump                           "dired jump")
(circ/p1 "o D"  'dired                                "dired")
(circ/p1 "o e"  'mu4e                                 "mu4e")
(circ/p1 "o i"  'circ/open-in-intellij                "open in intellij")
(circ/p1 "o i"  'image-dired                          "image-dired"                         'dired-mode-map)
(circ/p1 "o m"  'mpccp                                "mpccp")
(circ/p1 "o p"  'proced                               "proded")
(circ/p1 "o r"  'circ/elfeed-load-and-open            "elfeed")
(circ/p1 "o s"  'circ/open-in-openscad                "open in openscad"                    'scad-mode-map)
(circ/p1 "o tc" 'circ/alias-clisp-shell               "clisp")
(circ/p1 "o te" 'erlang-shell                         "erlang")
(circ/p1 "o tp" 'circ/alias-python-shell              "python")
(circ/p1 "o tt" 'circ/ansi-term                       "bash")
(circ/p1 "o x"  'emux                                 "emux")
(circ/p1 "o"    'nil                                  "applications")
(circ/p1 "p ?"  'projectile-command-map               "other")
(circ/p1 "p O"  'circ/alias-org-force-publish         "force org publish project"           'org-mode-map)
(circ/p1 "p b"  'projectile-switch-to-buffer          "switch project buffer")
(circ/p1 "p c"  'circ/check-project                   "check / compile project")
(circ/p1 "p f"  'counsel-projectile-find-file         "find project file")
(circ/p1 "p g"  'counsel-projectile-grep              "find instances in project")
(circ/p1 "p i"  'org-insert-link                      "insert link")
(circ/p1 "p o"  'org-publish-current-project          "org publish project"                 'org-mode-map)
(circ/p1 "p p"  'counsel-projectile-switch-project    "switch project")
(circ/p1 "p r"  'circ/revert-project-buffers          "revert project buffers")
(circ/p1 "p s"  'org-store-link                       "copy link")
(circ/p1 "p t"  'circ/regenerate-tags                 "regenerate tags")
(circ/p1 "p w"  'circ/save-project-buffers            "save all project buffers")
(circ/p1 "p w"  'org-save-all-org-buffers             "save all org buffers"                'org-mode-map)
(circ/p1 "p"    'nil                                  "projects")
(circ/p1 "q"    'circ/kill-this-buffer                "kill buffer")
(circ/p1 "r n"  'nil                                  "numbers")
(circ/p1 "r ni" 'increment-register                   "increment register with number")
(circ/p1 "r np" 'insert-register                      "paste number from register")
(circ/p1 "r ny" 'number-to-register                   "yank number to register")
(circ/p1 "r p"  'nil                                  "positions")
(circ/p1 "r pp" 'jump-to-register                     "goto register position")
(circ/p1 "r py" 'point-to-register                    "yank current position to register")
(circ/p1 "r r"  'nil                                  "rectangle")
(circ/p1 "r rp" 'insert-register                      "paste rectangle from register")
(circ/p1 "r ry" 'copy-rectangle-to-register           "yank rectangle to register")
(circ/p1 "r t"  'nil                                  "text")
(circ/p1 "r ta" 'append-to-register                   "append text to register")
(circ/p1 "r tb" 'prepend-to-register                  "prepend text to register (before)")
(circ/p1 "r tp" 'insert-register                      "paste text register")
(circ/p1 "r ty" 'copy-to-register                     "yank text to register")
(circ/p1 "r"    'nil                                  "registers")
(circ/p1 "t R"  'auto-revert-mode                     "toggle auto revert mode")
(circ/p1 "t W"  'circ/toggle-whitespace-full          "toggle whitespace full")
(circ/p1 "t a"  'abbrev-mode                          "toggle abbrev mode")
(circ/p1 "t a"  'vc-annotate-toggle-annotation-visibility "toggle annotations"              'vc-annotate-mode-map)
(circ/p1 "t b"  'circ/org-agenda-toggle-blocked-tasks "toggle blocked tasks"                'org-agenda-mode-map)
(circ/p1 "t c"  'circ/org-agenda-toggle-clock-closed  "toggle clock closed"                 'org-agenda-mode-map)
(circ/p1 "t c"  'comment-line                         "toggle comment line")
(circ/p1 "t f"  'font-lock-mode                       "toggle auto font formatting")
(circ/p1 "t h"  'hl-line-mode                         "toggle highight line mode")
(circ/p1 "t h"  'dired-omit-mode                      "toggle hidden"                       'dired-mode-map)
(circ/p1 "t i"  'org-toggle-inline-images             "toggle images"                       'org-mode-map)
(circ/p1 "t l"  'nlinum-mode                          "toggle relative line numbers")
(circ/p1 "t o"  'rcirc-omit-mode                      "toggle omit mode"                    'rcirc-mode-map) ;; TODO WORKING?
(circ/p1 "t p"  'projectile-mode                      "toggle projectile mode")
(circ/p1 "t r"  'rainbow-delimiters-mode              "toggle rainbow delimiters")
(circ/p1 "t t"  'nil                                  "tables"                              'org-mode-map)
(circ/p1 "t t"  'circ/org-agenda-toggle-hide-tags     "toggle hide tags"                    'org-agenda-mode-map)
(circ/p1 "t t"  'proced-toggle-tree                   "toggle proced tree"                  'proced-mode-map)
(circ/p1 "t tr" 'org-table-toggle-coordinate-overlay  "toggle table coords"                 'org-mode-map)
(circ/p1 "t w"  'whitespace-mode                      "toggle whitespace display")
(circ/p1 "t"    'nil                                  "toggles")
(circ/p1 "v D"  'vc-ediff                             "ediff")
(circ/p1 "v a"  'circ/vc-annotate                     "annotate")
(circ/p1 "v b"  'counsel-git-checkout                 "change branch")
(circ/p1 "v d"  'nil                                  "diff")
(circ/p1 "v dd" 'vc-version-ediff                     "version ediff")
(circ/p1 "v dm" 'circ/vc-diff-head-current            "compare current to head")
(circ/p1 "v n"  'diff-hl-next-hunk                    "next change")
(circ/p1 "v p"  'diff-hl-previous-hunk                "prev change")
(circ/p1 "v m"  'nil                                  "merge conflict"                      'smerge-mode-map)
(circ/p1 "v mn" 'smerge-next                          "next merge conflict"                 'smerge-mode-map)
(circ/p1 "v mp" 'smerge-prev                          "prev merge conflict"                 'smerge-mode-map)
(circ/p1 "v s"  'magit-status                         "magit status")
(circ/p1 "v"    'nil                                  "version control")
(circ/p1 "w e"  'balance-windows                      "balance windows")
(circ/p1 "w h"  'circ/split-window-right              "split horizontal")
(circ/p1 "w o"  'delete-other-windows                 "delete other windows")
(circ/p1 "w r"  'revert-buffer                        "reload from disk")
(circ/p1 "w v"  'circ/split-window-below              "split vertical")
(circ/p1 "w z"  'maximize-window                      "maximize")
(circ/p1 "w H"  'circ/maximise-window-horizontal      "maximize horizontal")
(circ/p1 "w V"  'circ/maximise-window-vertical        "maximize vertical")
(circ/p1 "w"    'nil                                  "windows")
(circ/p1 "x S"  'circ/alias-sh-cmd-whole-buffer-split-lines "sh cmd whole buffer split lines")
(circ/p1 "x X"  'circ/alias-sh-cmd-whole-buffer       "sh cmd whole buffer")
(circ/p1 "x s"  'circ/alias-sh-cmd-split-lines        "sh cmd split lines")
(circ/p1 "x x"  'circ/sh-cmd                          "sh cmd")
(circ/p1 "x"    'nil                                  "sh cmd")
#+END_SRC

** P2
#+BEGIN_SRC emacs-lisp
;;       KEY    FUNCTION                              DESCRIPTION                           MODE
(circ/p2 "h"    'circ/alias-shrink-win-horz           "shrink horz"                         'override)
(circ/p2 "j"    'circ/alias-enlarge-win-vert          "enlarge vert"                        'override)
(circ/p2 "k"    'circ/alias-shrink-win-vert           "shrink vert"                         'override)
(circ/p2 "l"    'circ/alias-enlarge-win-horz          "enlarge horz"                        'override)
(circ/p2 "i"    'nil                                  "insert")
(circ/p2 "i a"  'nil                                  "a chars")
(circ/p2 "i am" 'circ/insert-a-macron                 "")
(circ/p2 "i e"  'nil                                  "e chars")
(circ/p2 "i em" 'circ/insert-e-macron                 "")
(circ/p2 "i i"  'nil                                  "i chars")
(circ/p2 "i im" 'circ/insert-i-macron                 "")
(circ/p2 "i o"  'nil                                  "o chars")
(circ/p2 "i om" 'circ/insert-o-macron                 "")
(circ/p2 "i u"  'nil                                  "u chars")
(circ/p2 "i um" 'circ/insert-u-macron                 "")
(circ/p2 "i y"  'nil                                  "y chars")
(circ/p2 "i ym" 'circ/insert-y-macron                 "")
(circ/p2 "p"    'nil                                  "pass")
(circ/p2 "p u"  'circ/pass/copy-user                  "copy user")
(circ/p2 "p p"  'circ/pass/copy-password              "copy password")
(circ/p2 "p g"  'circ/pass/generate-entry             "generate")
(circ/p2 "p o"  'circ/pass/open-entry                 "open entry")
(circ/p2 "e"    'balance-windows                      "balance window")
(circ/p2 "z"    'nil                                  "maximise window")
(circ/p2 "z z"  'maximize-window                      "maximise window")
(circ/p2 "z h"  'circ/maximise-window-horizontal      "maximise window horizontal")
(circ/p2 "z v"  'circ/maximise-window-vertical        "maximise window vertical")
(circ/p2 "c"    'nil                                  "minimise window")
(circ/p2 "c c"  'minimize-window                      "minimise window")
(circ/p2 "c h"  'circ/minimise-window-horizontal      "minimise window horizontal")
(circ/p2 "c v"  'circ/minimise-window-vertical        "minimise window vertical")
#+END_SRC

** P3
#+BEGIN_SRC emacs-lisp
;;       KEY    FUNCTION                              DESCRIPTION                           MODE
(circ/p3 "f r"  'circ/set-frame-name                  "rename frame")
(circ/p3 "f c"  'make-frame                           "create new frame")
(circ/p3 "f q"  'delete-frame                         "close frame")
(circ/p3 "f o"  'pop-out-config-to-new-frame          "pop out to frame")
(circ/p3 "f"    'nil                                  "frames")
(circ/p3 "h"    'circ/alias-cast-buffer-left          "cast buffer left")
(circ/p3 "j"    'circ/alias-cast-buffer-down          "cast buffer down")
(circ/p3 "k"    'circ/alias-cast-buffer-up            "cast buffer up")
(circ/p3 "l"    'circ/alias-cast-buffer-right         "cast buffer right")
(circ/p3 "p"    'evil-jump-backward                   "jump back")
(circ/p3 "n"    'evil-jump-forward                    "jump forward")
(circ/p3 "x"    'nil                                  "clearing notifications")
(circ/p3 "x e"  'circ/rcirc-clear-all-buffer-tracking "clear all rcirc tracking")
#+END_SRC

** P4
#+BEGIN_SRC emacs-lisp
;;       KEY    FUNCTION                              DESCRIPTION                           MODE
(circ/p4 "["    'org-previous-link                    "previous link"                       'org-mode-map)
(circ/p4 "]"    'org-next-link                        "next link"                           'org-mode-map)
(circ/p4 "["    'org-previous-link                    "previous link"                       'org-agenda-mode-map)
(circ/p4 "]"    'org-next-link                        "next link"                           'org-agenda-mode-map)
(circ/p4 "["    'shr-previous-link                    "previous link"                       'mu4e-view-mode-map)
(circ/p4 "]"    'shr-next-link                        "next link"                           'mu4e-view-mode-map)
(circ/p4 "["    'backward-button                      "backward button"                     'Man-mode-map)
(circ/p4 "]"    'forward-button                       "forward button"                      'Man-mode-map)
(circ/p4 "["    'eww-previous-url                     "previous url"                        'eww-mode-map)
(circ/p4 "]"    'eww-next-url                         "next url"                            'eww-mode-map)
(circ/p4 "["    'shr-previous-link                    "previous link"                       'elfeed-show-mode-map)
(circ/p4 "]"    'elfeed-show-next-link                "next link"                           'elfeed-show-mode-map)
(circ/p4 "["    'backward-button                      "backward button"                     'help-mode-map)
(circ/p4 "]"    'forward-button                       "forward button"                      'help-mode-map)
(circ/p4 "/"    'counsel-org-goto                     "org goto"                            'org-mode-map)
(circ/p4 "/"    'Man-goto-section                     "man goto section"                    'Man-mode-map)
(circ/p4 "a"    'nil                                  "org-agenda")
(circ/p4 "a a"  'circ/alias-org-agenda-agenda         "agenda")
(circ/p4 "a t"  'circ/alias-org-agenda-tasks          "tasks")
(circ/p4 "a s"  'circ/setup-agenda-view               "setup agenda view")
(circ/p4 "b c"  'circ/open-calendar                   "calendar")
(circ/p4 "b l"  'circ/open-checklists                 "checklists")
(circ/p4 "b i"  'circ/open-inbox                      "inbox")
(circ/p4 "b r"  'circ/open-read                       "read")
(circ/p4 "b s"  'circ/open-someday                    "someday")
(circ/p4 "b t"  'circ/open-todo                       "todo")
(circ/p4 "b vc" 'org-columns                          "columns"                             'org-mode-map)
(circ/p4 "b"    'nil                                  "buffer switching")
(circ/p4 "e"    'nil                                  "org edit"                            'org-mode-map)
(circ/p4 "e s"  'circ/org-sort-headlines              "sort headlines"                      'org-mode-map)
(circ/p4 "e c"  'org-clone-subtree-with-time-shift    "clone subtree with time shirt"       'org-mode-map)
(circ/p4 "f m"  'circ/org-file-reference              "file reference"                      'org-mode-map)
(circ/p4 "f p"  'circ/pims/set-project                "set as project"                      'org-mode-map)
(circ/p4 "f r"  'org-refile                           "org refile"                          'org-mode-map)
(circ/p4 "f r"  'org-agenda-refile                    "org refile"                          'org-agenda-mode-map)
(circ/p4 "f t"  'circ/pims/set-todo                   "set as todo"                         'org-mode-map)
(circ/p4 "f d"  'circ/pims/refile-to-tickler          "refile to tickler"                   'org-mode-map)
(circ/p4 "f"    'nil                                  "filing"                              'org-mode-map)
(circ/p4 "h"    'outline-backward-same-level          "back same level")
(circ/p4 "i"    'org-clock-in                         "clock in"                            'org-mode-map)
(circ/p4 "j"    'outline-next-visible-heading         "next visible heading")
(circ/p4 "k"    'outline-previous-visible-heading     "prev visible heading")
(circ/p4 "l"    'outline-forward-same-level           "forward same level")
(circ/p4 "d"    'org-archive-subtree-default          "archive"                             'org-mode-map)
(circ/p4 "d"    'org-agenda-archive                   "archive"                             'org-agenda-mode-map)
(circ/p4 "n"    'org-capture                          "org capture")
(circ/p4 "o"    'org-clock-out                        "clock out"                           'org-mode-map)
(circ/p4 "p e"  'org-set-effort                       "effort"                              'org-mode-map)
(circ/p4 "p e"  'org-agenda-set-effort                "effort"                              'org-agenda-mode-map)
(circ/p4 "p d"  'org-deadline                         "deadline"                            'org-mode-map)
(circ/p4 "p d"  'org-agenda-deadline                  "deadline"                            'org-agenda-mode-map)
(circ/p4 "p p"  'org-set-property                     "set property"                        'org-mode-map)
(circ/p4 "p p"  'org-agenda-set-property              "set property"                        'org-agenda-mode-map)
(circ/p4 "p s"  'org-schedule                         "schedule"                            'org-mode-map)
(circ/p4 "p s"  'org-agenda-schedule                  "schedule"                            'org-agenda-mode-map)
(circ/p4 "p t"  'circ/org-set-tags                    "set tags"                            'org-mode-map)
(circ/p4 "p T"  'circ/org-clear-tags                  "clear tags"                          'org-mode-map)
(circ/p4 "p t"  'circ/org-agenda-set-tags             "set tags"                            'org-agenda-mode-map)
(circ/p4 "p T"  'circ/org-agenda-clear-tags           "clear tags"                          'org-agenda-mode-map)
(circ/p4 "p o"  'org-toggle-ordered-property          "toggle ordered"                      'org-mode-map)
(circ/p4 "p i"  'circ/org-toggle-pinned-property      "toggle pinned"                       'org-mode-map)
(circ/p4 "p i"  'circ/org-agenda-toggle-pinned-property "toggle pinned"                     'org-agenda-mode-map)
(circ/p4 "p n"  'org-add-note                         "add note"                            'org-mode-map)
(circ/p4 "p n"  'org-agenda-add-note                  "add note"                            'org-agenda-mode-map)
(circ/p4 "p"    'nil                                  "property"                            'org-mode-map)
(circ/p4 "r"    'nil                                  "references"                          'org-mode-map)
(circ/p4 "r f"  'circ/pims/find-reference             "find reference")
(circ/p4 "r l"  'circ/pims/insert-reference-link      "insert reference link"               'org-mode-map)
(circ/p4 "t c"  'org-table-create-or-convert-from-region "create / convert table"           'org-mode-map)
(circ/p4 "t d"  'nil                                  "delete"                              'org-mode-map)
(circ/p4 "t dd" 'org-cut-special                      "delete cell"                         'org-mode-map)
(circ/p4 "t dc" 'org-table-delete-column              "delete column"                       'org-mode-map)
(circ/p4 "t dr" 'org-table-kill-row                   "delete row"                          'org-mode-map)
(circ/p4 "t i"  'nil                                  "insert"                              'org-mode-map)
(circ/p4 "t ic" 'org-table-insert-column              "insert column"                       'org-mode-map)
(circ/p4 "t ih" 'org-table-insert-hline               "insert horizontal line"              'org-mode-map)
(circ/p4 "t ir" 'org-table-insert-row                 "insert row"                          'org-mode-map)
(circ/p4 "t y"  'nil                                  "yank"                                'org-mode-map)
(circ/p4 "t yy" 'org-copy-special                     "yank cell"                           'org-mode-map)
(circ/p4 "t p"  'nil                                  "paste"                               'org-mode-map)
(circ/p4 "t pp" 'org-paste-special                    "paste cell"                          'org-mode-map)
(circ/p4 "t"    'nil                                  "tables"                              'org-mode-map)
(circ/p4 "u"    'outline-up-heading                   "up heading")
(circ/p4 "v c"  'circ/insert-created-timestamp        "created date"                        'org-mode-map)
(circ/p4 "v d"  'org-time-stamp                       "time stamp"                          'org-mode-map)
(circ/p4 "v n"  'org-add-note                         "add note"                            'org-mode-map)
(circ/p4 "v l"  'org-insert-link                      "edit link"                           'org-mode-map)
(circ/p4 "v p"  'counsel-yank-pop                     "paste selector")
(circ/p4 "v t"  'circ/org-template-insert             "template"                            'org-mode-map)
(circ/p4 "v f"  'mml-attach-file                      "attach file"                         'mu4e-compose-mode-map)
(circ/p4 "v"    'nil                                  "insert items"                        'org-mode-map)
(circ/p4 "x"    'nil                                  "none")
(circ/p4 "x"    'org-toggle-checkbox                  "toggle checkbox"                     'org-mode-map)
#+END_SRC

** Other
*** Non-P Bindings
#+BEGIN_SRC emacs-lisp
(evil-define-key 'motion org-agenda-mode-map "ci" 'org-agenda-show-clocking-issues)
(evil-define-key 'motion org-agenda-mode-map "cl" 'org-agenda-log-mode)

;; F1 is reserved for some special cases when "C-h" isn't available
(general-define-key
  "<f2>" 'circ/alias-org-agenda-agenda
  "<f3>" 'circ/alias-org-agenda-tasks
  "<f4>" 'circ/open-inbox
  "<f5>" 'circ/open-checklists
)

(general-define-key :keymaps 'override
  "C-a" 'mark-whole-buffer
)

(evil-define-key '(normal visual) copy-buffer-mode-map
  "q" 'copy-buffer-copy-quit)

(evil-define-key 'motion org-agenda-mode-map
  "f" 'nil
  "ft" 'circ/org-agenda-filter-tag
  "fT" 'circ/org-agenda-show-all-tags
  "fe" 'circ/org-agenda-filter-effort
  "fE" 'circ/org-agenda-show-all-efforts
  "fc" 'circ/org-agenda-filter-category
  "fC" 'circ/org-agenda-show-all-categories
  "r" 'circ/org-agenda-redo
  "R" 'org-agenda-redo)

(evil-define-key 'normal org-capture-mode-map
  "q" 'org-capture-finalize
  "Q" 'org-capture-kill)
;; Evil mode only sets keymaps on state transition. It does not know that
;; org-capture-mode-map has evil bindings when you start an org-capture. Force
;; it to load the keymap with this function on hook.
(add-hook 'org-capture-mode-hook 'evil-normalize-keymaps)

(general-define-key
 :keymaps 'ivy-minibuffer-map
 "<escape>"  'minibuffer-keyboard-quit
  "C-l" 'delete-minibuffer-contents)

(general-define-key
 :keymaps 'swiper-map
 "<escape>"  'minibuffer-keyboard-quit
  "C-l" 'delete-minibuffer-contents)
#+END_SRC

*** Help
#+BEGIN_SRC emacs-lisp
(general-define-key
  "C-h v" 'counsel-describe-variable
  "C-h f" 'counsel-describe-function
)
#+END_SRC
* Custom Command Line Options
These are for easy launching of emacs.

To automagically open emacsclient or emacs do so in the format:
#+BEGIN_SRC sh
emacsclient -c -a 'false' --no-wait --eval "(circ/startup/agenda)" || emacs --agenda
#+END_SRC
This will open an emacsclient and automatically launch an emacsclient if emacs
is already running, and run the =circ/startup/agenda= function. If emacs is not
running, it will open a new instance and use the =--agenda= flag to launch
=circ/startup/agenda=.

#+BEGIN_SRC emacs-lisp
(defun circ/startup/inbox (&optional switch) (circ/open-inbox))
(add-to-list 'command-switch-alist '("--inbox" . circ/startup/inbox))

(defun circ/startup/agenda (&optional switch) (circ/alias-org-agenda-agenda))
(add-to-list 'command-switch-alist '("--agenda" . circ/startup/agenda))

(defun circ/startup/tasks (&optional switch) (circ/alias-org-agenda-tasks))
(add-to-list 'command-switch-alist '("--tasks" . circ/startup/tasks))

(defun circ/startup/pims (&optional switch) (circ/set-up-agenda-view))
(add-to-list 'command-switch-alist '("--pims" . circ/startup/pims))
#+END_SRC
