#+STARTUP: overview
#+TITLE: emacs.d config

* Better defaults
** Start Up
#+BEGIN_SRC emacs-lisp
(server-start) ; Start emacs server
;(desktop-save-mode 1) ; Save session and restore on next launch
#+END_SRC

** UI
#+BEGIN_SRC emacs-lisp
(setq inhibit-startup-screen t) ; inhibit useless and old-school startup screen
(setq ring-bell-function 'ignore) ; silent bell when you make a mistake
(setq-default frame-title-format '("%b - Emacs")) ; set the emacs title.
                                        ; overrides the old "emacs@HOST" title
(set-frame-font "Liberation Mono 7" t t)
(menu-bar-mode -1)
(tool-bar-mode -1)
(scroll-bar-mode -1)
(load-theme 'wheatgrass)
; Split vertically by default
(setq split-width-threshold 160)
(setq split-height-threshold 100)
(setq-default fill-column 80)
(setq calendar-week-start-day 1)
#+END_SRC

** Tab Behaviour
#+BEGIN_SRC emacs-lisp
(setq-default indent-tabs-mode nil) ; don't insert tabs
(setq-default tab-width 4) ; self-documenting
(setq indent-line-function 'insert-tab)
#+END_SRC

** Backup and autosave locations
#+BEGIN_SRC emacs-lisp
(setq backup-directory-alist '((".*" . "~/.emacs.d/backup")))
(setq auto-save-file-name-transforms '((".*" "~/.emacs.d/autosave/" t)))
#+END_SRC

** Default major mode
#+BEGIN_SRC emacs-lisp
(setq-default major-mode 'text-mode)
#+END_SRC

* Whitespace
Force it on all the time.

Highlights:
- face visualisation
- empty lines at beginning of end of buffer
- tabs
- tailing blanks

#+BEGIN_SRC emacs-lisp
(require 'whitespace)
(setq whitespace-style '(face empty tabs trailing))
(global-whitespace-mode t)
#+END_SRC

* Org
#+BEGIN_SRC emacs-lisp
(setq org-html-postamble "<p class=\"created\">Created: %T</p>")
(setq org-src-fontify-natively t)
(setq org-src-tab-acts-natively t)
(setq org-startup-folded nil) ; Start org mode expanded
(setq org-startup-with-inline-images t) ; Show images by default
(setq org-startup-indented nil)
(setq org-hide-leading-stars t)
(setq org-edit-src-content-indentation 0)
(setq org-clock-into-drawer t)
(setq org-agenda-window-setup 'current-window)
(setq org-agenda-sticky t)
(setq org-log-done 'time)
(setq org-agenda-skip-scheduled-if-done t)
(setq org-agenda-skip-deadline-if-done t)

;; Enable habit tracking in org-mode
(add-to-list 'org-modules 'org-habit)
;; Always show habits
(setq org-habit-show-habits-only-for-today nil)

;; Set up languages for running code blocks in org
(org-babel-do-load-languages
 'org-babel-load-languages '((python . t)
                             (sh . t)
                             (emacs-lisp . t)))
#+END_SRC

Line wrap mode
#+BEGIN_SRC emacs-lisp
(defun org-mode-startup-functions ()
  (toggle-word-wrap 1)
  (toggle-truncate-lines -1))

(add-hook 'org-mode-hook 'org-mode-startup-functions)
#+END_SRC

** Beautifying org-mode
Credits:
zzamboni - https://zzamboni.org/post/beautifying-org-mode-in-emacs/#step-4-configure-faces-for-specific-org-elements

Hide the markup for various emphasis'
#+BEGIN_SRC emacs-lisp
(setq org-hide-emphasis-markers t)
#+END_SRC

Replace list bullet point with nice unicode
#+BEGIN_SRC emacs-lisp
(font-lock-add-keywords
  'org-mode
  '(("^ *\\([-]\\) "
     (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))
#+END_SRC

Set up nice fonts
#+BEGIN_SRC emacs-lisp
(let* ((base-font-color  (face-foreground 'default nil 'default))
       (headline        `(:inherit    default
                          :weight     bold
                          :foreground ,base-font-color)))

  (custom-theme-set-faces
   'user
   `(org-document-title   ((t (,@headline :height 1.00 :underline t))))
   `(org-level-1          ((t (,@headline :height 1.00 :foreground "#e6194b"))))
   `(org-level-2          ((t (,@headline :height 1.00 :foreground "#3cb44b"))))
   `(org-level-3          ((t (,@headline :height 1.00 :foreground "#ffe119"))))
   `(org-level-4          ((t (,@headline :height 1.00 :foreground "#4363d8"))))
   `(org-level-5          ((t (,@headline :height 1.00 :foreground "#f58231"))))
   `(org-level-6          ((t (,@headline :height 1.00 :foreground "#911eb4"))))
   `(org-level-7          ((t (,@headline :height 1.00 :foreground "#42d4f4"))))
   `(org-level-8          ((t (,@headline :height 1.00 :foreground "#f032e6"))))
   `(org-block-background ((t (:height 1.00 :background "#222222"))))
   `(org-block            ((t (:height 1.00 :background "#222222"))))
   `(org-block-begin-line ((t (:height 1.00 :foreground "#222222" :background "#070707"))))
   `(org-block-end-line   ((t (:height 1.00 :foreground "#222222" :background "#070707"))))
))
#+END_SRC

* Mode Line
#+BEGIN_SRC emacs-lisp
(column-number-mode 1) ; show column number
(set-face-attribute 'mode-line nil ; Set active mode line colour
                    :foreground "white"
                    :background "blue")
(set-face-attribute 'mode-line-buffer-id nil ; Set buffer id colour
                    :foreground "white"
                    :background "black")
#+END_SRC

* Custom Functions
** eshell-new
Interative function to create a new instance of eshell.

#+BEGIN_SRC emacs-lisp
(defun eshell-new()
  "Open a new instance of eshell."
  (interactive)
  (eshell 'N))
#+END_SRC

** transpose-buffers
Transpose two buffers.

#+BEGIN_SRC emacs-lisp
(defun transpose-buffers (dir &optional arg)
  "Transpose the buffers in the current window and the target window
If arg is non-nil, the selected window will change to keep the source buffer
selected."
  (let ((target-window (windmove-find-other-window dir))
        (source-window (selected-window)))
    (cond ((null target-window)
           (format "No window found in dir %s" dir))
          ((and (window-minibuffer-p target-window)
                (not (minibuffer-window-active-p target-window)))
           (user-error "Minibuffer is inactive"))
          (t
           (let ((target-buffer (window-buffer target-window))
                 (source-buffer (window-buffer)))
             (set-window-buffer target-window source-buffer)
             (set-window-buffer source-window target-buffer))
           (if arg
               (select-window target-window))))))

(defun transpose-buffers-left (&optional arg)
    "Transpose buffers from current window to buffer to the left"
  (interactive)
  (transpose-buffers 'left arg))

(defun transpose-buffers-up (&optional arg)
    "Transpose buffers from current window to buffer above"
  (interactive)
  (transpose-buffers 'up arg))

(defun transpose-buffers-right (&optional arg)
    "Transpose buffers from current window to buffer to the right"
  (interactive)
  (transpose-buffers 'right arg))

(defun transpose-buffers-down (&optional arg)
    "Transpose buffers from current window to buffer below"
  (interactive)
  (transpose-buffers 'down arg))
#+END_SRC

** cast-buffer
Send a buffer to another window.

#+BEGIN_SRC emacs-lisp
(defun cast-buffer (dir &optional arg)
  "Casts the current buffer to window in direction dir, and switches current
window back to last buffer.
If arg is non-nil, the targetted window is selected."
  (let ((target-window (windmove-find-other-window dir))
        (source-buffer (window-buffer)))
    (cond ((null target-window)
           (format "No window found in dir %s" dir))
          ((and (window-minibuffer-p target-window)
                (not (minibuffer-window-active-p target-window)))
           (user-error "Minibuffer is inactive"))
          (t
           (set-window-buffer target-window source-buffer)
           (previous-buffer)
           (if arg
               (select-window target-window))))))

(defun cast-buffer-left (&optional arg)
  "Cast current buffer to the left"
  (interactive)
  (cast-buffer 'left arg))

(defun cast-buffer-up (&optional arg)
  "Cast current buffer up"
  (interactive)
  (cast-buffer 'up arg))

(defun cast-buffer-right (&optional arg)
  "Cast current buffer to the right"
  (interactive)
  (cast-buffer 'right arg))

(defun cast-buffer-down (&optional arg)
  "Cast current buffer down"
  (interactive)
  (cast-buffer 'down arg))
#+END_SRC

** duplicate-buffer
Open buffer in another window.

#+BEGIN_SRC emacs-lisp
(defun duplicate-buffer (dir &optional arg)
  "Opens the current buffer in the window in the direction dir
If arg is non-nil, the targeted window is selected"
  (let ((target-window (windmove-find-other-window dir))
        (source-buffer (window-buffer)))
    (cond ((null target-window)
           (format "No window found in dir %s" dir))
          ((and (window-minibuffer-p target-window)
                (not (minibuffer-window-active-p target-window)))
           (user-error "Minibuffer is inactive"))
          (t
           (set-window-buffer target-window source-buffer)
           (if arg
               (select-window target-window))))))

(defun duplicate-buffer-left (&optional arg)
  "Cast current buffer to the left"
  (interactive)
  (duplicate-buffer 'left arg))

(defun duplicate-buffer-up (&optional arg)
  "Cast current buffer up"
  (interactive)
  (duplicate-buffer 'up arg))

(defun duplicate-buffer-right (&optional arg)
  "Cast current buffer to the right"
  (interactive)
  (duplicate-buffer 'right arg))

(defun duplicate-buffer-down (&optional arg)
  "Cast current buffer down"
  (interactive)
  (duplicate-buffer 'down arg))
#+END_SRC

** get-string-from-file
Read a file in as a string.

#+BEGIN_SRC emacs-lisp
(defun get-string-from-file (filePath)
  "Return filePath's file content."
  (with-temp-buffer
    (insert-file-contents filePath)
    (buffer-string)))
#+END_SRC

[[http://ergoemacs.org/emacs/elisp_read_file_content.html][Credits to “Pascal J Bourguignon” and “TheFlyingDutchman"]]

** regenerate-tags
Regenerate tags using a command defined in the project root under the =.emacs=
directory.

#+BEGIN_SRC emacs-lisp
(defun regenerate-tags ()
  "use the generate-tags script in the project root to generate tags"
  (interactive)
  (cond ((projectile-project-root)
         (let* ((root-dir (projectile-project-root))
                (generate-tags-script (concat root-dir ".emacs/generate-tags"))
                (tag-command (concat ". " generate-tags-script " " root-dir))
                (result (shell-command-to-string tag-command)))
           (message result)))
        (t
         (user-error "Not in a project!"))))
#+END_SRC

** open-terminal-in-workdir
Opens a konsole in the current project root. If not in project, opens it in the
current directory.

#+BEGIN_SRC emacs-lisp
(defun open-terminal-in-workdir ()
 "Opens a terminal in the project root.
If not in a project, opens it in the current directory."
 (interactive)
 (let ((workdir (if (projectile-project-root)
                    (projectile-project-root)
                  default-directory)))
   (call-process-shell-command
    (concat "konsole --workdir " workdir) nil 0)))
#+END_SRC

** whitespace-mode
Toggle on and off whitespace trailing mode

#+BEGIN_SRC emacs-lisp
(defun toggle-whitespace-full ()
  "toggle display of more whitespace"
  (interactive)
  (whitespace-toggle-options '(lines-tail)))
#+END_SRC

** alignment functions
#+BEGIN_SRC emacs-lisp
(defun align-once-head (start end regexp)
  "Align by regex once, adding spaces to the head of the regexp"
  (interactive "r\nsAlign once head regexp: ")
  (align-regexp start end
                (concat "\\(\\s-*\\)" regexp) 1 1 nil))

(defun align-once-tail (start end regexp)
  "Align by regex once, adding spaces to the tail of the regexp"
  (interactive "r\nsAlign once tail regexp: ")
  (align-regexp start end
                (concat regexp "\\(\\s-*\\)") 1 1 nil))

(defun align-repeat-head (start end regexp)
  "Align by regex repeatedly, adding spaces to the head of the regexp"
  (interactive "r\nsAlign repeat head regexp: ")
  (align-regexp start end
                (concat "\\(\\s-*\\)" regexp) 1 1 t))

(defun align-repeat-tail (start end regexp)
  "Align by regex repeatedly, adding spaces to the tail of the regexp"
  (interactive "r\nsAlign repeat tail regexp: ")
  (align-regexp start end
                (concat regexp "\\(\\s-*\\)") 1 1 t))
#+END_SRC

** file opener functions
Some extra functions to aid in opening files

#+BEGIN_SRC emacs-lisp
(defun find-file-line (filename linenum)
  "invoke function find-file and goto-line"
  (find-file filename)
  (goto-line linenum))
#+END_SRC

The =find-file-line= function expects two args. We just therefore parse any
FILENAME:LINENUMBER string that it uses.

#+BEGIN_SRC emacs-lisp
(defun parse-file-special-syntax (file-string)
  "parses the format FILENAME:LINENUMBER"
  (let* ((file-list (split-string file-string ":"))
         (filename (car file-list))
         (line-number (string-to-number(cadr file-list))))
    (list filename line-number)))
#+END_SRC

We also want the ability to parse dirty file paths.

#+BEGIN_SRC emacs-lisp
(defun clean-file-path (file-string)
  "cleans the file path"
  (replace-regexp-in-string
   "^.*:[0-9]*\\(.*\\)$"
   ""
   file-string
   nil nil 1))
#+END_SRC

Plus we need a function to tie it all together.

#+BEGIN_SRC emacs-lisp
(defun find-file-special-syntax (file-string)
  "opens special syntax"
  (apply 'find-file-line
         (parse-file-special-syntax
          (clean-file-path file-string))))
#+END_SRC

** open-in-intellij
Helpful function to open the current buffer and line in intellij.

The complimentary command for intellij is:
#+BEGIN_SRC sh
emacsclient -n +$LINENUMBER$:$COLUMN$ $FILE$
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (defun open-in-intellij ()
    "Open the current file + line in intellij"
    (interactive)
    (let* ((file (buffer-file-name))
           (line-num (number-to-string (line-number-at-pos)))
           (command (concat "idea " file ":" line-num)))
      (shell-command command)
      (message "file opened in intellij")))
#+END_SRC

** check-project
Compile / check the project and send results to ivy-read.

Expects results in the format:

#+BEGIN_EXAMPLE
FILENAME:100 explanation
FILENAME:200 explanation
FILENAME:40can also be dirty
#+END_EXAMPLE

#+BEGIN_SRC emacs-lisp
(defun check-project ()
  "run .emacs/check-project and put results in ivy-read"
  (interactive)
  (cond ((projectile-project-root)
         (let* ((root-dir (projectile-project-root))
                (script (concat root-dir ".emacs/check-project"))
                (command (concat ". " script " " root-dir))
                (result (shell-command-to-string command)))
           (cond ((> (length result) 0)
                  (ivy-read "Check project results: "
                            (split-string result "\n")
                            :action 'find-file-special-syntax))
                 (t
                  (user-error "Check complete")))))
        (t
         (user-error "Not in a project!"))))
#+END_SRC

** show-file-path
Show the full file path as a message

#+BEGIN_SRC emacs-lisp
(defun show-file-path ()
  "Show full file path as a message"
  (interactive)
  (if buffer-file-name
      (message buffer-file-name)
    (message "No valid file path")))
#+END_SRC

** smart-clear-buffer
Clear the buffer, but with special cases for certain major modes.

#+BEGIN_SRC emacs-lisp
(defun smart-clear-buffer ()
  "Clear the current buffer. term-mode requires different command to clear."
  (interactive)
  (case major-mode
    ('term-mode (comint-clear-buffer))
    (otherwise (erase-buffer))))
#+END_SRC

** Revert project buffers
Revert all the buffers in the current project.

#+BEGIN_SRC emacs-lisp
(defun leslie/revert-project-buffers ()
  (interactive)
  (let* ((project (projectile-ensure-project (projectile-project-root)))
         (project-buffers (projectile-project-buffers project))
         (buffers (remove-if-not 'buffer-file-name project-buffers)))
    (dolist (buffer buffers)
      (with-current-buffer buffer
        (revert-buffer nil t)
        (message "Reverted: %s" buffer)))
    (message "Project buffers reverted")))
#+END_SRC
** Org Set Property
#+BEGIN_SRC emacs-lisp
(defun leslie/org-set-property (property)
  (interactive)
  (let* ((current-value (org-entry-get nil property))
         (value (read-string (format "Set property %s: " property)
                             current-value)))
    (org-entry-put nil property value)))
#+END_SRC
** Org file reference
#+BEGIN_SRC emacs-lisp
(defun leslie/org-file-reference ()
  (interactive)
  (let* ((target-file (expand-file-name
                       (ivy-read "File reference (C-M-j to done): "
                                 (mapcar (lambda (filepath)
                                           (file-relative-name
                                            filepath
                                            leslie/org-reference-directory))
                                         (directory-files-recursively
                                          leslie/org-reference-directory
                                          ".*\.org"
                                          nil)))
                       leslie/org-reference-directory))
         (org-heading (org-get-heading)))
    (org-back-to-heading)
    (org-cut-subtree)

    (find-file target-file)
    (let ((target-buffer (get-file-buffer target-file)))
      (unless (file-exists-p target-file)
        (make-directory (file-name-directory target-file) t)
        (with-current-buffer target-buffer
          (insert (concat "#+TITLE: " org-heading))
          (newline))
        (message "Created file"))
      (with-current-buffer target-buffer
        (end-of-buffer)
        (newline)
        (yank)
        (save-buffer)))))
#+END_SRC
** Buffer yank paste
#+BEGIN_SRC emacs-lisp
(setq leslie/buffer-clipboard nil)

(defun leslie/buffer-yank ()
  (interactive)
  (setq leslie/buffer-clipboard (current-buffer)))

(defun leslie/buffer-paste ()
  (interactive)
  (when leslie/buffer-clipboard
    (set-window-buffer (selected-window) leslie/buffer-clipboard)))
#+END_SRC
* Local variables
** Safe Local Eval Aliases
#+BEGIN_SRC emacs-lisp
(defun leslie/file-local-eval-safe-auto-revert ()
  (interactive)
  (auto-revert-mode t))
#+END_SRC
** Safe Local Eval List
#+BEGIN_SRC emacs-lisp
(add-to-list 'safe-local-eval-forms '(leslie/file-local-eval-safe-auto-revert))
#+END_SRC

* Package Specific
** which-key
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/which-key-3.3.1")
(require 'which-key)
(which-key-mode)
#+END_SRC

** evil
Load evil, and its dependencies in it comes with.

#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/evil-1.2.14")
(add-to-list 'load-path "~/.emacs.d/packages/evil-1.2.14/lib")
(require 'evil)
(evil-mode 1)
#+END_SRC

Rebind the ~q~ and ~quit~ commands to make more sense.

#+BEGIN_SRC emacs-lisp
(evil-ex-define-cmd "q" 'kill-this-buffer) ; :q should kill the buffer rather
                                        ; than quiting emacs
(evil-ex-define-cmd "quit" 'evil-quit-all) ; :quit to quit emacs
;; Deal with common mistakes
(evil-ex-define-cmd "W"  'evil-write)
(evil-ex-define-cmd "Wq" 'evil-save-and-close)
(evil-ex-define-cmd "WQ" 'evil-save-and-close)

(evil-define-command evil-save-and-kill-buffer (file &optional bang)
  "Save current buffer and close buffer.
Override for :wq"
  :repeat nil
  (interactive "<f><!>")
  (evil-write nil nil nil file bang)
  (kill-this-buffer))
(evil-ex-define-cmd "wq" 'evil-save-and-kill-buffer)
#+END_SRC

** evil-leader
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/evil-leader-0.4.3")
(require 'evil-leader)
(global-evil-leader-mode)
#+END_SRC

** evil-org
#+BEGIN_SRC emacs-lisp
(add-to-list
 'load-path
 "~/.emacs.d/packages/evil-org-mode-b6d652a9163d3430a9e0933a554bdbee5244bbf6")
(require 'evil-org)
(add-hook 'org-mode-hook 'evil-org-mode)
(evil-org-set-key-theme '(navigation insert textobjects additional calendar shift todo heading))
(add-hook 'org-mode-hook
          (lambda ()
          (setq evil-auto-indent nil)))
(require 'evil-org-agenda)
(evil-org-agenda-set-keys)
#+END_SRC

** evil-numbers
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/evil-numbers-0.4")
(require 'evil-numbers)
#+END_SRC

** evil-quickscope
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/evil-quickscope-0.1.4")
(require 'evil-quickscope)
(global-evil-quickscope-mode 1)
#+END_SRC

** ivy / swiper / counsel
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/swiper-0.11.0")
(require 'ivy)
(require 'swiper)
(require 'counsel)
(setq ivy-use-virtual-buffers t)
(setq ivy-count-format "(%d/%d) ")

;; Setting up more ivy completion
(add-to-list 'ivy-completing-read-handlers-alist '(org-tags-view . completing-read-default))
(add-to-list 'ivy-completing-read-handlers-alist '(org-refile . completing-read-default))
(setq org-outline-path-complete-in-steps nil)
(setq org-completion-use-ido nil)
#+END_SRC

** projectile
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/projectile-2.0.0")
(require 'projectile)
(projectile-mode +1)
(setq projectile-project-search-path '("~/projects/")) ; where the projects are
(setq projectile-completion-system 'ivy)
#+END_SRC

** counsel-projectile
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/counsel-projectile-0.3.0")
(require 'counsel-projectile)
(setq counsel-projectile-grep-initial-input '(ivy-thing-at-point))
                                        ; this required a fix that was taken
                                        ; from commit a07ddc8
#+END_SRC

** ranger
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/ranger.el-0.9.8.5")
(require 'ranger)
#+END_SRC

** rainbow-delimiters
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/rainbow-delimiters-2.1.3")
(require 'rainbow-delimiters)
#+END_SRC

Set the colours to be as distinct as possible.

#+BEGIN_SRC emacs-lisp
(set-face-attribute 'rainbow-delimiters-depth-1-face nil :foreground "#e6194b")
(set-face-attribute 'rainbow-delimiters-depth-2-face nil :foreground "#3cb44b")
(set-face-attribute 'rainbow-delimiters-depth-3-face nil :foreground "#ffe119")
(set-face-attribute 'rainbow-delimiters-depth-4-face nil :foreground "#4363d8")
(set-face-attribute 'rainbow-delimiters-depth-5-face nil :foreground "#f58231")
(set-face-attribute 'rainbow-delimiters-depth-6-face nil :foreground "#911eb4")
(set-face-attribute 'rainbow-delimiters-depth-7-face nil :foreground "#42d4f4")
(set-face-attribute 'rainbow-delimiters-depth-8-face nil :foreground "#f032e6")
(set-face-attribute 'rainbow-delimiters-depth-9-face nil :foreground "#bfef45")
(set-face-attribute 'rainbow-delimiters-unmatched-face nil
                    :background "#ff0000"
                    :foreground "#ffffff")
#+END_SRC

** beacon
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/beacon-1.3.4")
(require 'beacon)
(beacon-mode 1)
#+END_SRC

** json-mode
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/json-snatcher-1.0.0")
(add-to-list 'load-path "~/.emacs.d/packages/json-reformat-0.0.6")
(add-to-list 'load-path "~/.emacs.d/packages/json-mode-1.7.0")
(require 'json-mode)
#+END_SRC

** telephone-line
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/telephone-line-0.4")
(require 'telephone-line)
#+END_SRC

Telephone line customization.

#+BEGIN_SRC emacs-lisp
(setq telephone-line-lhs
      '((evil   . (telephone-line-evil-tag-segment))
        (accent . (telephone-line-vc-segment
                   telephone-line-erc-modified-channels-segment
                   telephone-line-process-segment))
        (nil    . (telephone-line-buffer-segment))))
(setq telephone-line-rhs
      '((nil    . (telephone-line-misc-info-segment))
        (accent . (telephone-line-major-mode-segment))
        (evil   . (telephone-line-airline-position-segment))))
(telephone-line-mode 1)
#+END_SRC

** nlinum-relative
nlinum is a dependency.

Delay is kinda required or else files with loads of lines tend to lag.

#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/nlinum-1.8.1")
(require 'nlinum)

(add-to-list
 'load-path
 "~/.emacs.d/packages/nlinum-relative-5b9950c97ba79a6f0683e38b13da23f39e01031c")
(require 'nlinum-relative)
(nlinum-relative-setup-evil)
(global-nlinum-relative-mode)
(setq nlinum-relative-redisplay-delay 0.2) ; delay
(setq nlinum-relative-current-symbol "") ; e.g. "->"
                                        ; "" for display current line number
(setq nlinum-relative-offset 0)          ; 1 if you want 0, 2, 3...
#+END_SRC

I want relative numbers to display when in evil operator mode.

#+BEGIN_SRC emacs-lisp
(add-hook 'evil-operator-state-entry-hook
          (lambda () (when (bound-and-true-p nlinum-relative-mode)
                       (nlinum-relative-on))))
(add-hook 'evil-operator-state-exit-hook
          (lambda () (when (bound-and-true-p nlinum-relative-mode)
                       (nlinum-relative-off))))
#+END_SRC

** diff-hl
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/diff-hl-1.8.6")
(require 'diff-hl)
(require 'diff-hl-flydiff)
(global-diff-hl-mode)
(diff-hl-flydiff-mode) ; Don't wait for save to calcualte diff
#+END_SRC

** erlang
#+BEGIN_SRC emacs-lisp
(when leslie/enable-erlang
  (setq load-path (cons  "~/erl_rel/18.3/lib/tools-2.8.3/emacs" load-path))
  (setq erlang-root-dir "~/erl_rel/18.3")
  (setq exec-path (cons "~/erl_rel/18.3/bin" exec-path))
  (require 'erlang-start)
  (require 'erlang-flymake))
#+END_SRC

** term mode
Set colours to be more readable

#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'term
  (set-face-attribute 'term-color-green   nil :foreground "#55ff55")
  (set-face-attribute 'term-color-blue    nil :foreground "#5555ff")
  (set-face-attribute 'term-color-red     nil :foreground "#ff5555")
  (set-face-attribute 'term-color-magenta nil :foreground "#ff55ff")
  (set-face-attribute 'term-color-cyan    nil :foreground "#55ffff")
  (set-face-attribute 'term-color-yellow  nil :foreground "#ffff55"))
#+END_SRC

Disable line number mode for term mode.
Requires this hacky double add hook thing because the
global-nlinum-relative-mode hook is run after the term-mode-hook

#+BEGIN_SRC emacs-lisp
(defun setup-term-mode ()
  "Counteract global nlinum mode"
  (add-hook 'after-change-major-mode-hook
            (lambda () (nlinum-mode 0))
            :append :local))

(add-hook 'term-mode-hook 'setup-term-mode)
#+END_SRC

Set normal / visual / operator mode to be line mode.
Set insert mode to be char mode.

=ignore-errors= added because this crashes term-mode from starting up.
I don't know why.

#+BEGIN_SRC emacs-lisp
(defun term-mode-normal-visual-operator-switch ()
  (when (equal major-mode 'term-mode) (ignore-errors (term-line-mode))))
(defun term-mode-insert-switch ()
  (when (equal major-mode 'term-mode) (ignore-errors (term-char-mode))))

(add-hook 'evil-normal-state-entry-hook 'term-mode-normal-visual-operator-switch)
(add-hook 'evil-visual-state-entry-hook 'term-mode-normal-visual-operator-switch)
(add-hook 'evil-operator-state-entry-hook 'term-mode-normal-visual-operator-switch)
(add-hook 'evil-insert-state-entry-hook 'term-mode-insert-switch)
#+END_SRC

Have the term buffer close automatically when the process has finished.

Source: https://oremacs.com/2015/01/01/three-ansi-term-tips/

#+BEGIN_SRC emacs-lisp
(defun auto-exit-term-exec-hook ()
  (let* ((buff (current-buffer))
         (proc (get-buffer-process buff)))
    (set-process-sentinel
     proc
     `(lambda (process event)
        (if (string= event "finished\n")
            (kill-buffer ,buff))))))

(add-hook 'term-exec-hook 'auto-exit-term-exec-hook)
#+END_SRC

** general
#+BEGIN_SRC emacs-lisp
(add-to-list
 'load-path
 "~/.emacs.d/packages/general-2d2dd1d532fa75c1ed0c010d50e817ce43e58066/")
(require 'general)
(general-auto-unbind-keys)
#+END_SRC

* Keybindings
** Aliases
To keep the code nice and clean.
#+BEGIN_SRC emacs-lisp
(defun leslie/alias-text-scale-down () (interactive) (text-scale-adjust -1))
(defun leslie/alias-text-scale-up   () (interactive) (text-scale-adjust +1))

(defun leslie/alias-search-buffer () (interactive) (swiper (ivy-thing-at-point)))

(defun leslie/alias-transpose-buffer-left  () (interactive) (transpose-buffers-left t))
(defun leslie/alias-transpose-buffer-down  () (interactive) (transpose-buffers-down t))
(defun leslie/alias-transpose-buffer-up    () (interactive) (transpose-buffers-up t))
(defun leslie/alias-transpose-buffer-right () (interactive) (transpose-buffers-right t))

(defun leslie/alias-cast-buffer-left  () (interactive) (cast-buffer-left t))
(defun leslie/alias-cast-buffer-down  () (interactive) (cast-buffer-down t))
(defun leslie/alias-cast-buffer-up    () (interactive) (cast-buffer-up t))
(defun leslie/alias-cast-buffer-right () (interactive) (cast-buffer-right t))

(defun leslie/alias-duplicate-buffer-left  () (interactive) (duplicate-buffer-left t))
(defun leslie/alias-duplicate-buffer-down  () (interactive) (duplicate-buffer-down t))
(defun leslie/alias-duplicate-buffer-up    () (interactive) (duplicate-buffer-up t))
(defun leslie/alias-duplicate-buffer-right () (interactive) (duplicate-buffer-right t))

(defun leslie/alias-erlang-find-tag () (interactive) (erlang-find-tag (erlang-find-tag-default)))

(defun leslie/alias-bash-shell () (interactive) (ansi-term "/bin/bash"))
(defun leslie/alias-clip-shell () (interactive) (ansi-term "/usr/bin/clisp"))
(defun leslie/alias-python-shell () (interactive) (ansi-term "/usr/bin/python"))

(defun leslie/alias-org-force-publish () (interactive) (org-publish-current-project t))

(defun leslie/alias-org-set-property-category () (interactive) (leslie/org-set-property "CATEGORY"))
#+END_SRC

** Helper Functions
#+BEGIN_SRC emacs-lisp
(setq leslie/p1-prefix-normal   "C-M-S-")
(setq leslie/p1-prefix-special  "C-M-")
(setq leslie/p1-prefix-standard "M-f")

(setq leslie/p2-prefix-normal   "C-S-")
(setq leslie/p2-prefix-special  "C-")
(setq leslie/p2-prefix-standard "M-d")

(setq leslie/p3-prefix-normal   "C-M-")
(setq leslie/p3-prefix-special  "C-M-")
(setq leslie/p3-prefix-standard "M-s")

(setq leslie/p4-prefix-normal   "M-")
(setq leslie/p4-prefix-special  "M-")
(setq leslie/p4-prefix-standard "M-a")

(defun leslie/p1 (key command description &optional keymap)
  (let* ((prefix-normal   leslie/p1-prefix-normal)
         (prefix-special  leslie/p1-prefix-special)
         (standard-prefix leslie/p1-prefix-standard)
         (prefix-key (cond ((string= key ";") (concat prefix-special ":"))
                           ((string= key "-") (concat prefix-special "_"))
                           ((string= key "=") (concat prefix-special "+"))
                           ((string= key ",") (concat prefix-special "<"))
                           ((string= key ".") (concat prefix-special ">"))
                           ((string= key "/") (concat prefix-special "?"))
                           (t (concat prefix-normal key))))
         (standard-prefix-key (concat standard-prefix " " key)))
    (leslie/set-keys prefix-key standard-prefix-key command description keymap)))

(defun leslie/p2 (key command description &optional keymap)
  (let* ((prefix-normal   leslie/p2-prefix-normal)
         (prefix-special  leslie/p2-prefix-special)
         (standard-prefix leslie/p2-prefix-standard)
         (prefix-key (cond (t (concat prefix-normal key))))
         (standard-prefix-key (concat standard-prefix " " key)))
    (leslie/set-keys prefix-key standard-prefix-key command description keymap)))

(defun leslie/p3 (key command description &optional keymap)
  (let* ((prefix-normal   leslie/p3-prefix-normal)
         (prefix-special  leslie/p3-prefix-special)
         (standard-prefix leslie/p3-prefix-standard)
         (prefix-key (cond (t (concat prefix-normal key))))
         (standard-prefix-key (concat standard-prefix " " key)))
    (leslie/set-keys prefix-key standard-prefix-key command description keymap)))

(defun leslie/p4 (key command description &optional keymap)
  (let* ((prefix-normal   leslie/p4-prefix-normal)
         (prefix-special  leslie/p4-prefix-special)
         (standard-prefix leslie/p4-prefix-standard)
         (prefix-key (cond (t (concat prefix-normal (upcase (substring key 0 1)) (substring key 1)))))
         (standard-prefix-key (concat standard-prefix " " key)))
    (leslie/set-keys prefix-key standard-prefix-key command description keymap)))

(defun leslie/set-keys (prefix-key standard-prefix-key command description &optional keymap)
  (cond (command
         (leslie/set-key prefix-key command description keymap)
         (leslie/set-key standard-prefix-key command description keymap))
        (t
         (leslie/set-prefix prefix-key description keymap)
         (leslie/set-prefix standard-prefix-key description keymap))))

(defun leslie/set-prefix (key description &optional keymap)
  (cond (keymap
         (general-define-key
           :keymaps keymap
           :states '(normal insert visual operator motion emacs)
           key (list :ignore t :which-key description)))
        (t
         (general-define-key
           :states '(normal insert visual operator motion emacs)
           key (list :ignore t :which-key description)))))

(defun leslie/set-key (key command description &optional keymap)
  (cond (keymap
         (general-define-key
          :keymaps keymap
          :states '(normal insert visual operator motion emacs)
          key (list command :which-key description)))
        (t
         (general-define-key 
          :states '(normal insert visual operator motion emacs)
          key (list command :which-key description)))))
#+END_SRC

** Unbinding Keys
#+BEGIN_SRC emacs-lisp
;(general-unbind 
;  '(normal insert visual operator)
;  '(global-map org-mode-map evil-org-mode-map)
  ;"C-S-h"
  ;"C-S-j"
  ;"C-S-k"
  ;"C-S-l"
  ;"C-M-S-d"
;)

;; Prevent these from appearing in the standard keymap
(global-unset-key (kbd "M-s ESC"))
(global-unset-key (kbd "M-s ."))
(global-unset-key (kbd "M-s _"))
(global-unset-key (kbd "M-s o"))
(global-unset-key (kbd "M-s w"))
#+END_SRC

** P1
#+BEGIN_SRC emacs-lisp
;;FUN      KEY    FUNCTION                              DESCRIPTION                           MODE
(leslie/p1 ";"    'counsel-M-x                          "M-x")
(leslie/p1 "q"    'kill-this-buffer                     "kill buffer")
(leslie/p1 "d"    'evil-goto-definition                 "goto definition")
(leslie/p1 "d"    'leslie/alias-erlang-find-tag         "goto definition"                     'erlang-mode-map)
(leslie/p1 "d"    'org-open-at-point                    "open link"                           'org-mode-map)
(leslie/p1 "c"    'delete-window                        "close window")
(leslie/p1 "c"    'ranger-disable                       "close ranger"                        'ranger-mode-map)
(leslie/p1 "h"    'windmove-left                        "win left")
(leslie/p1 "j"    'windmove-down                        "win down")
(leslie/p1 "k"    'windmove-up                          "win up")
(leslie/p1 "l"    'windmove-right                       "wind right")
(leslie/p1 "-"    'leslie/alias-text-scale-down         "text scale down")
(leslie/p1 "="    'leslie/alias-text-scale-up           "text scale up")
(leslie/p1 ","    'previous-buffer                      "prev buffer")
(leslie/p1 "."    'next-buffer                          "next buffer")
(leslie/p1 "/"    'leslie/alias-search-buffer           "search buffer")
(leslie/p1 "f"    'nil                                  "files")
(leslie/p1 "f f"  'counsel-find-file                    "find file")
(leslie/p1 "f r"  'counsel-recentf                      "find recent file")
(leslie/p1 "f b"  'ivy-switch-buffer                    "buffers")
(leslie/p1 "f h"  'org-html-export-to-html              "export to html"                      'org-mode-map)
(leslie/p1 "f d"  'dired-create-directory               "create directory"                    'ranger-mode-map)
(leslie/p1 "w"    'nil                                  "windows")
(leslie/p1 "w v"  'split-window-below                   "split vertical")
(leslie/p1 "w h"  'split-window-right                   "split horizontal")
(leslie/p1 "w z"  'maximize-window                      "maximize")
(leslie/p1 "w o"  'delete-other-windows                 "delete other windows")
(leslie/p1 "w e"  'balance-windows                      "balance windows")
(leslie/p1 "w r"  'revert-buffer                        "reload from disk")
(leslie/p1 "b"    'nil                                  "buffers")
(leslie/p1 "b b"  'ivy-switch-buffer                    "switch buffers")
(leslie/p1 "b o"  'open-in-new-config                   "open buffer in a new window config")
(leslie/p1 "b r"  'rename-buffer                        "rename buffer")
(leslie/p1 "b x"  'smart-clear-buffer                   "clear buffer")
(leslie/p1 "b f"  'show-file-path                       "show file path")
(leslie/p1 "b y"  'leslie/buffer-yank                   "yank buffer")
(leslie/p1 "b p"  'leslie/buffer-paste                  "paste buffer")
(leslie/p1 "b t"  'nil                                  "transpose buffers")
(leslie/p1 "b th" 'leslie/alias-transpose-buffer-left   "transpose windows left")
(leslie/p1 "b tj" 'leslie/alias-transpose-buffer-down   "transpose windows down")
(leslie/p1 "b tk" 'leslie/alias-transpose-buffer-up     "transpose windows up")
(leslie/p1 "b tl" 'leslie/alias-transpose-buffer-right  "transpose windows right")
(leslie/p1 "b c"  'nil                                  "cast buffers")
(leslie/p1 "b ch" 'leslie/alias-cast-buffer-left        "cast buffer left")
(leslie/p1 "b cj" 'leslie/alias-cast-buffer-down        "cast buffer down")
(leslie/p1 "b ck" 'leslie/alias-cast-buffer-up          "cast buffer up")
(leslie/p1 "b cl" 'leslie/alias-cast-buffer-right       "cast buffer right")
(leslie/p1 "b d"  'nil                                  "duplicate buffers")
(leslie/p1 "b dh" 'leslie/alias-duplicate-buffer-left   "duplicate buffer left")
(leslie/p1 "b dj" 'leslie/alias-duplicate-buffer-down   "duplicate buffer down")
(leslie/p1 "b dk" 'leslie/alias-duplicate-buffer-up     "duplicate buffer up")
(leslie/p1 "b dl" 'leslie/alias-duplicate-buffer-right  "duplicate buffer right")
(leslie/p1 "t"    'nil                                  "toggles")
(leslie/p1 "t w"  'whitespace-mode                      "toggle whitespace display")
(leslie/p1 "t W"  'toggle-whitespace-full               "toggle whitespace full")
(leslie/p1 "t p"  'projectile-mode                      "toggle projectile mode")
(leslie/p1 "t f"  'font-lock-mode                       "toggle auto font formatting")
(leslie/p1 "t c"  'comment-line                         "toggle comment line")
(leslie/p1 "t r"  'rainbow-delimiters-mode              "toggle rainbow delimiters")
(leslie/p1 "t R"  'auto-revert-mode                     "toggle auto revert mode")
(leslie/p1 "t l"  'nlinum-mode                          "toggle relative line numbers")
(leslie/p1 "t h"  'hl-line-mode                         "toggle highight line mode")
(leslie/p1 "t i"  'org-toggle-inline-images             "toggle images"                       'org-mode-map)
(leslie/p1 "t t"  'nil                                  "tables"                              'org-mode-map)
(leslie/p1 "t tr" 'org-table-toggle-coordinate-overlay  "toggle table coords"                 'org-mode-map)
(leslie/p1 "t h"  'ranger-toggle-dotfiles               "toggle hidden"                       'ranger-mode-map)
(leslie/p1 "e"    'nil                                  "edits")
(leslie/p1 "e c"  'ispell                               "spell check")
(leslie/p1 "e f"  'nil                                  "formatting")
(leslie/p1 "e fr" 'fill-region                          "fill region")
(leslie/p1 "e fp" 'fill-paragraph                       "fill paragraph")
(leslie/p1 "e fi" 'indent-region                        "indent region")
(leslie/p1 "e fb" 'json-mode-beautify                   "json beautify"                       'json-mode-map)
(leslie/p1 "e a"  'nil                                  "align")
(leslie/p1 "e ah" 'align-once-head                      "regex ahead of match")
(leslie/p1 "e aH" 'align-repeat-head                    "regex ahead of match repeatedly")
(leslie/p1 "e at" 'align-once-tail                      "regex to tail of match")
(leslie/p1 "e aT" 'align-repeat-tail                    "regex to tail of match repeatedly")
(leslie/p1 "e l"  'org-insert-link                      "edit link"                           'org-mode-map)
(leslie/p1 "e s"  'org-sort                             "sort"                                'org-mode-map)
(leslie/p1 "e aa" 'erlang-align-arrows                  "align arrows"                        'erlang-mode-map)
(leslie/p1 "e j"  'erlang-generate-new-clause           "new clause"                          'erlang-mode-map)
(leslie/p1 "e d"  'erlang-clone-arguments               "duplicate arguments"                 'erlang-mode-map)
(leslie/p1 "e i"  'erlang-indent-region                 "indent region"                       'erlang-mode-map)
(leslie/p1 "r"    'nil                                  "registers")
(leslie/p1 "r p"  'nil                                  "positions")
(leslie/p1 "r py" 'point-to-register                    "yank current position to register")
(leslie/p1 "r pp" 'jump-to-register                     "goto register position")
(leslie/p1 "r t"  'nil                                  "text")
(leslie/p1 "r ty" 'copy-to-register                     "yank text to register")
(leslie/p1 "r tp" 'insert-register                      "paste text register")
(leslie/p1 "r ta" 'append-to-register                   "append text to register")
(leslie/p1 "r tb" 'prepend-to-register                  "prepend text to register (before)")
(leslie/p1 "r r"  'nil                                  "rectangle")
(leslie/p1 "r ry" 'copy-rectangle-to-register           "yank rectangle to register")
(leslie/p1 "r rp" 'insert-register                      "paste rectangle from register")
(leslie/p1 "r n"  'nil                                  "numbers")
(leslie/p1 "r ny" 'number-to-register                   "yank number to register")
(leslie/p1 "r np" 'insert-register                      "paste number from register")
(leslie/p1 "r ni" 'increment-register                   "increment register with number")
(leslie/p1 "o"    'nil                                  "applications")
(leslie/p1 "o r"  'ranger                               "ranger")
(leslie/p1 "o i"  'open-in-intellij                     "open in intellij")
(leslie/p1 "a t"  'nil                                  "terminals")
(leslie/p1 "o tt" 'leslie/alias-bash-shell              "bash")
(leslie/p1 "o te" 'erlang-shell                         "erlang")
(leslie/p1 "o tc" 'leslie/alias-clisp-shell             "clisp")
(leslie/p1 "o tp" 'leslie/alias-python-shell            "python")
(leslie/p1 "v"    'nil                                  "version control")
(leslie/p1 "v a"  'vc-annotate                          "annotate")
(leslie/p1 "v d"  'vc-diff                              "diff")
(leslie/p1 "v b"  'vc-retrieve-tag                      "change branch")
(leslie/p1 "p"    'nil                                  "projects")
(leslie/p1 "p ?"  'projectile-command-map               "other")
(leslie/p1 "p p"  'counsel-projectile-switch-project    "switch project")
(leslie/p1 "p g"  'counsel-projectile-grep              "find instances in project")
(leslie/p1 "p f"  'counsel-projectile-find-file         "find project file")
(leslie/p1 "p s"  'org-store-link                       "copy link")
(leslie/p1 "p i"  'org-insert-link                      "insert link")
(leslie/p1 "p t"  'regenerate-tags                      "regenerate tags")
(leslie/p1 "p r"  'leslie/revert-project-buffers        "revert project buffers")
(leslie/p1 "p c"  'check-project                        "check / compile project")
(leslie/p1 "p b"  'projectile-switch-to-buffer          "switch project buffer")
(leslie/p1 "p o"  'org-publish-current-project          "org publish project"                 'org-mode-map)
(leslie/p1 "p O"  'leslie/alias-org-force-publish       "force org publish project"           'org-mode-map)
(leslie/p1 "p w"  'org-save-all-org-buffers             "save all org buffers"                'org-mode-map)
#+END_SRC

** P2
#+BEGIN_SRC emacs-lisp
;;         KEY    FUNCTION                              DESCRIPTION                           MODE
(leslie/p2 "h"    'shrink-window-horizontally           "shrink horz"                         'override)
(leslie/p2 "j"    'enlarge-window                       "enlarge vert"                        'override)
(leslie/p2 "k"    'shrink-window                        "shrink vert"                         'override)
(leslie/p2 "l"    'enlarge-window-horizontally          "enlarge horz"                        'override)
#+END_SRC

** P3
#+BEGIN_SRC emacs-lisp
;;         KEY    FUNCTION                              DESCRIPTION                           MODE
(leslie/p3 "h"    'evil-jump-backward                   "jump back")
(leslie/p3 "l"    'evil-jump-forward                    "jump forward")
(leslie/p3 "f"    'nil                                  "frames")
(leslie/p3 "f R"  'set-frame-title                      "rename frame")
(leslie/p3 "f o"  'pop-out-config-to-new-frame          "pop out to frame")
(leslie/p3 "f c"  'make-frame                           "create new frame")
#+END_SRC

** P4
#+BEGIN_SRC emacs-lisp
;;         KEY    FUNCTION                              DESCRIPTION                           MODE
(leslie/p4 "k"    'outline-previous-visible-heading     "prev visible heading")
(leslie/p4 "j"    'outline-next-visible-heading         "next visible heading")
(leslie/p4 "h"    'outline-backward-same-level          "back same level")
(leslie/p4 "l"    'outline-forward-same-level           "forward same level")
(leslie/p4 "u"    'outline-up-heading                   "up heading")
(leslie/p4 "a"    'org-agenda                           "agenda")
(leslie/p4 "x"    'nil                                  "none")
(leslie/p4 "x"    'org-toggle-checkbox                  "toggle checkbox"                     'org-mode-map)
(leslie/p4 "s"    'org-schedule                         "schedule"                            'org-mode-map)
(leslie/p4 "d"    'org-deadline                         "deadline"                            'org-mode-map)
(leslie/p4 "c"    'org-columns                          "columns"                             'org-mode-map)
(leslie/p4 "t"    'nil                                  "tables"                              'org-mode-map)
(leslie/p4 "t c"  'org-table-create-or-convert-from-region "create / convert table"           'org-mode-map)
(leslie/p4 "t d"  'nil                                  "delete"                              'org-mode-map)
(leslie/p4 "t dc" 'org-table-delete-column              "delete column"                       'org-mode-map)
(leslie/p4 "t dr" 'org-table-kill-row                   "delete row"                          'org-mode-map)
(leslie/p4 "t i"  'nil                                  "insert"                              'org-mode-map)
(leslie/p4 "t ic" 'org-table-insert-column              "insert column"                       'org-mode-map)
(leslie/p4 "t ir" 'org-table-insert-row                 "insert row"                          'org-mode-map)
(leslie/p4 "t ih" 'org-table-insert-hline               "insert horizontal line"              'org-mode-map)
(leslie/p4 "i"    'org-clock-in                         "clock in"                            'org-mode-map)
(leslie/p4 "o"    'org-clock-out                        "clock out"                           'org-mode-map)
(leslie/p4 "m"    'org-archive-subtree-default          "archive"                             'org-mode-map)
(leslie/p4 "q"    'org-set-tags-command                 "set tags"                            'org-mode-map)
(leslie/p4 "r"    'org-refile                           "refile"                              'org-mode-map)
(leslie/p4 "f"    'leslie/org-file-reference            "file reference"                      'org-mode-map)
(leslie/p4 "p"    'nil                                  "property"                            'org-mode-map)
(leslie/p4 "p p"  'org-set-property                     "set property (free)"                 'org-mode-map)
(leslie/p4 "p c"  'leslie/alias-org-set-property-category "set category"                      'org-mode-map)
(leslie/p4 "v"    'nil                                  "insert items"                        'org-mode-map)
(leslie/p4 "v d"  'org-time-stamp                       "time stamp"                          'org-mode-map)
#+END_SRC

** Other
*** Non-P Bindings
#+BEGIN_SRC emacs-lisp

#+END_SRC

*** Help
#+BEGIN_SRC emacs-lisp
(general-define-key
  "C-h v" 'counsel-describe-variable
  "C-h f" 'counsel-describe-function
)
#+END_SRC
