#+STARTUP: overview
#+TITLE: emacs.d config

* Better defaults
** Start Up
#+BEGIN_SRC emacs-lisp
(server-start) ; Start emacs server
;(desktop-save-mode 1) ; Save session and restore on next launch
#+END_SRC

** UI
#+BEGIN_SRC emacs-lisp
(setq inhibit-startup-screen t) ; inhibit useless and old-school startup screen
(setq ring-bell-function 'ignore) ; silent bell when you make a mistake
(setq-default frame-title-format '("%b - Emacs")) ; set the emacs title.
                                        ; overrides the old "emacs@HOST" title
(set-frame-font "Liberation Mono 9" t t)
(menu-bar-mode -1)

;; Disable these in termux mode
(defvar circ/termux-p 'nil)
(unless circ/termux-p
  (mouse-avoidance-mode 'animate)
  (tool-bar-mode -1)
  (scroll-bar-mode -1))
(when circ/termux-p
  (defun circ/termux-open (args)
    (interactive)
    (if (not (listp args))
        (setq args (list args)))
    (apply 'call-process "termux-open" nil nil nil args))
  (defun circ/browse-url-browser-function (url &rest args)
    (interactive)
    (circ/termux-open url))

  (setq browse-url-browser-function
    'circ/browse-url-browser-function))

(load-theme 'wheatgrass)
; Split vertically by default
(setq split-width-threshold 160)
(setq split-height-threshold 100)
(setq-default fill-column 80)
(setq calendar-week-start-day 1)

;; Keep point in same position relative to window when scrolling
(setq scroll-preserve-screen-position t)

;; Don't use proportional fonts in eww
(setq shr-use-fonts nil)
#+END_SRC

** Tab Behaviour
#+BEGIN_SRC emacs-lisp
(setq-default indent-tabs-mode nil) ; don't insert tabs
(setq-default tab-width 4) ; self-documenting
(setq indent-line-function 'insert-tab)
#+END_SRC

** Backup and autosave locations
#+BEGIN_SRC emacs-lisp
(setq auto-save-visited-file-name t)
(setq auto-save-default nil)
(setq backup-directory-alist '((".*" . "~/.emacs.d/backup")))
(setq auto-save-file-name-transforms '((".*" "~/.emacs.d/autosave/" t)))
#+END_SRC

** Default major mode
#+BEGIN_SRC emacs-lisp
(setq-default major-mode 'org-mode)
#+END_SRC

* Whitespace
Force it on all the time.

Highlights:
- face visualisation
- empty lines at beginning of end of buffer
- tabs
- tailing blanks

#+BEGIN_SRC emacs-lisp
(require 'whitespace)
(setq whitespace-style '(face empty tabs trailing))
(global-whitespace-mode t)
#+END_SRC

* Org
#+BEGIN_SRC emacs-lisp
(setq org-html-postamble "<p class=\"created\">Created: %T</p>")
(setq org-src-fontify-natively t)
(setq org-src-tab-acts-natively t)
(setq org-startup-folded nil) ; Start org mode expanded
(setq org-startup-with-inline-images t) ; Show images by default
(setq org-startup-indented nil)
(setq org-hide-leading-stars t)
(setq org-edit-src-content-indentation 0)
(setq org-clock-into-drawer "CLOCK")
(setq org-use-property-inheritance t)
(setq org-clock-mode-line-total 'current)
(setq org-agenda-window-setup 'current-window)
(setq org-agenda-sticky t)
(setq org-log-done 'time)
(setq org-agenda-skip-scheduled-if-done t)
(setq org-agenda-skip-deadline-if-done t)
(setq org-src-window-setup 'current-window)
(setq org-time-stamp-rounding-minutes '(1 1))
(setq org-clock-out-when-done nil)
(setq org-log-into-drawer "LOGBOOK")

;(setq org-clock-persist 'clock)
;(org-clock-persistence-insinuate)

(add-to-list 'org-link-frame-setup '(file . find-file))

;; Enable habit tracking in org-mode
(require 'org-habit)
(add-to-list 'org-modules 'org-habit)
(add-to-list 'org-modules 'org-drill)
;(require 'org-drill)
;; Don't show any habits in the agenda, there is a dedicated section for that.
(setq org-habit-show-habits nil)
(setq org-habit-show-habits-only-for-today nil)
(setq org-habit-show-all-today nil)

;; Set up languages for running code blocks in org
;; In version 9.0.9, ob-sh was renamed to ob-shell
(org-babel-do-load-languages
 'org-babel-load-languages
 (cond
  ((version< org-version "9.0.9")
   '((python . t)
     (sh . t)
     (emacs-lisp . t)))
  (t
   '((python . t)
     (shell . t)
     (emacs-lisp . t)))))

;; Set clock checks
(setq org-agenda-clock-consistency-checks
      (quote (:max-duration "4:00"
              :min-duration 0
              :max-gap 0
              :gap-ok-around ("4:00"))))
#+END_SRC

Line wrap mode
#+BEGIN_SRC emacs-lisp
(defun org-mode-startup-functions ()
  (toggle-word-wrap 1)
  (toggle-truncate-lines -1))

(add-hook 'org-mode-hook 'org-mode-startup-functions)

(defun org-agenda-mode-startup-functions ()
  (hl-line-mode +1)
  (evil-quickscope-mode 0))

(add-hook 'org-agenda-mode-hook 'org-agenda-mode-startup-functions)
(add-hook 'org-agenda-mode-hook 'circ/disable-evil-quickscope-mode)
#+END_SRC

Fix the =\emsp= bug in clock tables.
#+BEGIN_SRC emacs-lisp
(defun circ/org-clocktable-indent-string (level)
  (if (= level 1)
      ""
    (let ((str "^"))
      (while (> level 2)
        (setq level (1- level)
              str (concat str "--")))
      (concat str "-> "))))

(advice-add 'org-clocktable-indent-string :override
            #'circ/org-clocktable-indent-string)
#+END_SRC

** Beautifying org-mode
Credits:
zzamboni - https://zzamboni.org/post/beautifying-org-mode-in-emacs/#step-4-configure-faces-for-specific-org-elements

Hide the markup for various emphasis'
#+BEGIN_SRC emacs-lisp
(setq org-hide-emphasis-markers t)
#+END_SRC

Replace list bullet point with nice unicode
#+BEGIN_SRC emacs-lisp
(font-lock-add-keywords
  'org-mode
  '(("^ *\\([-]\\) "
     (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "â€¢"))))))
#+END_SRC

Set up nice fonts
#+BEGIN_SRC emacs-lisp
(let* ((base-font-color  (face-foreground 'default nil 'default))
       (headline        `(:inherit    default
                          :weight     bold
                          :foreground ,base-font-color)))

  (custom-theme-set-faces
   'user
   `(org-document-title   ((t (,@headline :height 1.00 :underline t))))
   `(org-level-1          ((t (,@headline :height 1.00 :foreground "#e6194b"))))
   `(org-level-2          ((t (,@headline :height 1.00 :foreground "#3cb44b"))))
   `(org-level-3          ((t (,@headline :height 1.00 :foreground "#ffe119"))))
   `(org-level-4          ((t (,@headline :height 1.00 :foreground "#4363d8"))))
   `(org-level-5          ((t (,@headline :height 1.00 :foreground "#f58231"))))
   `(org-level-6          ((t (,@headline :height 1.00 :foreground "#911eb4"))))
   `(org-level-7          ((t (,@headline :height 1.00 :foreground "#42d4f4"))))
   `(org-level-8          ((t (,@headline :height 1.00 :foreground "#f032e6"))))
   `(org-block-background ((t (:height 1.00 :background "#222222"))))
   `(org-block            ((t (:height 1.00 :background "#222222"))))
   `(org-block-begin-line ((t (:height 1.00 :foreground "#222222" :background "#070707"))))
   `(org-block-end-line   ((t (:height 1.00 :foreground "#222222" :background "#070707"))))
))
#+END_SRC

** Notifications
Send agenda appointment desktop notifications.

#+BEGIN_SRC emacs-lisp
(setq appt-message-warning-time 15)
(setq appt-display-interval 5)
(setq appt-display-mode-line nil)
(setq appt-disp-window-function 'circ/appt-display)
(setq appt-delete-window-function (lambda () t))

;; Pre-defined functions for formatting
(defun circ/format-appt-notify-msg-simple (mins-to-appt curr-time msg)
  (format "%s: %s in %s mins" curr-time msg mins-to-appt))

;; Pre-defined functions for different notification systems
(defun circ/format-appt-notify-cmd-desktop (message)
  (format "timeout 0.2 notify-send -t 0 \"%s\"" message))
(defun circ/format-appt-notify-cmd-termux (message)
  (format "timeout 5 termux-notification -t \"%s\"" message))

(defvar circ/format-appt-notify-msg nil)
(defvar circ/format-appt-notify-cmd nil)

; Notifcations not working? Try using some of these
; (setq circ/format-appt-notify-msg 'circ/format-appt-notify-msg-simple)
; (setq circ/format-appt-notify-cmd 'circ/format-appt-notify-cmd-desktop)
; (setq circ/format-appt-notify-cmd 'circ/format-appt-notify-cmd-termux)

(defun circ/refresh-appointments ()
  (interactive)
  (setq appt-time-msg-list nil)
  (org-agenda-to-appt))

(defun circ/appt-display (mins-to-appt curr-time msg)
  "Sends a notification to the noticiation daemon. Has a
hardcoded 200ms timeout in case no notification service is alive"
  (when (and circ/format-appt-notify-msg
             circ/format-appt-notify-cmd
             msg)
    (let* ((head-msg (cond ((listp msg) (car msg))
                           (t msg)))
           (head-mins (cond ((listp mins-to-appt) (car mins-to-appt))
                            (t mins-to-appt)))
           (message (funcall circ/format-appt-notify-msg head-mins curr-time head-msg))
           (command (funcall circ/format-appt-notify-cmd message)))
      (when (< 0 (shell-command command))
        (user-error "Appointment notification failed"))
      (message "Notification: %s" message))
    (when (and (listp msg) msg)
      (circ/appt-display (cdr mins-to-appt) curr-time (cdr msg)))))

(defun circ/expanded-org-agenda-files ()
  (mapcar 'expand-file-name org-agenda-files))

(defun circ/org-agenda-file-p (&optional file)
  (member (or file (buffer-file-name)) (circ/expanded-org-agenda-files)))

(defun circ/maybe-refresh-appts ()
  (when (circ/org-agenda-file-p)
    (circ/refresh-appointments)))

;; Generate appointments on startup
(circ/refresh-appointments)
;; Regenerate at 00:05, so you can leave emacs open over night
(run-at-time "00:05" (* 60 60 24) 'circ/refresh-appointments)
;; Generate appointments when you save an agenda file
(add-hook 'after-save-hook 'circ/maybe-refresh-appts)
(add-hook 'after-revert-hook 'circ/maybe-refresh-appts)
#+END_SRC

* Mode Line
#+BEGIN_SRC emacs-lisp
(column-number-mode 1) ; show column number
(set-face-attribute 'mode-line nil ; Set active mode line colour
                    :foreground "white"
                    :background "darkgreen")
(set-face-attribute 'mode-line-buffer-id nil ; Set buffer id colour
                    :foreground "white"
                    :background "black")
#+END_SRC

* Custom Functions
** Helper Functions
#+BEGIN_SRC emacs-lisp
(defun circ/strip-last-newline (string)
  (replace-regexp-in-string "\n\\'" "" string))

(defun circ/escape-double-quotes (string)
  (replace-regexp-in-string "\"" "\\\\\"" string))

(defun circ/strip-font-properties (string)
  (set-text-properties 0 (length string) nil string)
  string)
#+END_SRC

** eshell-new
Interative function to create a new instance of eshell.

#+BEGIN_SRC emacs-lisp
(defun circ/eshell-new ()
  "Open a new instance of eshell."
  (interactive)
  (eshell 'N))
#+END_SRC

** transpose-buffers
Transpose two buffers.

#+BEGIN_SRC emacs-lisp
(defun circ/transpose-buffers (dir &optional arg)
  "Transpose the buffers in the current window and the target window
If arg is non-nil, the selected window will change to keep the source buffer
selected."
  (let ((target-window (windmove-find-other-window dir))
        (source-window (selected-window)))
    (cond ((null target-window)
           (format "No window found in dir %s" dir))
          ((and (window-minibuffer-p target-window)
                (not (minibuffer-window-active-p target-window)))
           (user-error "Minibuffer is inactive"))
          (t
           (let ((target-buffer (window-buffer target-window))
                 (source-buffer (window-buffer)))
             (set-window-buffer target-window source-buffer)
             (set-window-buffer source-window target-buffer))
           (if arg
               (select-window target-window))))))

(defun circ/transpose-buffers-left (&optional arg)
    "Transpose buffers from current window to buffer to the left"
  (interactive)
  (circ/transpose-buffers 'left arg))

(defun circ/transpose-buffers-up (&optional arg)
    "Transpose buffers from current window to buffer above"
  (interactive)
  (circ/transpose-buffers 'up arg))

(defun circ/transpose-buffers-right (&optional arg)
    "Transpose buffers from current window to buffer to the right"
  (interactive)
  (circ/transpose-buffers 'right arg))

(defun circ/transpose-buffers-down (&optional arg)
    "Transpose buffers from current window to buffer below"
  (interactive)
  (circ/transpose-buffers 'down arg))
#+END_SRC

** cast-buffer
Send a buffer to another window.

#+BEGIN_SRC emacs-lisp
(defun circ/cast-buffer (dir &optional arg)
  "Casts the current buffer to window in direction dir, and switches current
window back to last buffer.
If arg is non-nil, the targetted window is selected."
  (let ((target-window (windmove-find-other-window dir))
        (source-buffer (window-buffer)))
    (cond ((null target-window)
           (format "No window found in dir %s" dir))
          ((and (window-minibuffer-p target-window)
                (not (minibuffer-window-active-p target-window)))
           (user-error "Minibuffer is inactive"))
          (t
           (set-window-buffer target-window source-buffer)
           (previous-buffer)
           (if arg
               (select-window target-window))))))

(defun circ/cast-buffer-left (&optional arg)
  "Cast current buffer to the left"
  (interactive)
  (circ/cast-buffer 'left arg))

(defun circ/cast-buffer-up (&optional arg)
  "Cast current buffer up"
  (interactive)
  (circ/cast-buffer 'up arg))

(defun circ/cast-buffer-right (&optional arg)
  "Cast current buffer to the right"
  (interactive)
  (circ/cast-buffer 'right arg))

(defun circ/cast-buffer-down (&optional arg)
  "Cast current buffer down"
  (interactive)
  (circ/cast-buffer 'down arg))
#+END_SRC

** duplicate-buffer
Open buffer in another window.

#+BEGIN_SRC emacs-lisp
(defun circ/duplicate-buffer (dir &optional arg)
  "Opens the current buffer in the window in the direction dir
If arg is non-nil, the targeted window is selected"
  (let ((target-window (windmove-find-other-window dir))
        (source-buffer (window-buffer)))
    (cond ((null target-window)
           (format "No window found in dir %s" dir))
          ((and (window-minibuffer-p target-window)
                (not (minibuffer-window-active-p target-window)))
           (user-error "Minibuffer is inactive"))
          (t
           (set-window-buffer target-window source-buffer)
           (if arg
               (select-window target-window))))))

(defun circ/duplicate-buffer-left (&optional arg)
  "Cast current buffer to the left"
  (interactive)
  (circ/duplicate-buffer 'left arg))

(defun circ/duplicate-buffer-up (&optional arg)
  "Cast current buffer up"
  (interactive)
  (circ/duplicate-buffer 'up arg))

(defun circ/duplicate-buffer-right (&optional arg)
  "Cast current buffer to the right"
  (interactive)
  (circ/duplicate-buffer 'right arg))

(defun circ/duplicate-buffer-down (&optional arg)
  "Cast current buffer down"
  (interactive)
  (circ/duplicate-buffer 'down arg))
#+END_SRC

** regenerate-tags
Regenerate tags using a command defined in the project root under the =.emacs=
directory.

#+BEGIN_SRC emacs-lisp
(defun circ/regenerate-tags ()
  "use the generate-tags script in the project root to generate tags"
  (interactive)
  (cond ((projectile-project-root)
         (let* ((root-dir (projectile-project-root))
                (generate-tags-script (concat root-dir ".emacs/generate-tags"))
                (tag-command (concat ". " generate-tags-script " " root-dir))
                (result (if (file-exists-p generate-tags-script)
                            (shell-command-to-string tag-command)
                          (projectile-regenerate-tags))))
           (message result)))
        (t
         (user-error "Not in a project!"))))
#+END_SRC

** open-terminal-in-workdir
Opens a konsole in the current project root. If not in project, opens it in the
current directory.

#+BEGIN_SRC emacs-lisp
(defun circ/open-terminal-in-workdir ()
 "Opens a terminal in the project root.
If not in a project, opens it in the current directory."
 (interactive)
 (let ((workdir (if (projectile-project-root)
                    (projectile-project-root)
                  default-directory)))
   (call-process-shell-command
    (concat "konsole --workdir " workdir) nil 0)))
#+END_SRC

** whitespace-mode
Toggle on and off whitespace trailing mode

#+BEGIN_SRC emacs-lisp
(defun circ/toggle-whitespace-full ()
  "toggle display of more whitespace"
  (interactive)
  (whitespace-toggle-options '(lines-tail)))
#+END_SRC

** alignment functions
#+BEGIN_SRC emacs-lisp
(defun circ/align-once-head (start end regexp)
  "Align by regex once, adding spaces to the head of the regexp"
  (interactive "r\nsAlign once head regexp: ")
  (align-regexp start end
                (concat "\\(\\s-*\\)" regexp) 1 1 nil))

(defun circ/align-once-tail (start end regexp)
  "Align by regex once, adding spaces to the tail of the regexp"
  (interactive "r\nsAlign once tail regexp: ")
  (align-regexp start end
                (concat regexp "\\(\\s-*\\)") 1 1 nil))

(defun circ/align-repeat-head (start end regexp)
  "Align by regex repeatedly, adding spaces to the head of the regexp"
  (interactive "r\nsAlign repeat head regexp: ")
  (align-regexp start end
                (concat "\\(\\s-*\\)" regexp) 1 1 t))

(defun circ/align-repeat-tail (start end regexp)
  "Align by regex repeatedly, adding spaces to the tail of the regexp"
  (interactive "r\nsAlign repeat tail regexp: ")
  (align-regexp start end
                (concat regexp "\\(\\s-*\\)") 1 1 t))
#+END_SRC

** file opener functions
Some extra functions to aid in opening files

#+BEGIN_SRC emacs-lisp
(defun circ/find-file-line (filename linenum)
  "invoke function find-file and goto-line"
  (find-file filename)
  (goto-line linenum))
#+END_SRC

The =find-file-line= function expects two args. We just therefore parse any
FILENAME:LINENUMBER string that it uses.

#+BEGIN_SRC emacs-lisp
(defun circ/parse-file-special-syntax (file-string)
  "parses the format FILENAME:LINENUMBER"
  (let* ((file-list (split-string file-string ":"))
         (filename (car file-list))
         (line-number (string-to-number(cadr file-list))))
    (list filename line-number)))
#+END_SRC

We also want the ability to parse dirty file paths.

#+BEGIN_SRC emacs-lisp
(defun circ/clean-file-path (file-string)
  "cleans the file path"
  (replace-regexp-in-string
   "^.*:[0-9]*\\(.*\\)$"
   ""
   file-string
   nil nil 1))
#+END_SRC

Plus we need a function to tie it all together.

#+BEGIN_SRC emacs-lisp
(defun circ/find-file-special-syntax (file-string)
  "opens special syntax"
  (apply 'circ/find-file-line
         (circ/parse-file-special-syntax
          (circ/clean-file-path file-string))))
#+END_SRC

** open-in-intellij
Helpful function to open the current buffer and line in intellij.

The complimentary command for intellij is:
#+BEGIN_SRC sh
emacsclient -n +$LINENUMBER$:$COLUMN$ $FILE$
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun circ/open-in-intellij ()
  "Open the current file + line in intellij"
  (interactive)
  (let* ((file (buffer-file-name))
         (line-num (number-to-string (line-number-at-pos)))
         (command (concat "idea " file ":" line-num)))
    (shell-command command)
    (message "file opened in intellij")))
#+END_SRC

** check-project
Compile / check the project and send results to ivy-read.

Expects results in the format:

#+BEGIN_EXAMPLE
FILENAME:100 explanation
FILENAME:200 explanation
FILENAME:40can also be dirty
#+END_EXAMPLE

#+BEGIN_SRC emacs-lisp
(defun circ/check-project ()
  "run .emacs/check-project and put results in ivy-read"
  (interactive)
  (cond ((projectile-project-root)
         (message "Checking project...")
         (let* ((root-dir (projectile-project-root))
                (script (concat root-dir ".emacs/check-project"))
                (command (concat ". " script " " root-dir))
                (result (shell-command-to-string command)))
           (cond ((> (length result) 0)
                  (completing-read "Check project results: "
                                   (split-string result "\n")
                                   :action 'circ/find-file-special-syntax))
                 (t
                  (user-error "Check complete")))))
        (t
         (user-error "Not in a project!"))))
#+END_SRC

** show-file-path
Show the full file path as a message

#+BEGIN_SRC emacs-lisp
(defun circ/show-file-path ()
  "Show full file path as a message"
  (interactive)
  (if buffer-file-name
      (message buffer-file-name)
    (message "No valid file path")))
#+END_SRC

** smart-clear-buffer
Clear the buffer, but with special cases for certain major modes.

#+BEGIN_SRC emacs-lisp
(defun circ/smart-clear-buffer ()
  "Clear the current buffer. term-mode requires different command to clear."
  (interactive)
  (case major-mode
    ('term-mode (comint-clear-buffer))
    (otherwise (erase-buffer))))
#+END_SRC

** Revert project buffers
Revert all the buffers in the current project.

#+BEGIN_SRC emacs-lisp
(defun circ/revert-project-buffers ()
  (interactive)
  (let* ((project (projectile-ensure-project (projectile-project-root)))
         (project-buffers (projectile-project-buffers project))
         (buffers (remove-if-not 'buffer-file-name project-buffers)))
    (dolist (buffer buffers)
      (with-current-buffer buffer
        (ignore-errors (revert-buffer nil t))
        (message "Reverted: %s" buffer)))
    (message "Project buffers reverted")))
#+END_SRC
** Save all project buffers
#+BEGIN_SRC emacs-lisp
(defun circ/save-project-buffers ()
  (interactive)
  (let* ((project (projectile-ensure-project (projectile-project-root)))
         (project-buffers (projectile-project-buffers project))
         (buffers (remove-if-not 'buffer-file-name project-buffers)))
    (dolist (buffer buffers)
      (with-current-buffer buffer
        (save-buffer)
        (message "Saved: %s" buffer)))
    (message "Project buffers saved")))
#+END_SRC
** Org Set Property
#+BEGIN_SRC emacs-lisp
(defun circ/org-set-property (property &optional val)
  (interactive)
  (let* ((current-value (org-entry-get nil property))
         (value (cond (val val)
                      (t (read-string (format "Set property %s: " property)
                                      current-value)))))
    (org-entry-put nil property value)))
#+END_SRC
** Org file reference
#+BEGIN_SRC emacs-lisp
(defun circ/org-file-reference ()
  (interactive)
  (let* ((target-file (expand-file-name
                       (completing-read "File reference (C-M-j to done): "
                                        (mapcar (lambda (filepath)
                                                  (file-relative-name
                                                   filepath
                                                   circ/org-reference-directory))
                                                (directory-files-recursively
                                                 circ/org-reference-directory
                                                 ".*\.org"
                                                 nil)))
                       circ/org-reference-directory))
         (org-heading (org-get-heading)))
    (org-back-to-heading)
    (org-cut-subtree)

    (find-file target-file)
    (let ((target-buffer (get-file-buffer target-file)))
      (unless (file-exists-p target-file)
        (make-directory (file-name-directory target-file) t)
        (with-current-buffer target-buffer
          (insert (concat "#+TITLE: " org-heading))
          (newline))
        (message "Created file"))
      (with-current-buffer target-buffer
        (end-of-buffer)
        (newline)
        (yank)
        (save-buffer)))))
#+END_SRC
** Buffer yank paste
#+BEGIN_SRC emacs-lisp
(setq circ/buffer-clipboard nil)

(defun circ/buffer-yank ()
  (interactive)
  (setq circ/buffer-clipboard (current-buffer)))

(defun circ/buffer-paste ()
  (interactive)
  (when circ/buffer-clipboard
    (set-window-buffer (selected-window) circ/buffer-clipboard)))
#+END_SRC
** Kill buffer
#+BEGIN_SRC emacs-lisp
(defun circ/kill-this-buffer ()
  (interactive)
  (kill-buffer (current-buffer)))
#+END_SRC
** Cortex
#+BEGIN_SRC emacs-lisp
(defun circ/cortex/create-file (&optional initial-title)
  "Create a new cortex file"
  (interactive)
  (let* ((title (read-string "Title: " initial-title))
         (id (circ/cortex/create-new-file title)))
    (find-file (circ/cortex/expand-filepath id))
    (goto-char (point-max))))

(defun circ/cortex/create-new-file (title)
  (let ((new-id (circ/cortex/new-id)))
    (circ/cortex/ensure-file new-id title)
    new-id))

(defun circ/cortex/get-ids ()
  (mapcar (lambda (file)
            (replace-regexp-in-string "\.org" "" file))
          (directory-files circ/cortex/directory nil "^[0-9]*\.org$")))

(defun circ/cortex/get-title ()
  (let ((point-location (point)))
    (goto-char (point-min))
    (re-search-forward "\* \\(.*\\)")
    (goto-char point-location)
    (match-string 1)))

(defun circ/cortex/get-entry ()
  (let ((point-location (point)))
    (goto-char (point-min))
    (let ((entry (cond ((re-search-forward ":END: *\n" nil t)
                        (buffer-substring (point) (point-max)))
                       ((re-search-forward "\* .*\n" nil t)
                        (buffer-substring (point) (point-max)))
                       (t "ERROR PARSING ENTRY"))))
      (goto-char point-location)
      (replace-regexp-in-string "\\[cortex:[0-9]*\\]" "" entry))))

(defun circ/cortex/get-file-previews()
  (let ((ids (circ/cortex/get-ids)))
    (mapcar (lambda (id)
              (with-temp-buffer
                (insert-file-contents (circ/cortex/expand-filepath id))
                (concat (propertize id 'face '(:foreground "grey")) ": "
                        (propertize (circ/cortex/get-title) 'face '(:foreground "green")) "\n"
                        (circ/cortex/get-entry))))
            ids)))

(defun circ/cortex/expand-filepath (id)
  "Given an id, create the full cortex filepath"
  (concat (file-name-as-directory circ/cortex/directory)
          id ".org"))

(defun circ/cortex/extract-id (filepath)
  "Given a cortex filepath, return the id"
  (let ((filename (file-name-nondirectory filepath)))
    (string-match "^\\([0-9]*\\)\.org" filename)
    (match-string 1 filename)))

(defun circ/cortex/ensure-file (id &optional descr)
  (let ((description (cond (descr descr)
                           (t "")))
        (abs-filepath (circ/cortex/expand-filepath id)))
    (unless (file-exists-p (circ/cortex/expand-filepath id))
      (write-region (format "* %s\n" (capitalize description)) nil
                    abs-filepath))))

(defun circ/cortex/format-link (id descr)
  (format "[[cortex:%s][%s]]" id descr))

(defun circ/cortex/add-backlink (id)
  "Adds a backlink to the slide ID that links to the currently visited slide"
  (let ((current-file (buffer-file-name))
        (current-heading (org-get-heading t t))
        (abs-filepath (circ/cortex/expand-filepath id)))
    (with-temp-buffer
      (let ((file-buffer (get-file-buffer abs-filepath)))
        (insert-file-contents abs-filepath)
        (org-mode)
        (org-entry-put nil "Backlinks"
                       ;; Ensure we do not add a duplicate backlink
                       (let* ((backlinks (org-entry-get nil "Backlinks"))
                              (link (circ/cortex/format-link
                                     (circ/cortex/extract-id current-file)
                                     current-heading)))
                         (cond ((string-match-p (regexp-quote link)
                                                (cond (backlinks backlinks)
                                                      (t "")))
                                backlinks)
                               (t
                                (cond (backlinks (concat backlinks " " link))
                                      (t link))))))
        (write-file abs-filepath)))))

(defun circ/cortex/new-id ()
  (format-time-string "%Y%m%d%H%M%S"))

(defun circ/cortex/interactive-slide-picker (&optional initial-input)
  "Prompts user to interactively pick a slide and returns the id and the
description in a cons.

(id . description)

If no slide is found, a new id is generated and the search term is returned as
the description"
  (let* ((result (completing-read "Cortex link (C-M-j to done): "
                                  (circ/cortex/get-file-previews)
                                  nil nil
                                  initial-input))
         (id (progn
               (string-match "^\\([0-9]*\\):" result)
               (match-string 1 result)))
         (description (cond
                       (id
                        (string-match "^[0-9]*: \\(.*\\)" result)
                        (match-string 1 result))
                       (t
                        (string-match "^\\(.*\\)" result)
                        (match-string 1 result)))))

    ;; Remove any font properties
    (set-text-properties 0 (length id) nil id)
    (set-text-properties 0 (length description) nil description)
    (message "ID: %s" id)
    (message "Des: %s" description)

    (cons (cond ((file-exists-p (circ/cortex/expand-filepath id)) id)
                (t (circ/cortex/new-id)))
          description)))

(defun circ/cortex/add-link (id description)
  "Create a cortex link. If a region is highlighted, it is replaced with the
generated link"
  (when (region-active-p)
    (delete-region (region-beginning) (region-end)))
  (insert (circ/cortex/format-link id description)))

(defun circ/cortex/link (start end)
  "Create a cortex link.

When a region is highlighted, the initial search input is set to the highlighted
text, and the initial default description is also set to the highlighted text.

When no region is highlighed, the initial search input and initial description
are blank.

If the link given does not exist, the file is created with an initial heading
of the inputted description.

The targeted file is assigned a backlink for the original file the link was
created from."
  (interactive "r")
  (let* ((initial-input (when (region-active-p)
                               (circ/strip-font-properties
                                (buffer-substring start end))))
         (id-desc (circ/cortex/interactive-slide-picker initial-input))
         (id (car id-desc))
         (desc (cdr id-desc))
         (description (read-string "Description: " (cond (initial-input initial-input)
                                                         (t desc)))))

    ;; Firstly, ensure that a target file exists with the proper heading
    (circ/cortex/ensure-file id desc)
    (circ/cortex/add-backlink id)
    (circ/cortex/add-link id description)
    (save-buffer)))

(defun circ/cortex/get-all-links ()
  "Returns all cortex links in the current file in a list of conses."
  (let ((point-location (point))) ; Save pointer to restore later
    ;; Go to the beginning of the buffer
    (goto-char (point-min))
    ;; Move past the properties (if any)
    (re-search-forward (regexp-quote ":END:") nil t)
    (let (links)
      ;; Generate list of links in current buffer
      (while (re-search-forward "\\[\\[cortex:\\([0-9]*\\)\\]\\[\\(.*?\\)\\]\\]"
                                nil t)
        (let ((id (match-string 1))
              (desc (match-string 2)))
          (set-text-properties 0 (length id) nil id)
          (set-text-properties 0 (length desc) nil desc)
          (push (cons id desc) links)))
      (goto-char point-location)
      (cl-remove-duplicates links :test #'equal))))

(defun circ/cortex/update-backlink (slide-id link-id old-desc new-desc)
  "For the slide of `slide-id`, update the backlink of `link-id` to update the
description"
  (message "Updating cortex slide %s" slide-id)
  (with-temp-buffer
    (let ((filepath (circ/cortex/expand-filepath slide-id)))
      (insert-file-contents filepath)
      (org-mode)
      (let ((backlinks (org-entry-get nil "Backlinks")))
        (org-entry-put nil "Backlinks"
                       (replace-regexp-in-string
                        (regexp-quote (circ/cortex/format-link link-id old-desc))
                        (circ/cortex/format-link link-id new-desc)
                        backlinks)))
      (write-file filepath))))

(defun circ/cortex/rename-current-title (new-title)
  "Renames the title in the current slide"
  (let ((old-title (org-get-heading t t))
        (point-location (point))) ; Restore pointer later
    (goto-char (point-min))
    (re-search-forward (regexp-quote (concat "* " old-title)))
    (replace-match (concat "* " new-title))
    (goto-char (- point-location (- (length old-title) (length new-title)))))
  (save-buffer))

(defun circ/cortex/get-current-id ()
  (circ/cortex/extract-id (buffer-file-name)))

(defun circ/cortex/rename-slide ()
  "Rename the current slide and update the backlinks for any linked slides"
  (interactive)
  (let* ((current-id (circ/cortex/get-current-id))
         (old-title (org-get-heading t t))
         (new-title (read-string "New title: " old-title)))
    (message "Changing %s to %s" old-title new-title)
    (circ/cortex/rename-current-title new-title)
    (dolist (link (circ/cortex/get-all-links))
      (let ((link-id (car link)))
        (circ/cortex/update-backlink link-id current-id
                                       old-title new-title)))))

(defun circ/cortex/search-slides ()
  "Search all slides and open"
  (interactive)
  (let* ((search-term (circ/cortex/interactive-slide-picker))
         (filepath (circ/cortex/expand-filepath (car search-term))))
    (cond ((not (file-exists-p filepath))
           (message "Slide does not exist. Creating")
           (circ/cortex/create-file (cdr search-term)))
          (t
           (find-file filepath)))))

(defun circ/cortex/continue ()
  "Creates a continue link at the bottom of the current slide.

If the current slide has no index, set the index property to 1.

The new slide is created with an incremented index."
  (interactive)
  (let* ((point-location (point))
         (buffer-size (point-max))
         (current-title (org-get-heading t t))
         (org-index (org-entry-get nil "Index"))
         (current-index (cond (org-index org-index) (t "1")))
         (new-index (number-to-string (+ 1 (string-to-number current-index))))
         (new-id (circ/cortex/new-id))
         (new-title (read-string "New title: " current-title)))
    (goto-char (point-max))
    (insert "\n")
    (circ/cortex/ensure-file new-id new-title)
    (circ/cortex/add-backlink new-id)
    (circ/cortex/add-link new-id "Continued...")

    ;; If the continued slide has the same title, increment indexes
    (when (equal current-title new-title)
      (message "Indexing slides")
      (unless (org-entry-get nil "Index")
        (org-entry-put nil "Index" current-index))
      (circ/cortex/add-index new-id new-index))

    (goto-char (+ point-location (- (point-max) buffer-size)))
    (save-buffer)
    (find-file (circ/cortex/expand-filepath new-id))
    (goto-char (point-max))
    (message "%s continued..." current-title)))

(defun circ/cortex/add-index (id index)
  "Add index to given slide id"
  (with-temp-buffer
    (let ((abs-filepath (circ/cortex/expand-filepath id)))
      (insert-file-contents abs-filepath)
      (org-mode)
      (org-entry-put nil "Index" index)
      (write-file abs-filepath))))

(defun circ/cortex/list-reference-files ()
  (mapcar (lambda (file)
            (replace-regexp-in-string (regexp-quote (expand-file-name circ/cortex/reference-directory))
                                      "" file))
          (directory-files-recursively circ/cortex/reference-directory "")))

(defun circ/cortex/reference-completing-read (&optional initial-input)
  (completing-read "Reference: "
                   (circ/cortex/list-reference-files)
                   nil nil initial-input))

(defun circ/cortex/find-reference ()
  (interactive)
  (let* ((filepath (circ/cortex/reference-completing-read))
         (full-filepath (concat (expand-file-name circ/cortex/reference-directory) filepath)))
    (circ/ensure-file full-filepath)
    (find-file full-filepath)))

(defun circ/cortex/insert-reference-link ()
  (interactive)
  (let* ((filepath (circ/cortex/reference-completing-read))
         (description (read-string "Description: " (concat "Ref: " filepath)))
         (org-link (concat "ref:" filepath))
         (full-filepath (concat (expand-file-name circ/cortex/reference-directory) filepath)))
    (circ/ensure-file full-filepath)
    (insert (org-make-link-string org-link description))))

(defun circ/ensure-file (filepath)
  (unless (file-exists-p full-filepath)
    (make-directory (file-name-directory full-filepath) t)
    (write-region (concat "#+TITLE: "
                   (capitalize (replace-regexp-in-string
                                "_" " " (file-name-base filepath))))
                  nil full-filepath)))

(defun circ/cortex/reference-directories ()
  (seq-uniq
   (mapcar (lambda (f)
             (replace-regexp-in-string "/$" ""
                                       (file-name-directory f)))
           (circ/cortex/list-reference-files))))


(defun circ/cortex/file-web-page-archive ()
  (interactive)
  (dolist (file (directory-files (expand-file-name "~/Downloads/web_page_archive")
                                 t directory-files-no-dot-files-regexp))
    (let* ((filename (concat (file-name-base file)
                             (file-name-extension file t)))
           (directory (completing-read (format "File %s to: " filename)
                                       (circ/cortex/reference-directories)))
           (target-dir (file-name-as-directory
                          (concat (expand-file-name circ/cortex/reference-directory)
                                  directory)))
           (target-path (concat target-dir filename)))
      (message "Moving %s to %s" file target-path)
      (make-directory target-dir t)
      (rename-file file target-path))))
#+END_SRC

** Surround
#+BEGIN_SRC emacs-lisp
(defun circ/surround-parentheses () (interactive) (circ/surround "(" ")"))
(defun circ/surround-brackets    () (interactive) (circ/surround "[" "]"))
(defun circ/surround-braces      () (interactive) (circ/surround "{" "}"))
(defun circ/surround-asterisk    () (interactive) (circ/surround "*" "*"))
(defun circ/surround-d-quote     () (interactive) (circ/surround "\"" "\""))
(defun circ/surround-s-quote     () (interactive) (circ/surround "'" "'"))
(defun circ/surround-slash       () (interactive) (circ/surround "/" "/"))
(defun circ/surround-equals      () (interactive) (circ/surround "=" "="))
(defun circ/surround-plus        () (interactive) (circ/surround "+" "+"))
(defun circ/surround-minus       () (interactive) (circ/surround "-" "-"))

(defun circ/surround-region ()
  (interactive)
  (let* ((start (read-string "Beginning: "))
         (end (read-string "End: " start)))
    (circ/surround start end)))

(defun circ/surround (start end)
  (let ((region (buffer-substring (region-beginning) (region-end))))
    (delete-region (region-beginning) (region-end))
    (insert (format "%s%s%s" start region end))))
#+END_SRC

** Insert org timestamp
#+BEGIN_SRC emacs-lisp
(defun circ/insert-label-timestamp (label)
  (insert (format "%s: " label))
  (org-time-stamp-inactive))

(defun circ/insert-created-timestamp ()
  (interactive)
  (circ/insert-label-timestamp "Created"))
#+END_SRC
** Term Mode Functions
#+BEGIN_SRC emacs-lisp
(defun circ/term/delete-previous-word ()
  "Simulates typical C-<backspace> behaviour by sending C-w instead."
  (interactive)
  (term-send-raw-string "\C-w"))

(defun circ/term/delete-next-word ()
  "Simulates typical C-<delete> behaviour by sending M-d instead."
  (interactive)
  (term-send-raw-string "\^[d"))

(defun circ/term/go-to-previous-word ()
  "Simulates typical C-<left> behaviour by sending M-b instead."
  (interactive)
  (term-send-raw-string "\^[b"))

(defun circ/term/go-to-next-word ()
  "Simulates typical C-<right> behaviour by sending M-f instead."
  (interactive)
  (term-send-raw-string "\^[f"))
#+END_SRC

** Shell Command
#+BEGIN_SRC emacs-lisp
(defvar circ/shell-line-history '())

(defun circ/do-sh-cmd (input-list command &optional strip-newline)
  (let (output-list)
    (dolist (dirty-input input-list)
      (set-text-properties 0 (length dirty-input) nil dirty-input)
      (let* ((input (circ/escape-double-quotes
                     (circ/strip-last-newline
                      dirty-input)))
             (output (shell-command-to-string
                      (concat command " <<< \"" input "\""))))
        (setq output-list (cons (if strip-newline
                                    (circ/strip-last-newline output)
                                  output) output-list))))
    (reverse output-list)))

(defun circ/sh-cmd (&optional cmd whole-buffer split-lines)
  "Execute CMD on the buffer. If CMD is nil, ask the user what
command to use. If split-lines is non-nil, split the input by
newlines and send each line into the command individually.

Use the selected region as the input to the shell command. If no
region is selected, use the current line as the input, except
when WHOLE-BUFFER is non-nil, in which case, use the entire
buffer as the input.

A history of executed commands is kept."
  (interactive)
  (let ((command (cond (cmd cmd)
                       (t (completing-read "Command (C-M-j to done): "
                                           circ/shell-line-history)))))
    (add-to-list 'circ/shell-line-history command)
    (cond ((eq evil-this-type 'block)
           ;; Case when region is an evil block
           (let* ((rb (region-beginning))
                  (re (region-end))
                  (input-list (extract-rectangle rb re))
                  (output-list (circ/do-sh-cmd input-list command t))
                  (start (= (point) rb)))
             (goto-char rb)
             (delete-rectangle rb re)
             (insert-rectangle output-list)
             ;; after inserting rectanble, point will move to the end of the
             ;; input, so if the point was at the start of the rectangle, then
             ;; move it back.
             (when start
               (goto-char rb))))
          (t
           (let* ((rb (cond (whole-buffer (point-min))
                            ((use-region-p) (region-beginning))
                            (t (line-beginning-position))))
                  (re (cond (whole-buffer (point-max))
                            ((use-region-p) (region-end))
                            (t (line-end-position))))
                  (input (buffer-substring rb re))
                  (input-list (cond (split-lines (split-string input "\n"))
                                    (t (list input))))
                  (output-list (circ/do-sh-cmd input-list command (not whole-buffer))))
             (delete-region rb re)
             (dolist (line output-list)
               (insert line)))))))
#+END_SRC
** Org agenda habits
Force habit graphs to be drawn everywhere
#+BEGIN_SRC emacs-lisp
(defvar circ/org-habit-show-graphs-everywhere t
  "If non-nil, show habit graphs in all types of agenda buffers.

Normally, habits display consistency graphs only in
\"agenda\"-type agenda buffers, not in other types of agenda
buffers.  Set this variable to any non-nil variable to show
consistency graphs in all Org mode agendas.")

(defun circ/org-agenda-mark-habits ()
  "Mark all habits in current agenda for graph display.

This function enforces `circ/org-habit-show-graphs-everywhere' by
marking all habits in the current agenda as such.  When run just
before `org-agenda-finalize' (such as by advice; unfortunately,
`org-agenda-finalize-hook' is run too late), this has the effect
of displaying consistency graphs for these habits.

When `circ/org-habit-show-graphs-everywhere' is nil, this function
has no effect."
  (when (and circ/org-habit-show-graphs-everywhere
         (not (get-text-property (point) 'org-series)))
    (let ((cursor (point))
          item data)
      (while (setq cursor (next-single-property-change cursor 'org-marker))
        (setq item (get-text-property cursor 'org-marker))
        (when (and item (org-is-habit-p item))
          (with-current-buffer (marker-buffer item)
            (setq data (org-habit-parse-todo item)))
          (put-text-property cursor
                             (next-single-property-change cursor 'org-marker)
                             'org-habit-p data))))))

(advice-add #'org-agenda-finalize :before #'circ/org-agenda-mark-habits)
#+END_SRC
** VC annotate in current window
#+BEGIN_SRC emacs-lisp
(defun circ/vc-annotate-current-window ()
  "A bad implementation of vc-annotate-current-window"
  (interactive)
  (vc-ensure-vc-buffer)
  (let ((prev-window-configuration (current-window-configuration)))
    (call-interactively 'vc-annotate)
    (let ((vc-buffer (current-buffer)))
      (set-window-configuration prev-window-configuration)
      (switch-to-buffer vc-buffer))))
#+END_SRC
** Org agenda setup
#+BEGIN_SRC emacs-lisp
(defun circ/setup-agenda-view()
  (interactive)
  (circ/alias-org-agenda-tasks)
  (split-window-right)
  (circ/alias-org-agenda-agenda))
#+END_SRC
** Org agenda templates
#+BEGIN_SRC emacs-lisp
(setq circ/org-template-alist
      '(("Is this useful?" . "*Is this useful?*
/What do you think you could use it for?/

/What does it do?/
")
        ("Does this fix my issue?" . "*Does this fix my issue?*
/What issue could this solve?/

/What features does this have?/

/How could such features solve your problem?/")))

(defun circ/org-template-insert ()
  (interactive)
  (let ((template (completing-read "Template: "
                                   circ/org-template-alist)))
    (insert (cdr (assoc template circ/org-template-alist)))))
#+END_SRC
** Org sort headlines
Sorts the level 0 headlines by todo state
#+BEGIN_SRC emacs-lisp
(defun circ/org-hide-all ()
  (interactive)
  (org-map-entries
   (lambda () (outline-hide-subtree))
   nil 'file))

(defun circ/org-sort-headlines ()
  (interactive)
  (mark-whole-buffer)
  (org-sort-entries nil ?o)
  (circ/org-hide-all))
#+END_SRC
** Bash history
#+BEGIN_SRC emacs-lisp
(defun circ/bash-history ()
  (reverse
   (remove-if (lambda (string) (string-match-p "^#[0-9]*$" string))
              (split-string
               (with-temp-buffer
                 (insert-file-contents "~/.bash_history")
                 (buffer-substring-no-properties (point-min) (point-max)))
               "\n" t))))

(defun circ/bash-history-search()
  (interactive)
  (if (string-equal major-mode "term-mode")
      (progn
        (let* (;; Hacky fix for ivy sorting. Does not work with default
               ;; completing-read function
               (ivy-sort-functions-alist nil)
               (string (completing-read "History: " (circ/bash-history))))
          (term-send-raw-string string)
          (term-send-raw-string "\n")))
    (message "Not in term-mode")))
#+END_SRC
** Set Frame Name
A wrapper around the =set-frame-name= function to automatically append " - Emacs"
to the title and pre-fill the default input as the current frame name.

#+BEGIN_SRC emacs-lisp
(defun circ/set-frame-name (&optional name)
  (interactive)
  (let ((title (cond (name name)
                     (t (read-string "Title: "
                                     (replace-regexp-in-string
                                      " - Emacs$" ""
                                      (frame-parameter nil 'name)))))))
    (set-frame-name (concat title " - Emacs"))))
#+END_SRC
** New Scratch Modes
#+BEGIN_SRC emacs-lisp
(defun new-scratch-with-mode (mode)
  "Opens a new scratch buffer in given mode. If one already exists,
creates a new one"
  (interactive)
  (let ((name (concat "*" (symbol-name mode) "-scratch*")))
    (switch-to-buffer (get-buffer-create "*new-scratch-mode*"))
    (rename-buffer name t)
    (funcall mode)))

;; Add new scratch modes below
(defun new-scratch-json-mode ()
  (interactive)
  (new-scratch-with-mode 'json-mode))

(defun new-scratch-org-mode ()
  (interactive)
  (new-scratch-with-mode 'org-mode))

(defun new-scratch-text-mode ()
  (interactive)
  (new-scratch-with-mode 'text-mode))
#+END_SRC
** Disable evil quickscope
#+BEGIN_SRC emacs-lisp
(defun circ/disable-evil-quickscope-mode ()
  (evil-quickscope-mode -1))
#+END_SRC
** run-proc-and-fun
A function to run a shell program in the background and run a function on the
resulting buffer output.
#+BEGIN_SRC emacs-lisp
(defun circ/run-proc-and-fun (process-name buffer-name directory arg-list
                                           &optional erase-buffer fun)
  "Call ARG-LIST and run FUN in the results buffer.
Calls `start-process' with PROCESS-NAME BUFFER-NAME and ARG-LIST.
DIRECTORY sets the directory the process is run in.
ERASE-BUFFER, if non-nil will erase the results buffer before running
the process.
FUN, if a function, will be run after the process has finished.

Example

(circ/run-proc-and-fun \"test\" \"*test*\" \"~/Downloads\" (list \"ls\" \"-lh\") t
             (lambda ()
               (insert \"test4\\n\")))

NOTE: I use `list' because I don't know how to show a real
apostrophe in the doc"
  (interactive)
  (let* ((buf (get-buffer-create buffer-name)))
    (with-current-buffer buf
      (when erase-buffer
        (erase-buffer))
      (setq-local process-name process-name)
      (setq-local process-directory directory)
      (setq-local post-process-fun fun)
      (set-process-sentinel
       (let ((process-fun (append
                           (list process-name (current-buffer))
                           arg-list))
             (default-directory process-directory))
         (apply 'start-process process-fun))
       (lambda (process event)
         (unless (process-live-p process)
           (with-current-buffer (process-buffer process)
             (goto-char (point-max))
             (when (functionp post-process-fun)
               (funcall post-process-fun))
             (goto-char (point-max))))))))
  (message "Process started: %s" arg-list))
#+END_SRC
** RSS Feed Functions
Subscribe to subreddits
#+BEGIN_SRC emacs-lisp
(defun circ/generate-subreddit-feed ()
  (interactive)
  (let* ((subreddit (read-string "subreddit: r/"))
         (type (completing-read "Feed Type: "
                                '("Hot"
                                  "New"
                                  "Rising"
                                  "Controversial"
                                  "Top of the Past Hour"
                                  "Top of the Past Day"
                                  "Top of the Past Week"
                                  "Top of the Past Month"
                                  "Top of the Past Year"
                                  "Top of All Time")))
         (url (concat "https://www.reddit.com/r/" subreddit "/"
                      (cond ((string= type "Hot")                   "")
                            ((string= type "New")                   "new/")
                            ((string= type "Rising")                "rising/")
                            ((string= type "Controversial")         "controversial/")
                            ((string= type "Top of the Past Hour")  "top/")
                            ((string= type "Top of the Past Day")   "top/")
                            ((string= type "Top of the Past Week")  "top/")
                            ((string= type "Top of the Past Month") "top/")
                            ((string= type "Top of the Past Year")  "top/")
                            ((string= type "Top of All Time")       "top/"))
                      ".rss"
                      (cond ((string= type "Top of the Past Hour")  "?t=hour")
                            ((string= type "Top of the Past Day")   "?t=day")
                            ((string= type "Top of the Past Week")  "?t=month")
                            ((string= type "Top of the Past Month") "?t=month")
                            ((string= type "Top of the Past Year")  "?t=year")
                            ((string= type "Top of All Time")       "?t=all"))))
         (title (concat subreddit
                        (cond ((string= type "Hot")                   "")
                              ((string= type "New")                   " (new)")
                              ((string= type "Rising")                " (rising)")
                              ((string= type "Controversial")         " (controversial)")
                              ((string= type "Top of the Past Hour")  " (hourly)")
                              ((string= type "Top of the Past Day")   " (daily)")
                              ((string= type "Top of the Past Week")  " (weekly)")
                              ((string= type "Top of the Past Month") " (monthly)")
                              ((string= type "Top of the Past Year")  " (yearly)")
                              ((string= type "Top of All Time")       " (all time)"))))
         (org-link (format "[[%s][%s]]" url title)))
    (kill-new org-link)
    (message "Copied to clipboard: %s" org-link)))
#+END_SRC

Subscribe to youtube channel
#+BEGIN_SRC emacs-lisp
(defun circ/generate-youtube-channel-feed ()
  (interactive)
  (let* ((youtube-url (read-string "Youtube Channel Link: "))
         (channel-name (read-string "Youtube Channel Name: "))
         (channel-id (replace-regexp-in-string ".*channel/" "" youtube-url))
         (url (concat "https://www.youtube.com/feeds/videox.xml?channel_id="
                      channel-id))
         (org-link (format "[[%s][%s]]" url channel-name)))
    (kill-new org-link)
    (message "Copied to clipboard: %s" org-link)))
#+END_SRC
** Desktop notifications
#+BEGIN_SRC emacs-lisp
(defvar circ/notify-command nil)

(defun circ/desktop-notify (message timeout)
  (format "timeout 0.2 notify-send -t %s \"%s\"" timeout message))
(defun circ/termux-notify (message timeout)
  (format "timeout 5 termux-notification -t \"%s\"" message))

(defun circ/notify (message &optional timeout)
  (interactive)
  (let ((timeout-secs (cond (timeout (* 1000 timeout))
                            (t 0))))
    (when (functionp circ/notify-command)
      (when (< 0 (shell-command (funcall circ/notify-command message timeout-secs)))
        (user-error "Notification failure: %s" message)))
    (message "Notification: %s" message)))
#+END_SRC
** vc shortcuts
#+BEGIN_SRC emacs-lisp
(defun circ/vc-diff-head-current ()
"Compare current file against HEAD"
  (interactive)
  (message "%s" (buffer-file-name))
  (vc-version-ediff (list (buffer-file-name)) "HEAD" nil))
#+END_SRC
** Reload all org agendas
#+BEGIN_SRC emacs-lisp
(defun circ/reload-all-org-agendas ()
  (interactive)
  (dolist (buffer (buffer-list))
    (with-current-buffer buffer
      (when (derived-mode-p 'org-agenda-mode)
        (let ((window (get-buffer-window buffer t)))
          (when window
            (with-selected-window window
              (org-agenda-redo))))))))

(defun circ/maybe-refresh-all-org-agendas ()
  (when (circ/org-agenda-file-p)
    (circ/reload-all-org-agendas)))

(add-hook 'after-save-hook 'circ/maybe-refresh-all-org-agendas)
(add-hook 'after-revert-hook 'circ/maybe-refresh-all-org-agendas)
#+END_SRC
** copy-buffer
Major mode for copy buffer
#+BEGIN_SRC emacs-lisp
(defvar copy-buffer-mode-map
  (let ((map (make-sparse-keymap)))
    map)
  "Keymap for `copy-buffer-mode'.")

(define-derived-mode copy-buffer-mode org-mode "copy-buffer"
  "Major mode for copy-buffer."
  (set (make-local-variable 'revert-buffer-function) #'copy-buffer))

(defvar copy-buffer-copy-function 'nil)

(defun copy-buffer-copy-function-desktop (string)
  (kill-new string))

(defun copy-buffer-copy-function-termux (string)
  (shell-command (concat "termux-clipboard-set" " "
                         "\"" string "\"")))

(defun copy-buffer-copy-quit ()
  (interactive)
  (when (functionp copy-buffer-copy-function)
    (funcall copy-buffer-copy-function (buffer-string))
    (circ/kill-this-buffer)))

(defun copy-buffer ()
  (interactive)
  (let ((buf (get-buffer-create "*copy-buffer-new*")))
    (with-current-buffer buf
      (rename-buffer "*copy-buffer*" t)
      (copy-buffer-mode)
      (switch-to-buffer buf))))
#+END_SRC
** ansi-term title
#+BEGIN_SRC emacs-lisp
(defun circ/ansi-term ()
  (interactive)
  (let* ((project-name (projectile-project-name))
         (title (cond ((string= project-name "-")
                       default-directory)
                      (t
                       project-name)))
         (term-name (format "%s term" title)))
    (ansi-term "/bin/bash" term-name)))
#+END_SRC
** reverse goto org clock
#+BEGIN_SRC emacs-lisp
(defun org-agenda-clock-goto ()
  "Jump to the currently clocked in task within the agenda.
If the currently clocked in task is not listed in the agenda
buffer, display it in another window."
  (interactive)
  (let (pos)
    (mapc (lambda (o)
        (if (eq (overlay-get o 'type) 'org-agenda-clocking)
        (setq pos (overlay-start o))))
      (reverse (overlays-in (point-min) (point-max))))
    (cond (pos (goto-char pos))
      ;; If the currently clocked entry is not in the agenda
      ;; buffer, we visit it in another window:
      ((bound-and-true-p org-clock-current-task)
       (org-switch-to-buffer-other-window (org-clock-goto)))
      (t (message "No running clock, use `C-c C-x C-j' to jump to the most recent one")))))
#+END_SRC
* Local variables
** Safe Local Eval Aliases
#+BEGIN_SRC emacs-lisp
(defun circ/file-local-eval-safe-auto-revert ()
  (interactive)
  (auto-revert-mode t))
#+END_SRC
** Safe Local Eval List
#+BEGIN_SRC emacs-lisp
(add-to-list 'safe-local-eval-forms '(circ/file-local-eval-safe-auto-revert))
#+END_SRC

* Package Specific
** ediff
#+BEGIN_SRC emacs-lisp
(setq ediff-split-window-function 'split-window-horizontally)
(setq ediff-window-setup-function 'ediff-setup-windows-plain)
#+END_SRC

Restore previous window config.
#+BEGIN_SRC emacs-lisp
(defvar circ/ediff-last-window-configuration nil)

(defun circ/ediff-store-window-configuration ()
  (setq circ/ediff-last-window-configuration (current-window-configuration)))

(defun circ/ediff-restore-window-configuration ()
  (set-window-configuration circ/ediff-last-window-configuration))

(add-hook 'ediff-before-setup-hook #'circ/ediff-store-window-configuration)
(add-hook 'ediff-quit-hook #'circ/ediff-restore-window-configuration)
#+END_SRC

Expand org files when comparing
#+BEGIN_SRC emacs-lisp
(add-hook 'ediff-prepare-buffer-hook #'outline-show-all)
#+END_SRC

Colours
#+BEGIN_SRC emacs-lisp
(custom-set-faces
 '(ediff-even-diff-A ((t (:background "dim gray"))))
 '(ediff-even-diff-B ((t (:background "dim gray"))))
 '(ediff-even-diff-C ((t (:background "dim gray"))))
 '(ediff-odd-diff-A ((t (:background "dim gray"))))
 '(ediff-odd-diff-B ((t (:background "dim gray"))))
 '(ediff-odd-diff-C ((t (:background "dim gray"))))
 )
#+END_SRC
** which-key
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/which-key-3.3.1")
(require 'which-key)
(which-key-mode)
#+END_SRC

** evil
Load evil, and its dependencies in it comes with.

#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/evil-1.2.14")
(add-to-list 'load-path "~/.emacs.d/packages/evil-1.2.14/lib")
(require 'evil)
(evil-mode 1)
#+END_SRC

Rebind the ~q~ and ~quit~ commands to make more sense.

#+BEGIN_SRC emacs-lisp
(evil-ex-define-cmd "q" 'kill-this-buffer) ; :q should kill the buffer rather
                                        ; than quiting emacs
(evil-ex-define-cmd "quit" 'evil-quit-all) ; :quit to quit emacs
;; Deal with common mistakes
(evil-ex-define-cmd "W"  'evil-write)
(evil-ex-define-cmd "Wq" 'evil-save-and-close)
(evil-ex-define-cmd "WQ" 'evil-save-and-close)

(evil-define-command evil-save-and-kill-buffer (file &optional bang)
  "Save current buffer and close buffer.
Override for :wq"
  :repeat nil
  (interactive "<f><!>")
  (evil-write nil nil nil file bang)
  (kill-this-buffer))
(evil-ex-define-cmd "wq" 'evil-save-and-kill-buffer)
#+END_SRC

Set initial states
#+BEGIN_SRC emacs-lisp
(evil-set-initial-state 'vc-annotate-mode 'motion)
#+END_SRC

** evil-leader
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/evil-leader-0.4.3")
(require 'evil-leader)
(global-evil-leader-mode)
#+END_SRC

** evil-org
#+BEGIN_SRC emacs-lisp
(add-to-list
 'load-path
 "~/.emacs.d/packages/evil-org-mode-b6d652a9163d3430a9e0933a554bdbee5244bbf6")
(require 'evil-org)
(add-hook 'org-mode-hook 'evil-org-mode)
(evil-org-set-key-theme '(navigation insert textobjects additional calendar shift todo heading))
(add-hook 'org-mode-hook
          (lambda () (setq evil-auto-indent nil)))
(require 'evil-org-agenda)
(evil-org-agenda-set-keys)

;; When using emacs in a terminal, many keys do not work.
;; Fix them here
(evil-define-key 'motion org-agenda-mode-map
  (kbd "RET") 'org-agenda-switch-to
  (kbd "TAB") 'org-agenda-goto)

(evil-define-key '(normal visual) evil-org-mode-map
  (kbd "TAB") 'org-cycle
  (kbd "<backtab>") 'org-shifttab)
#+END_SRC

** evil-numbers
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/evil-numbers-0.4")
(require 'evil-numbers)
#+END_SRC

** evil-quickscope
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/evil-quickscope-0.1.4")
(require 'evil-quickscope)
(global-evil-quickscope-mode 1)
#+END_SRC

** ivy / swiper / counsel
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/swiper-0.11.0")
(require 'ivy)
(require 'swiper)
(require 'counsel)
(setq ivy-use-virtual-buffers t)
(setq ivy-count-format "(%d/%d) ")
(ivy-mode 1)

;; Setting up more ivy completion
(setq org-outline-path-complete-in-steps nil)
(setq org-completion-use-ido nil)

;; Remove the Shift-SPACE shortcut.
;; I keep accidentally activating it.
(define-key ivy-minibuffer-map (kbd "S-SPC") nil)
#+END_SRC

** projectile
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/projectile-2.0.0")
(require 'projectile)
(projectile-mode +1)
(setq projectile-project-search-path '("~/projects/")) ; where the projects are
(setq projectile-completion-system 'ivy)
#+END_SRC

** counsel-projectile
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/counsel-projectile-0.3.0")
(require 'counsel-projectile)
(setq counsel-projectile-grep-initial-input '(ivy-thing-at-point))
                                        ; this required a fix that was taken
                                        ; from commit a07ddc8
#+END_SRC

** rainbow-delimiters
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/rainbow-delimiters-2.1.3")
(require 'rainbow-delimiters)
#+END_SRC

Set the colours to be as distinct as possible.

#+BEGIN_SRC emacs-lisp
(set-face-attribute 'rainbow-delimiters-depth-1-face nil :foreground "#e6194b")
(set-face-attribute 'rainbow-delimiters-depth-2-face nil :foreground "#3cb44b")
(set-face-attribute 'rainbow-delimiters-depth-3-face nil :foreground "#ffe119")
(set-face-attribute 'rainbow-delimiters-depth-4-face nil :foreground "#4363d8")
(set-face-attribute 'rainbow-delimiters-depth-5-face nil :foreground "#f58231")
(set-face-attribute 'rainbow-delimiters-depth-6-face nil :foreground "#911eb4")
(set-face-attribute 'rainbow-delimiters-depth-7-face nil :foreground "#42d4f4")
(set-face-attribute 'rainbow-delimiters-depth-8-face nil :foreground "#f032e6")
(set-face-attribute 'rainbow-delimiters-depth-9-face nil :foreground "#bfef45")
(set-face-attribute 'rainbow-delimiters-unmatched-face nil
                    :background "#ff0000"
                    :foreground "#ffffff")
#+END_SRC

** beacon
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/beacon-1.3.4")
(require 'beacon)
(beacon-mode 1)
#+END_SRC

** json-mode
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/json-snatcher-1.0.0")
(add-to-list 'load-path "~/.emacs.d/packages/json-reformat-0.0.6")
(add-to-list 'load-path "~/.emacs.d/packages/json-mode-1.7.0")
(require 'json-mode)
#+END_SRC

** telephone-line
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/telephone-line-0.4")
(require 'telephone-line)
#+END_SRC

Telephone line customization.

#+BEGIN_SRC emacs-lisp
(setq telephone-line-lhs
      '((evil   . (telephone-line-evil-tag-segment))
        (accent . (telephone-line-vc-segment
                   telephone-line-erc-modified-channels-segment
                   telephone-line-process-segment))
        (nil    . (telephone-line-buffer-segment))))
(setq telephone-line-rhs
      '((nil    . (telephone-line-misc-info-segment))
        (accent . (telephone-line-major-mode-segment))
        (evil   . (telephone-line-airline-position-segment))))
(telephone-line-mode 1)
#+END_SRC

** nlinum-relative
nlinum is a dependency.

Delay is kinda required or else files with loads of lines tend to lag.

#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/nlinum-1.8.1")
(require 'nlinum)

(add-to-list
 'load-path
 "~/.emacs.d/packages/nlinum-relative-5b9950c97ba79a6f0683e38b13da23f39e01031c")
(require 'nlinum-relative)
(nlinum-relative-setup-evil)
(global-nlinum-relative-mode)
(setq nlinum-relative-redisplay-delay 0.2) ; delay
(setq nlinum-relative-current-symbol "") ; e.g. "->"
                                        ; "" for display current line number
(setq nlinum-relative-offset 0)          ; 1 if you want 0, 2, 3...
#+END_SRC

I want relative numbers to display when in evil operator mode.

#+BEGIN_SRC emacs-lisp
(add-hook 'evil-operator-state-entry-hook
          (lambda () (when (bound-and-true-p nlinum-relative-mode)
                       (nlinum-relative-on))))
(add-hook 'evil-operator-state-exit-hook
          (lambda () (when (bound-and-true-p nlinum-relative-mode)
                       (nlinum-relative-off))))
#+END_SRC

** diff-hl
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/diff-hl-1.8.6")
(require 'diff-hl)
(require 'diff-hl-flydiff)
(global-diff-hl-mode)
(diff-hl-flydiff-mode) ; Don't wait for save to calcualte diff
#+END_SRC

** erlang
#+BEGIN_SRC emacs-lisp
(defvar circ/enable-erlang t)
(when circ/enable-erlang
  (setq load-path (cons  "~/.emacs.d/packages/erlang-2.8.4" load-path))
  (setq erlang-root-dir "~/erl_rel/18.3")
  (setq exec-path (cons "~/erl_rel/18.3/bin" exec-path))
  (require 'erlang-start)
  (require 'erlang-flymake))
#+END_SRC

*** Use regular indenting for single '%' comments
#+BEGIN_SRC emacs-lisp
(defun circ/erlang-comment-indent ()
  (cond ((looking-at "%%%") 0)
        ((looking-at "%%")
         (or (erlang-calculate-indent)
             (current-indentation)))
        ((looking-at "%")
         (or (erlang-calculate-indent)
             (current-indentation)))
        (t
         (save-excursion
           (skip-chars-backward " \t")
           (max (if (bolp) 0 (1+ (current-column)))
                comment-column)))))

(advice-add
   'erlang-comment-indent
   :override
   (lambda (&rest r) (circ/erlang-comment-indent))
   '((name . "erlang-comment-indent-advice")))
#+END_SRC

** term mode
Set colours to be more readable

#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'term
  (set-face-attribute 'term-color-green   nil :foreground "#55ff55")
  (set-face-attribute 'term-color-blue    nil :foreground "#5555ff")
  (set-face-attribute 'term-color-red     nil :foreground "#ff5555")
  (set-face-attribute 'term-color-magenta nil :foreground "#ff55ff")
  (set-face-attribute 'term-color-cyan    nil :foreground "#55ffff")
  (set-face-attribute 'term-color-yellow  nil :foreground "#ffff55"))
#+END_SRC

Disable line number mode for term mode.
Requires this hacky double add hook thing because the
global-nlinum-relative-mode hook is run after the term-mode-hook

#+BEGIN_SRC emacs-lisp
(defun setup-term-mode ()
  "Counteract global nlinum mode"
  (add-hook 'after-change-major-mode-hook
            (lambda () (nlinum-mode 0))
            :append :local))

(add-hook 'term-mode-hook 'setup-term-mode)
#+END_SRC

Set normal / visual / operator mode to be line mode.
Set insert mode to be char mode.

=ignore-errors= added because this crashes term-mode from starting up.
I don't know why.

#+BEGIN_SRC emacs-lisp
(defun term-mode-normal-visual-operator-switch ()
  (when (equal major-mode 'term-mode) (ignore-errors (term-line-mode))))
(defun term-mode-insert-switch ()
  (when (equal major-mode 'term-mode) (ignore-errors (term-char-mode)) (end-of-buffer)))

(add-hook 'evil-normal-state-entry-hook 'term-mode-normal-visual-operator-switch)
(add-hook 'evil-visual-state-entry-hook 'term-mode-normal-visual-operator-switch)
(add-hook 'evil-operator-state-entry-hook 'term-mode-normal-visual-operator-switch)
(add-hook 'evil-insert-state-entry-hook 'term-mode-insert-switch)
#+END_SRC

Have the term buffer close automatically when the process has finished.

Source: https://oremacs.com/2015/01/01/three-ansi-term-tips/

#+BEGIN_SRC emacs-lisp
(defun auto-exit-term-exec-hook ()
  (let* ((buff (current-buffer))
         (proc (get-buffer-process buff)))
    (set-process-sentinel
     proc
     `(lambda (process event)
        (if (not (process-live-p process))
            (kill-buffer ,buff))))))

(add-hook 'term-exec-hook 'auto-exit-term-exec-hook)
#+END_SRC

** man
Open man pages in current window
#+BEGIN_SRC emacs-lisp
(setq Man-notify-method 'pushy)
#+END_SRC

** mpccp
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/mpccp")
(require 'mpccp)
(setq mpccp-playlist-directory "/mnt/slave/playlists")
#+END_SRC
** Dashboard
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/dashboard")
(require 'dashboard)
(setq dashboard-persistent-links
      '("file:~/.emacs.d/configuration.org"
        "file:~/.emacs.d/settings.org"
        "file:~/.emacs.d/personalsettings.org"
        "url:http://duckduckgo.com"))
(setq initial-buffer-choice 'dashboard)
(add-hook 'dashboard-mode-hook 'circ/disable-evil-quickscope-mode)
#+END_SRC
** eww
Evil bindings for =eww=.
#+BEGIN_SRC emacs-lisp
(evil-define-key 'normal eww-mode-map
  (kbd "H") 'eww-back-url
  (kbd "L") 'eww-forward-url
  (kbd "[") 'shr-previous-link
  (kbd "]") 'shr-next-link
  (kbd "d") 'evil-scroll-down
  (kbd "u") 'evil-scroll-up
  (kbd "o") 'eww
  (kbd "r") 'eww-reload
  (kbd "R") 'eww-readable
  (kbd "q") 'kill-this-buffer
)
#+END_SRC

Rename buffers to allow for more than one =eww= buffer.
#+BEGIN_SRC emacs-lisp
(defun circ/rename-eww-hook ()
  "Rename eww buffer with page title for easier buffer finding and to allow
multiple eww buffers to be open"
  (let ((current-title (plist-get eww-data :title)))
    (rename-buffer (concat "*" "eww" " " "(" current-title ")" "*" )
                   t)))
(add-hook 'eww-mode-hook #'circ/rename-eww-hook)
(add-hook 'eww-after-render-hook #'circ/rename-eww-hook)
#+END_SRC
** elfeed
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/elfeed-7b2b6fadaa498fef2ba212a50da4a8afa2a5d305")
(require 'elfeed)
(setq elfeed-db-directory "~/rss_elfeed/elfeed/")
(add-hook 'elfeed-search-mode-hook 'circ/disable-evil-quickscope-mode)
#+END_SRC

#+BEGIN_SRC emacs-lisp
;; Dependencies
(add-to-list 'load-path "~/.emacs.d/packages/dash.el-2.16.0")
(add-to-list 'load-path "~/.emacs.d/packages/s.el-43ba8b563bee3426cead0e6d4ddc09398e1a349d")

(add-to-list 'load-path "~/.emacs.d/packages/elfeed-org-77b6bbf222487809813de260447d31c4c59902c9")
(require 'elfeed-org)
(elfeed-org)
(setq rmh-elfeed-org-files (list "~/rss_elfeed/rss_feeds.org"))
#+END_SRC

Open in eww readable
#+BEGIN_SRC emacs-lisp
(defun circ/eww-readable (url &rest args)
  (interactive)
  (eww url)
  (add-hook 'eww-after-render-hook 'eww-readable nil t))

(defun circ/open-in-mpv (url &rest args)
  (message "Opening in mpv: %s" url)
  (call-process "mpv" nil 0 nil url))

(defun circ/elfeed-show-open-in-mpv ()
  (interactive)
  (let ((browse-url-browser-function 'circ/open-in-mpv)) (elfeed-show-visit)))
(defun circ/elfeed-show-open-eww-readable()
  (interactive)
  (let ((browse-url-browser-function 'circ/eww-readable)) (elfeed-show-visit)))
(defun circ/elfeed-show-open-eww()
  (interactive)
  (let ((browse-url-browser-function 'eww-browse-url)) (elfeed-show-visit)))

(defun circ/elfeed-search-open-in-mpv ()
  (interactive)
  (let ((browse-url-browser-function 'circ/open-in-mpv)) (elfeed-search-browse-url)))
(defun circ/elfeed-search-open-eww-readable()
  (interactive)
  (let ((browse-url-browser-function 'circ/eww-readable)) (elfeed-search-browse-url)))
(defun circ/elfeed--search-open-eww()
  (interactive)
  (let ((browse-url-browser-function 'eww-browse-url)) (elfeed-search-browse-url)))

(defun circ/elfeed-search-tag-saved ()
  (interactive)
  (let ((elfeed-search-remain-on-entry t))
    (elfeed-search-tag-all 'saved)
    (elfeed-search-untag-all 'unread))
  (forward-line))
(defun circ/elfeed-search-untag-saved ()
  (interactive)
  (elfeed-search-untag-all 'saved))
(defun circ/elfeed-show-tag-saved ()
  (interactive)
  (elfeed-show-tag 'saved))
(defun circ/elfeed-show-untag-saved ()
  (interactive)
  (elfeed-show-untag 'saved))

(defun circ/elfeed-load-and-open ()
  (interactive)
  (elfeed-db-load)
  (elfeed))
(defun circ/elfeed-save-and-close ()
  (interactive)
  (elfeed-db-save)
  (kill-this-buffer))
(defun circ/elfeed-db-reload ()
  (interactive)
  (elfeed-db-load)
  (elfeed-search-update--force))

(defun circ/open-rss-elfeed-file ()
  (interactive)
  (find-file "~/rss_elfeed/rss_feeds.org"))
#+END_SRC

Completing read tag editing
#+BEGIN_SRC emacs-lisp
(defun circ/elfeed-add-search-filter-tag ()
  (interactive)
  (unwind-protect
      (let* ((tags (elfeed-db-get-all-tags))
             (current-filter elfeed-search-filter)
             (current-tags (plist-get (elfeed-search-parse-filter current-filter)
                                      :must-have))
             (tag-candidates (set-difference tags current-tags)) ; Order of lists matter
             (new-tag (completing-read "Add tag: " tag-candidates))
             (new-filter (concat current-filter " +" new-tag)))
        (setq elfeed-search-filter new-filter)
        (elfeed-search-update :force))))

(defun circ/elfeed-remove-search-filter-tag ()
  (interactive)
  (unwind-protect
      (let* ((tags (elfeed-db-get-all-tags))
             (current-filter elfeed-search-filter)
             (current-tags (plist-get (elfeed-search-parse-filter current-filter)
                                      :must-have))
             (tag-candidates (intersection tags current-tags))
             (remove-tag (completing-read "Remove tag: " tag-candidates))
             (new-filter (string-trim
                          (replace-regexp-in-string
                           (regexp-quote "  ") " "
                           (replace-regexp-in-string
                            (regexp-quote (concat "+" remove-tag)) "" current-filter)))))
        (setq elfeed-search-filter new-filter)
        (elfeed-search-update :force))))
#+END_SRC

Evil Keybindings
#+BEGIN_SRC emacs-lisp
(evil-set-initial-state 'elfeed-search-mode 'motion)
(evil-define-key 'motion elfeed-search-mode-map
  (kbd "RET") 'elfeed-search-show-entry
  (kbd "S-<return>") 'elfeed-search-browse-url
  "b" 'elfeed-search-browse-url
  "y" 'elfeed-search-yank
  (kbd "SPC") 'scroll-up-command
  (kbd "S-SPC") 'scroll-down-command
  (kbd "TAB") 'elfeed-show-next-link
  "/" 'elfeed-search-live-filter
  "r" 'elfeed-search-update--force
  "R" 'elfeed-search-fetch
  "gR" 'circ/elfeed-db-reload
  "s" 'circ/elfeed-search-tag-saved
  "S" 'circ/elfeed-search-untag-saved
  "t" 'circ/elfeed-add-search-filter-tag
  "T" 'circ/elfeed-remove-search-filter-tag
  "o" 'nil
  "or" 'circ/elfeed-search-open-eww-readable
  "oe" 'circ/elfeed-search-open-eww
  "ov" 'circ/elfeed-search-open-in-mpv
  "ob" 'elfeed-search-browse-url
  "f" 'circ/open-rss-elfeed-file
  "d" 'evil-scroll-down
  "u" 'evil-scroll-up
  "q" 'circ/elfeed-save-and-close)

(evil-define-key '(motion visual) elfeed-search-mode-map
  "+" 'elfeed-search-tag-all
  "-" 'elfeed-search-untag-all
  "M" 'elfeed-search-tag-all-unread
  "m" 'elfeed-search-untag-all-unread)

(evil-set-initial-state 'elfeed-show-mode 'motion)
(evil-define-key 'motion elfeed-show-mode-map
  "b" 'elfeed-show-visit
  (kbd "SPC") 'scroll-up-command
  (kbd "S-SPC") 'scroll-down-command
  (kbd "<tab>") 'elfeed-show-next-link
  (kbd "TAB") 'elfeed-show-next-link
  "/" 'elfeed-show-new-live-search
  "+" 'elfeed-show-tag
  "-" 'elfeed-show-untag
  "]]" 'elfeed-show-next
  "[[" 'elfeed-show-prev
  "J" 'elfeed-show-next
  "K" 'elfeed-show-prev
  "n" 'elfeed-show-next
  "p" 'elfeed-show-prev
  "r" 'elfeed-show-refresh
  "q" 'elfeed-kill-buffer
  "o" 'nil
  "or" 'circ/elfeed-show-open-eww-readable
  "oe" 'circ/elfeed-show-open-eww
  "ov" 'circ/elfeed-show-open-in-mpv
  "ob" 'elfeed-show-visit
  "y" 'elfeed-show-yank
  "d" 'evil-scroll-down
  "u" 'evil-scroll-up
  "s" 'circ/elfeed-show-tag-saved
  "S" 'circ/elfeed-show-untag-saved)
#+END_SRC
** notmuch
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path circ/notmuch-load-path)
(require 'notmuch)

(setq send-mail-function 'sendmail-send-it
      sendmail-program "/usr/bin/msmtp"
      mail-specify-envelope-from t
      message-sendmail-envelope-from 'header
      mail-envelope-from 'header)

(setq notmuch-archive-tags '("-inbox" "+archive" "-unread"))
(setq notmuch-show-all-tags-list t) ; Always show the tags
(setq notmuch-show-logo nil) ; No image please

(add-hook 'notmuch-hello-mode-hook 'circ/disable-evil-quickscope-mode)
(add-hook 'notmuch-search-mode-hook 'circ/disable-evil-quickscope-mode)
(add-hook 'notmuch-show-mode-hook 'circ/disable-evil-quickscope-mode)
(add-hook 'notmuch-tree-mode-hook 'circ/disable-evil-quickscope-mode)

(setq notmuch-saved-searches
      '((:name "inbox"
               :query "tag:inbox"
               :key "i")
        (:name "unread"
               :query "tag:unread"
               :key "u")
        (:name "flagged"
               :query "tag:flagged"
               :key "f")
        (:name "sent"
               :query "tag:sent"
               :key "t")
        (:name "drafts"
               :query "tag:draft"
               :key "d")
        (:name "all mail"
               :query "*"
               :key "a")
        (:name "gmail inbox"
               :query "path:gmail/** tag:inbox"
               :key "g")
        (:name "mailbox inbox"
               :query "path:mailbox/** tag:inbox"
               :key "m")))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun circ/notmuch-search ()
  (interactive)
  (let* ((search-history (cons "<NEW>" notmuch-search-history))
         (ivy-sort-functions-alist nil) ; to disable sorting
         (search-string (completing-read "Search: " search-history))
         (user-search-string (read-string "Search: " (cond ((string= search-string "<NEW>") "")
                                                           (t search-string)))))
    (push user-search-string notmuch-search-history)
    (notmuch-search user-search-string)))

(defun circ/message-set-sender ()
  (interactive)
  (let* ((curr-sender (message-fetch-field "from"))
         (desired-sender (completing-read "From: " circ/message-from-addresses))
         (curr-point (point)))
    (message-remove-header "From")
    (goto-char (point-min))
    (insert "From: " desired-sender "\n")
    (goto-char (- curr-point (- (length curr-sender) (length desired-sender))))))

(defun circ/notmuch-search-mark-delete ()
  (interactive)
  (notmuch-search-tag
   (notmuch-tag-change-list '("-inbox" "-unread" "+deleted"))))

(defun circ/notmuch-search-mark-read ()
  (interactive)
  (notmuch-search-tag
   (notmuch-tag-change-list '("-unread"))))

(defun circ/notmuch-search-mark-unread ()
  (interactive)
  (notmuch-search-tag
   (notmuch-tag-change-list '("+unread"))))

(defun circ/notmuch-show-mark-delete ()
  (interactive)
  (notmuch-show-tag
   (notmuch-tag-change-list '("-inbox" "-unread" "+deleted"))))

(defun circ/notmuch-show-mark-read ()
  (interactive)
  (notmuch-show-tag
   (notmuch-tag-change-list '("-unread"))))

(defun circ/notmuch-show-mark-unread ()
  (interactive)
  (notmuch-show-tag
   (notmuch-tag-change-list '("+unread"))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun circ/notmuch-update-emails ()
  (interactive)
  (circ/notify "Email update started" 10)
  (circ/run-proc-and-fun
   "email-update" "*email-update*" "~/"
   '("mbsync" "-a") t
   (lambda ()
     (circ/run-proc-and-fun
      "email-update" "*email-update*" "~/"
      '("notmuch" "new") t
      (lambda ()
        (circ/notify "Email update finished" 10)
        (notmuch-refresh-all-buffers))))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(evil-set-initial-state 'notmuch-hello-mode 'motion)
(evil-set-initial-state 'notmuch-search-mode 'motion)
(evil-set-initial-state 'notmuch-show-mode 'motion)
(evil-set-initial-state 'notmuch-tree-mode 'motion)

(defun circ/evil-set-notmuch-keys ()
  (interactive)
  (evil-define-key 'motion notmuch-common-keymap
    "?" 'notmuch-help
    "q" 'notmuch-bury-or-kill-this-buffer
    "r" 'notmuch-refresh-this-buffer
    "R" 'circ/notmuch-update-emails
    "J" 'notmuch-jump-search
    "/" 'circ/notmuch-search
    "c" 'notmuch-mua-new-mail
    "d" 'evil-scroll-down
    "u" 'evil-scroll-up
    )

  (evil-define-key 'motion notmuch-hello-mode-map
    (kbd "TAB") 'widget-forward
    (kbd "S-TAB") 'widget-backward
    "d" 'evil-scroll-down
    "u" 'evil-scroll-up
    )

  (evil-define-key '(motion visual) notmuch-search-mode-map
    "*" 'notmuch-search-tag-all
    "o" 'notmuch-search-toggle-order
    "r" 'notmuch-search-reply-to-thread-sender
    "R" 'circ/notmuch-update-emails
    [mouse-1] 'notmuch-search-show-thread
    "-" 'notmuch-search-remove-tag
    "+" 'notmuch-search-add-tag
    (kbd "RET") 'notmuch-search-show-thread
    "t" 'notmuch-search-filter-by-tag
    "f" 'notmuch-search-filter
    "d" 'evil-scroll-down
    "u" 'evil-scroll-up
    "a" 'notmuch-search-archive-thread
    "x" 'circ/notmuch-search-mark-delete
    "m" 'circ/notmuch-search-mark-read
    "M" 'circ/notmuch-search-mark-unread
    "zv" 'notmuch-tree-from-search-current-query
    )

  (evil-define-key 'motion notmuch-show-mode-map
    "p" 'notmuch-show-save-attachments
    "gd" 'goto-address-at-point
    "A" 'notmuch-show-archive-thread-then-next
    "r" 'notmuch-show-reply-sender
    "R" 'notmuch-show-reply
    "a" 'notmuch-show-archive-message-then-next-or-next-thread
    "d" 'evil-scroll-down
    "u" 'evil-scroll-up
    "x" 'circ/notmuch-show-mark-delete
    "m" 'circ/notmuch-show-mark-read
    "M" 'circ/notmuch-show-mark-unread
    "]]" 'notmuch-show-next-thread-show
    "[[" 'notmuch-show-previous-thread-show
    "J" 'notmuch-show-next-message
    "K" 'notmuch-show-previous-message
    "-" 'notmuch-show-remove-tag
    "+" 'notmuch-show-add-tag
    "*" 'notmuch-show-tag-all
    "H" 'notmuch-show-toggle-visibility-headers
    "o" 'notmuch-show-part-map
    (kbd "RET") 'notmuch-show-toggle-message
    (kbd "TAB") 'notmuch-show-next-button
    (kbd "<backtab>") 'notmuch-show-previous-button
    "zv" 'notmuch-tree-from-show-current-query
    )

  (evil-define-key 'motion notmuch-tree-mode-map
    "d" 'evil-scroll-down
    "u" 'evil-scroll-up
    "q" 'notmuch-tree-quit
    )
  )

(circ/evil-set-notmuch-keys)
#+END_SRC
** emux
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/emux")
(require 'emux)
#+END_SRC
** abbrev
#+BEGIN_SRC emacs-lisp
(setq abbrev-file-name "~/pims/abbrev_defs.el")
(setq-default abbrev-mode t)

(defun circ/add-abbrev ()
  (interactive)
  (let ((num-of-words (cond ((region-active-p) (count-words-region
                                                (region-beginning)
                                                (region-end)))
                            (t 1)))
        (mode-specific (y-or-n-p "Specific to mode? ")))
    (goto-char (region-end))
    (deactivate-mark)
    (if mode-specific
        (add-mode-abbrev num-of-words)
      (add-global-abbrev num-of-words)))
  (write-abbrev-file abbrev-file-name t))

(defun circ/reload-abbrevs ()
  (interactive)
  (kill-all-abbrevs)
  (read-abbrev-file))
#+END_SRC
** general
#+BEGIN_SRC emacs-lisp
(add-to-list
 'load-path
 "~/.emacs.d/packages/general-2d2dd1d532fa75c1ed0c010d50e817ce43e58066/")
(require 'general)
(general-auto-unbind-keys)
#+END_SRC

* Keybindings
** Aliases
To keep the code nice and clean.
#+BEGIN_SRC emacs-lisp
(defun circ/alias-text-scale-down () (interactive) (text-scale-adjust -1))
(defun circ/alias-text-scale-up   () (interactive) (text-scale-adjust +1))

(defun circ/alias-search-buffer () (interactive) (swiper (ivy-thing-at-point)))

(defun circ/alias-transpose-buffer-left  () (interactive) (circ/transpose-buffers-left t))
(defun circ/alias-transpose-buffer-down  () (interactive) (circ/transpose-buffers-down t))
(defun circ/alias-transpose-buffer-up    () (interactive) (circ/transpose-buffers-up t))
(defun circ/alias-transpose-buffer-right () (interactive) (circ/transpose-buffers-right t))

(defun circ/alias-cast-buffer-left  () (interactive) (circ/cast-buffer-left t))
(defun circ/alias-cast-buffer-down  () (interactive) (circ/cast-buffer-down t))
(defun circ/alias-cast-buffer-up    () (interactive) (circ/cast-buffer-up t))
(defun circ/alias-cast-buffer-right () (interactive) (circ/cast-buffer-right t))

(defun circ/alias-duplicate-buffer-left  () (interactive) (circ/duplicate-buffer-left t))
(defun circ/alias-duplicate-buffer-down  () (interactive) (circ/duplicate-buffer-down t))
(defun circ/alias-duplicate-buffer-up    () (interactive) (circ/duplicate-buffer-up t))
(defun circ/alias-duplicate-buffer-right () (interactive) (circ/duplicate-buffer-right t))

(defun circ/alias-erlang-find-tag () (interactive) (erlang-find-tag (erlang-default-function-or-module)))

(defun circ/alias-bash-shell () (interactive) (ansi-term "/bin/bash"))
(defun circ/alias-clip-shell () (interactive) (ansi-term "/usr/bin/clisp"))
(defun circ/alias-python-shell () (interactive) (ansi-term "/usr/bin/python"))

(defun circ/alias-org-force-publish () (interactive) (org-publish-current-project t))

(defun circ/alias-org-agenda-agenda () (interactive) (org-agenda nil "A"))
(defun circ/alias-org-agenda-tasks () (interactive) (org-agenda nil "T"))

(defun circ/alias-sh-cmd-whole-buffer () (interactive) (circ/sh-cmd nil t nil))
(defun circ/alias-sh-cmd-split-lines () (interactive) (circ/sh-cmd nil nil t))
(defun circ/alias-sh-cmd-whole-buffer-split-lines () (interactive) (circ/sh-cmd nil t t))

(setq circ/vert-resize-delta 5)
(setq circ/horz-resize-delta 10)

(defvar circ/vert-resize-delta 1)
(defvar circ/horz-resize-delta 1)
(defun circ/alias-shrink-win-horz  () (interactive) (shrink-window-horizontally circ/horz-resize-delta))
(defun circ/alias-enlarge-win-horz () (interactive) (enlarge-window-horizontally circ/horz-resize-delta))
(defun circ/alias-shrink-win-vert  () (interactive) (shrink-window circ/vert-resize-delta))
(defun circ/alias-enlarge-win-vert () (interactive) (enlarge-window circ/vert-resize-delta))
#+END_SRC

** Helper Functions
#+BEGIN_SRC emacs-lisp
(setq circ/p1-prefix-normal   "C-M-S-")
(setq circ/p1-prefix-special  "C-M-")
(setq circ/p1-prefix-standard "M-f")

(setq circ/p2-prefix-normal   "s-M-S-")
(setq circ/p2-prefix-special  "s-M-")
(setq circ/p2-prefix-standard "M-d")

(setq circ/p3-prefix-normal   "s-C-S-")
(setq circ/p3-prefix-special  "s-C-")
(setq circ/p3-prefix-standard "M-s")

(setq circ/p4-prefix-normal   "s-C-M-")
(setq circ/p4-prefix-special  "s-C-M-")
(setq circ/p4-prefix-standard "M-a")

(defun circ/p1 (key command description &optional keymap)
  (let* ((prefix-normal   circ/p1-prefix-normal)
         (prefix-special  circ/p1-prefix-special)
         (standard-prefix circ/p1-prefix-standard)
         (prefix-key (cond ((string= key ";") (concat prefix-special ":"))
                           ((string= key "-") (concat prefix-special "_"))
                           ((string= key "=") (concat prefix-special "+"))
                           ((string= key ",") (concat prefix-special "<"))
                           ((string= key ".") (concat prefix-special ">"))
                           ((string= key "/") (concat prefix-special "?"))
                           (t (concat prefix-normal key))))
         (standard-prefix-key (concat standard-prefix " " key)))
    (circ/set-keys prefix-key standard-prefix-key command description keymap)))

(defun circ/p2 (key command description &optional keymap)
  (let* ((prefix-normal   circ/p2-prefix-normal)
         (prefix-special  circ/p2-prefix-special)
         (standard-prefix circ/p2-prefix-standard)
         (prefix-key (cond (t (concat prefix-special (upcase (substring key 0 1)) (substring key 1)))))
         (standard-prefix-key (concat standard-prefix " " key)))
    (circ/set-keys prefix-key standard-prefix-key command description keymap)))

(defun circ/p3 (key command description &optional keymap)
  (let* ((prefix-normal   circ/p3-prefix-normal)
         (prefix-special  circ/p3-prefix-special)
         (standard-prefix circ/p3-prefix-standard)
         (prefix-key (cond (t (concat prefix-special (upcase (substring key 0 1)) (substring key 1)))))
         (standard-prefix-key (concat standard-prefix " " key)))
    (circ/set-keys prefix-key standard-prefix-key command description keymap)))

(defun circ/p4 (key command description &optional keymap)
  (let* ((prefix-normal   circ/p4-prefix-normal)
         (prefix-special  circ/p4-prefix-special)
         (standard-prefix circ/p4-prefix-standard)
         (prefix-key (cond (t (concat prefix-normal key ))))
         (standard-prefix-key (concat standard-prefix " " key)))
    (circ/set-keys prefix-key standard-prefix-key command description keymap)))

(defun circ/set-keys (prefix-key standard-prefix-key command description &optional keymap)
  (cond (command
         (circ/set-key prefix-key command description keymap)
         (circ/set-key standard-prefix-key command description keymap))
        (t
         (circ/set-prefix prefix-key description keymap)
         (circ/set-prefix standard-prefix-key description keymap))))

(defun circ/set-prefix (key description &optional keymap)
  (cond (keymap
         (general-define-key
           :keymaps keymap
           :states '(normal insert visual operator motion emacs)
           key (list :ignore t :which-key description)))
        (t
         (general-define-key
           :states '(normal insert visual operator motion emacs)
           key (list :ignore t :which-key description)))))

(defun circ/set-key (key command description &optional keymap)
  (cond (keymap
         (general-define-key
          :keymaps keymap
          :states '(normal insert visual operator motion emacs)
          key (list command :which-key description)))
        (t
         (general-define-key
          :states '(normal insert visual operator motion emacs)
          key (list command :which-key description)))))

#+END_SRC

** Term Mode Keys
Evil-mode interferes with the normal bash bindings. They must be dealt with.

*** C-a     - Go to beginning of line
#+BEGIN_SRC emacs-lisp
(evil-define-key 'insert term-raw-map (kbd "C-a") 'term-send-raw)
#+END_SRC

*** C-e     - Go to end of line
#+BEGIN_SRC emacs-lisp
(evil-define-key 'insert term-raw-map (kbd "C-e") 'term-send-raw)
#+END_SRC

*** M-f     - Go to next word
Interferes with my custom invokers.

*** M-b     - Go to previous word
Already build in.

*** C-x x   - Toggle point between current position and start of line
C-x interferes with emacs a lot. I am leaving this out one.

*** M-d     - Delete next word
Interferes with my custom invokers.

*** C-x C-e - Edit the current command in your text editor
Danger! Having this makes it too easy to invoke vim from within emacs.

Bad idea.

*** C--     - Undo previous action(s)
Does anyone use this? I won't. Leaving it out.

*** C-w     - Cut current word before the cursor
#+BEGIN_SRC emacs-lisp
(evil-define-key 'insert term-raw-map (kbd "C-w") 'term-send-raw)
#+END_SRC

*** C-k     - Cut from cursor to end of line
#+BEGIN_SRC emacs-lisp
(evil-define-key 'insert term-raw-map (kbd "C-k") 'term-send-raw)
#+END_SRC

*** C-u     - Cut from cursor to start of line
#+BEGIN_SRC emacs-lisp
(evil-define-key 'insert term-raw-map (kbd "C-u") 'term-send-raw)
#+END_SRC

*** C-y     - Paste the cut buffer at current position
#+BEGIN_SRC emacs-lisp
(evil-define-key 'insert term-raw-map (kbd "C-y") 'term-send-raw)
#+END_SRC

*** C-d     - Send EOF / Delete current character
#+BEGIN_SRC emacs-lisp
(evil-define-key 'insert term-raw-map (kbd "C-d") 'term-send-raw)
#+END_SRC

*** C-l     - Clear the terminal screen
Already built-in.

*** C-z     - Send current command to the background.
#+BEGIN_SRC emacs-lisp
;; C-z is more useful as a switch between evil and emacs states
;; So a command is available instead
(defun term-send-current-command-to-background ()
  (interactive)
  (term-send-raw-string "\C-z"))
#+END_SRC

*** C-r - Search history
#+BEGIN_SRC emacs-lisp
;(evil-define-key 'insert term-raw-map (kbd "C-r") 'term-send-raw)
(evil-define-key 'insert term-raw-map (kbd "C-r") 'circ/bash-history-search)
#+END_SRC

*** C-<backspace> - Delete prevous word
Not strictly a bash thing, but I'm putting it in anyway.
Simply send C-w instead
#+BEGIN_SRC emacs-lisp
(evil-define-key 'insert term-raw-map (kbd "C-<backspace>")
  'circ/term/delete-previous-word)
#+END_SRC

*** C-<delete> - Delete next word
Not strictly a bash thing, but I'm putting it in anyway.
Simply send M-d instead
#+BEGIN_SRC emacs-lisp
(evil-define-key 'insert term-raw-map (kbd "C-<delete>")
  'circ/term/delete-next-word)
#+END_SRC

*** C-<left> - Go to previous word
Not strictly a bash thing, but I'm putting it in anyway.
Simply send M-b instead
#+BEGIN_SRC emacs-lisp
(evil-define-key 'insert term-raw-map (kbd "C-<left>")
  'circ/term/go-to-previous-word)
#+END_SRC

*** C-<right> - Go to next word
Not strictly a bash thing, but I'm putting it in anyway.
Simply send M-f instead
#+BEGIN_SRC emacs-lisp
(evil-define-key 'insert term-raw-map (kbd "C-<right>")
  'circ/term/go-to-next-word)
#+END_SRC

** Unbinding Keys
#+BEGIN_SRC emacs-lisp
;(general-unbind 
;  '(normal insert visual operator)
;  '(global-map org-mode-map evil-org-mode-map)
  ;"C-S-h"
  ;"C-S-j"
  ;"C-S-k"
  ;"C-S-l"
  ;"C-M-S-d"
;)

;; Prevent these from appearing in the standard keymap
(global-unset-key (kbd "M-s ESC"))
(global-unset-key (kbd "M-s ."))
(global-unset-key (kbd "M-s _"))
(global-unset-key (kbd "M-s o"))
(global-unset-key (kbd "M-s w"))
#+END_SRC

** P1
#+BEGIN_SRC emacs-lisp
;;FUN    KEY    FUNCTION                              DESCRIPTION                           MODE
(circ/p1 ","    'previous-buffer                      "prev buffer")
(circ/p1 "-"    'circ/alias-text-scale-down           "text scale down")
(circ/p1 "."    'next-buffer                          "next buffer")
(circ/p1 "/"    'circ/alias-search-buffer             "search buffer")
(circ/p1 ";"    'counsel-M-x                          "M-x")
(circ/p1 "="    'circ/alias-text-scale-up             "text scale up")
(circ/p1 "a"    'circ/add-abbrev                      "add abbrev")
(circ/p1 "b b"  'ivy-switch-buffer                    "switch buffers")
(circ/p1 "b c"  'nil                                  "cast buffers")
(circ/p1 "b ch" 'circ/alias-cast-buffer-left          "cast buffer left")
(circ/p1 "b cj" 'circ/alias-cast-buffer-down          "cast buffer down")
(circ/p1 "b ck" 'circ/alias-cast-buffer-up            "cast buffer up")
(circ/p1 "b cl" 'circ/alias-cast-buffer-right         "cast buffer right")
(circ/p1 "b d"  'nil                                  "duplicate buffers")
(circ/p1 "b dh" 'circ/alias-duplicate-buffer-left     "duplicate buffer left")
(circ/p1 "b dj" 'circ/alias-duplicate-buffer-down     "duplicate buffer down")
(circ/p1 "b dk" 'circ/alias-duplicate-buffer-up       "duplicate buffer up")
(circ/p1 "b dl" 'circ/alias-duplicate-buffer-right    "duplicate buffer right")
(circ/p1 "b f"  'circ/show-file-path                  "show file path")
(circ/p1 "b o"  'open-in-new-config                   "open buffer in a new window config")
(circ/p1 "b p"  'circ/buffer-paste                    "paste buffer")
(circ/p1 "b r"  'rename-buffer                        "rename buffer")
(circ/p1 "b t"  'nil                                  "transpose buffers")
(circ/p1 "b th" 'circ/alias-transpose-buffer-left     "transpose windows left")
(circ/p1 "b tj" 'circ/alias-transpose-buffer-down     "transpose windows down")
(circ/p1 "b tk" 'circ/alias-transpose-buffer-up       "transpose windows up")
(circ/p1 "b tl" 'circ/alias-transpose-buffer-right    "transpose windows right")
(circ/p1 "b x"  'circ/smart-clear-buffer              "clear buffer")
(circ/p1 "b y"  'circ/buffer-yank                     "yank buffer")
(circ/p1 "b"    'nil                                  "buffers")
(circ/p1 "c"    'delete-window                        "close window")
(circ/p1 "c"    'ranger-disable                       "close ranger"                        'ranger-mode-map)
(circ/p1 "d"    'evil-goto-definition                 "goto definition")
(circ/p1 "d"    'circ/alias-erlang-find-tag           "goto definition"                     'erlang-mode-map)
(circ/p1 "d"    'org-open-at-point                    "open link"                           'org-mode-map)
(circ/p1 "d"    'org-open-at-point                    "open link"                           'org-agenda-mode-map)
(circ/p1 "d"    'goto-address-at-point                "open link"                           'notmuch-show-mode-map)
(circ/p1 "e #"  'nil                                  "number increment / decrement")
(circ/p1 "e #a" 'evil-numbers/inc-at-pt               "increment")
(circ/p1 "e #x" 'evil-numbers/dec-at-pt               "decrement")
(circ/p1 "e a"  'nil                                  "align")
(circ/p1 "e aH" 'circ/align-repeat-head               "regex ahead of match repeatedly")
(circ/p1 "e aT" 'circ/align-repeat-tail               "regex to tail of match repeatedly")
(circ/p1 "e aa" 'erlang-align-arrows                  "align arrows"                        'erlang-mode-map)
(circ/p1 "e ah" 'circ/align-once-head                 "regex ahead of match")
(circ/p1 "e at" 'circ/align-once-tail                 "regex to tail of match")
(circ/p1 "e c"  'dabbrev-completion                   "dabbrev completion")
(circ/p1 "e d"  'erlang-clone-arguments               "duplicate arguments"                 'erlang-mode-map)
(circ/p1 "e f"  'nil                                  "formatting")
(circ/p1 "e fb" 'json-mode-beautify                   "json beautify"                       'json-mode-map)
(circ/p1 "e fi" 'indent-region                        "indent region")
(circ/p1 "e fp" 'fill-paragraph                       "fill paragraph")
(circ/p1 "e fr" 'fill-region                          "fill region")
(circ/p1 "e i"  'erlang-indent-region                 "indent region"                       'erlang-mode-map)
(circ/p1 "e j"  'erlang-generate-new-clause           "new clause"                          'erlang-mode-map)
(circ/p1 "e l"  'org-insert-link                      "edit link"                           'org-mode-map)
(circ/p1 "e s"  'nil                                  "surround")
(circ/p1 "e s'" 'circ/surround-s-quote                "single quote '")
(circ/p1 "e s(" 'circ/surround-parentheses            "parentheses ( )")
(circ/p1 "e s)" 'circ/surround-parentheses            "parentheses ( )")
(circ/p1 "e s*" 'circ/surround-asterisk               "asterisk *")
(circ/p1 "e s+" 'circ/surround-plus                   "plus +")
(circ/p1 "e s-" 'circ/surround-minus                  "minus -")
(circ/p1 "e s/" 'circ/surround-slash                  "slash /")
(circ/p1 "e s=" 'circ/surround-equals                 "equals =")
(circ/p1 "e s[" 'circ/surround-brackets               "brackets [ ]")
(circ/p1 "e s\"" 'circ/surround-d-quote               "double quote \"")
(circ/p1 "e s]" 'circ/surround-brackets               "brackets [ ]")
(circ/p1 "e ss" 'circ/surround-region                 "surround region")
(circ/p1 "e s{" 'circ/surround-braces                 "braces { }")
(circ/p1 "e s}" 'circ/surround-braces                 "braces { }")
(circ/p1 "e"    'nil                                  "edits")
(circ/p1 "f b"  'ivy-switch-buffer                    "buffers")
(circ/p1 "f d"  'dired-create-directory               "create directory"                    'ranger-mode-map)
(circ/p1 "f f"  'counsel-find-file                    "find file")
(circ/p1 "f h"  'org-html-export-to-html              "export to html"                      'org-mode-map)
(circ/p1 "f r"  'counsel-recentf                      "find recent file")
(circ/p1 "f s"  'nil                                  "scratch buffers")
(circ/p1 "f sj" 'new-scratch-json-mode                "json scratch buffer")
(circ/p1 "f st" 'new-scratch-text-mode                "text scratch buffer")
(circ/p1 "f so" 'new-scratch-org-mode                 "org scratch buffer")
(circ/p1 "f"    'nil                                  "files")
(circ/p1 "h"    'windmove-left                        "win left")
(circ/p1 "j"    'windmove-down                        "win down")
(circ/p1 "k"    'windmove-up                          "win up")
(circ/p1 "l"    'windmove-right                       "wind right")
(circ/p1 "o i"  'circ/open-in-intellij                "open in intellij")
(circ/p1 "o c"  'copy-buffer                          "copy buffer")
(circ/p1 "o m"  'mpccp                                "mpccp")
(circ/p1 "o r"  'circ/elfeed-load-and-open            "elfeed")
(circ/p1 "o e"  'notmuch                              "notmuch")
(circ/p1 "o x"  'emux                                 "emux")
(circ/p1 "o d"  'dashboard                            "dashboard")
(circ/p1 "o tc" 'circ/alias-clisp-shell               "clisp")
(circ/p1 "o te" 'erlang-shell                         "erlang")
(circ/p1 "o tp" 'circ/alias-python-shell              "python")
(circ/p1 "o tt" 'circ/ansi-term                       "bash")
(circ/p1 "o"    'nil                                  "applications")
(circ/p1 "p ?"  'projectile-command-map               "other")
(circ/p1 "p O"  'circ/alias-org-force-publish         "force org publish project"           'org-mode-map)
(circ/p1 "p b"  'projectile-switch-to-buffer          "switch project buffer")
(circ/p1 "p c"  'circ/check-project                   "check / compile project")
(circ/p1 "p f"  'counsel-projectile-find-file         "find project file")
(circ/p1 "p g"  'counsel-projectile-grep              "find instances in project")
(circ/p1 "p i"  'org-insert-link                      "insert link")
(circ/p1 "p o"  'org-publish-current-project          "org publish project"                 'org-mode-map)
(circ/p1 "p p"  'counsel-projectile-switch-project    "switch project")
(circ/p1 "p r"  'circ/revert-project-buffers          "revert project buffers")
(circ/p1 "p s"  'org-store-link                       "copy link")
(circ/p1 "p t"  'circ/regenerate-tags                 "regenerate tags")
(circ/p1 "p w"  'circ/save-project-buffers            "save all project buffers")
(circ/p1 "p w"  'org-save-all-org-buffers             "save all org buffers"                'org-mode-map)
(circ/p1 "p"    'nil                                  "projects")
(circ/p1 "q"    'circ/kill-this-buffer                "kill buffer")
(circ/p1 "q"    'copy-buffer-copy-quit           "copy buffer copy quit"                    'copy-buffer-mode-map)
(circ/p1 "r n"  'nil                                  "numbers")
(circ/p1 "r ni" 'increment-register                   "increment register with number")
(circ/p1 "r np" 'insert-register                      "paste number from register")
(circ/p1 "r ny" 'number-to-register                   "yank number to register")
(circ/p1 "r p"  'nil                                  "positions")
(circ/p1 "r pp" 'jump-to-register                     "goto register position")
(circ/p1 "r py" 'point-to-register                    "yank current position to register")
(circ/p1 "r r"  'nil                                  "rectangle")
(circ/p1 "r rp" 'insert-register                      "paste rectangle from register")
(circ/p1 "r ry" 'copy-rectangle-to-register           "yank rectangle to register")
(circ/p1 "r t"  'nil                                  "text")
(circ/p1 "r ta" 'append-to-register                   "append text to register")
(circ/p1 "r tb" 'prepend-to-register                  "prepend text to register (before)")
(circ/p1 "r tp" 'insert-register                      "paste text register")
(circ/p1 "r ty" 'copy-to-register                     "yank text to register")
(circ/p1 "r"    'nil                                  "registers")
(circ/p1 "t R"  'auto-revert-mode                     "toggle auto revert mode")
(circ/p1 "t W"  'circ/toggle-whitespace-full          "toggle whitespace full")
(circ/p1 "t c"  'comment-line                         "toggle comment line")
(circ/p1 "t f"  'font-lock-mode                       "toggle auto font formatting")
(circ/p1 "t h"  'hl-line-mode                         "toggle highight line mode")
(circ/p1 "t h"  'ranger-toggle-dotfiles               "toggle hidden"                       'ranger-mode-map)
(circ/p1 "t i"  'org-toggle-inline-images             "toggle images"                       'org-mode-map)
(circ/p1 "t l"  'nlinum-mode                          "toggle relative line numbers")
(circ/p1 "t p"  'projectile-mode                      "toggle projectile mode")
(circ/p1 "t r"  'rainbow-delimiters-mode              "toggle rainbow delimiters")
(circ/p1 "t t"  'nil                                  "tables"                              'org-mode-map)
(circ/p1 "t tr" 'org-table-toggle-coordinate-overlay  "toggle table coords"                 'org-mode-map)
(circ/p1 "t w"  'whitespace-mode                      "toggle whitespace display")
(circ/p1 "t a"  'abbrev-mode                          "toggle abbrev mode")
(circ/p1 "t"    'nil                                  "toggles")
(circ/p1 "v a"  'circ/vc-annotate-current-window      "annotate")
(circ/p1 "v b"  'vc-retrieve-tag                      "change branch")
(circ/p1 "v d"  'nil                                  "diff")
(circ/p1 "v dd" 'vc-version-ediff                     "version ediff")
(circ/p1 "v dm" 'circ/vc-diff-head-current            "compare current to head")
(circ/p1 "v D"  'vc-ediff                             "ediff")
(circ/p1 "v"    'nil                                  "version control")
(circ/p1 "w e"  'balance-windows                      "balance windows")
(circ/p1 "w h"  'split-window-right                   "split horizontal")
(circ/p1 "w o"  'delete-other-windows                 "delete other windows")
(circ/p1 "w r"  'revert-buffer                        "reload from disk")
(circ/p1 "w v"  'split-window-below                   "split vertical")
(circ/p1 "w z"  'maximize-window                      "maximize")
(circ/p1 "w"    'nil                                  "windows")
(circ/p1 "x"    'nil                                  "sh cmd")
(circ/p1 "x x"  'circ/sh-cmd                          "sh cmd")
(circ/p1 "x X"  'circ/alias-sh-cmd-whole-buffer       "sh cmd whole buffer")
(circ/p1 "x s"  'circ/alias-sh-cmd-split-lines        "sh cmd split lines")
(circ/p1 "x S"  'circ/alias-sh-cmd-whole-buffer-split-lines "sh cmd whole buffer split lines")
#+END_SRC

** P2
#+BEGIN_SRC emacs-lisp
;;       KEY    FUNCTION                              DESCRIPTION                           MODE
(circ/p2 "h"    'circ/alias-shrink-win-horz           "shrink horz"                         'override)
(circ/p2 "j"    'circ/alias-enlarge-win-vert          "enlarge vert"                        'override)
(circ/p2 "k"    'circ/alias-shrink-win-vert           "shrink vert"                         'override)
(circ/p2 "l"    'circ/alias-enlarge-win-horz          "enlarge horz"                        'override)
#+END_SRC

** P3
#+BEGIN_SRC emacs-lisp
;;       KEY    FUNCTION                              DESCRIPTION                           MODE
(circ/p3 "f r"  'circ/set-frame-name                  "rename frame")
(circ/p3 "f c"  'make-frame                           "create new frame")
(circ/p3 "f q"  'delete-frame                         "close frame")
(circ/p3 "f o"  'pop-out-config-to-new-frame          "pop out to frame")
(circ/p3 "f"    'nil                                  "frames")
(circ/p3 "h"    'evil-jump-backward                   "jump back")
(circ/p3 "l"    'evil-jump-forward                    "jump forward")
#+END_SRC

** P4
#+BEGIN_SRC emacs-lisp
;;       KEY    FUNCTION                              DESCRIPTION                           MODE
(circ/p4 "["    'org-previous-link                    "previous link"                       'org-mode-map)
(circ/p4 "]"    'org-next-link                        "next link"                           'org-mode-map)
(circ/p4 "["    'org-previous-link                    "previous link"                       'org-agenda-mode-map)
(circ/p4 "]"    'org-next-link                        "next link"                           'org-agenda-mode-map)
(circ/p4 "/"    'counsel-org-goto                     "org goto"                            'org-mode-map)
(circ/p4 "a"    'nil                                  "org-agenda")
(circ/p4 "a a"  'circ/alias-org-agenda-agenda         "agenda")
(circ/p4 "a t"  'circ/alias-org-agenda-tasks          "tasks")
(circ/p4 "a s"  'circ/setup-agenda-view               "setup agenda view")
(circ/p4 "b c"  'circ/open-calendar                   "calendar")
(circ/p4 "b l"  'circ/open-checklists                 "checklists")
(circ/p4 "b i"  'circ/open-inbox                      "inbox")
(circ/p4 "b r"  'circ/open-read                       "read")
(circ/p4 "b s"  'circ/open-someday                    "someday")
(circ/p4 "b t"  'circ/open-todo                       "todo")
(circ/p4 "b vc" 'org-columns                          "columns"                             'org-mode-map)
(circ/p4 "b"    'nil                                  "buffer switching")
(circ/p4 "c c"  'circ/cortex/continue                 "continue in another slide"           'org-mode-map)
(circ/p4 "c f"  'circ/cortex/search-slides            "search slides")
(circ/p4 "c l"  'circ/cortex/link                     "cortex link"                         'org-mode-map)
(circ/p4 "c n"  'circ/cortex/create-file              "create cortex file")
(circ/p4 "c r"  'circ/cortex/rename-slide             "rename slide"                        'org-mode-map)
(circ/p4 "c"    'nil                                  "cortex"                              'org-mode-map)
(circ/p4 "e"    'nil                                  "org edit"                            'org-mode-map)
(circ/p4 "e s"  'circ/org-sort-headlines              "sort headlines"                      'org-mode-map)
(circ/p4 "f m"  'circ/org-file-reference              "file reference"                      'org-mode-map)
(circ/p4 "f p"  'circ/pims/set-project                "set as project"                      'org-mode-map)
(circ/p4 "f r"  'org-refile                           "org refile"                          'org-mode-map)
(circ/p4 "f t"  'circ/pims/set-todo                   "set as todo"                         'org-mode-map)
(circ/p4 "f"    'nil                                  "filing"                              'org-mode-map)
(circ/p4 "h"    'outline-backward-same-level          "back same level")
(circ/p4 "i"    'org-clock-in                         "clock in"                            'org-mode-map)
(circ/p4 "j"    'outline-next-visible-heading         "next visible heading")
(circ/p4 "k"    'outline-previous-visible-heading     "prev visible heading")
(circ/p4 "l"    'outline-forward-same-level           "forward same level")
(circ/p4 "m"    'org-archive-subtree-default          "archive"                             'org-mode-map)
(circ/p4 "n"    'org-capture                          "org capture")
(circ/p4 "o"    'org-clock-out                        "clock out"                           'org-mode-map)
(circ/p4 "p d"  'org-deadline                         "deadline"                            'org-mode-map)
(circ/p4 "p p"  'org-set-property                     "set property"                        'org-mode-map)
(circ/p4 "p s"  'org-schedule                         "schedule"                            'org-mode-map)
(circ/p4 "p t"  'org-set-tags-command                 "set tags"                            'org-mode-map)
(circ/p4 "p"    'nil                                  "property"                            'org-mode-map)
(circ/p4 "r"    'nil                                  "references"                          'org-mode-map)
(circ/p4 "r f"  'circ/cortex/find-reference           "find reference")
(circ/p4 "r l"  'circ/cortex/insert-reference-link    "insert reference link"               'org-mode-map)
(circ/p4 "t c"  'org-table-create-or-convert-from-region "create / convert table"           'org-mode-map)
(circ/p4 "t d"  'nil                                  "delete"                              'org-mode-map)
(circ/p4 "t dc" 'org-table-delete-column              "delete column"                       'org-mode-map)
(circ/p4 "t dr" 'org-table-kill-row                   "delete row"                          'org-mode-map)
(circ/p4 "t i"  'nil                                  "insert"                              'org-mode-map)
(circ/p4 "t ic" 'org-table-insert-column              "insert column"                       'org-mode-map)
(circ/p4 "t ih" 'org-table-insert-hline               "insert horizontal line"              'org-mode-map)
(circ/p4 "t ir" 'org-table-insert-row                 "insert row"                          'org-mode-map)
(circ/p4 "t"    'nil                                  "tables"                              'org-mode-map)
(circ/p4 "u"    'outline-up-heading                   "up heading")
(circ/p4 "v c"  'circ/insert-created-timestamp        "created date"                        'org-mode-map)
(circ/p4 "v d"  'org-time-stamp                       "time stamp"                          'org-mode-map)
(circ/p4 "v p"  'counsel-yank-pop                     "paste selector")
(circ/p4 "v t"  'circ/org-template-insert             "template"                            'org-mode-map)
(circ/p4 "v"    'nil                                  "insert items"                        'org-mode-map)
(circ/p4 "x"    'nil                                  "none")
(circ/p4 "x"    'org-toggle-checkbox                  "toggle checkbox"                     'org-mode-map)
#+END_SRC

** Other
*** Non-P Bindings
#+BEGIN_SRC emacs-lisp
(evil-define-key 'motion org-agenda-mode-map "ci" 'org-agenda-show-clocking-issues)
(evil-define-key 'motion org-agenda-mode-map "cl" 'org-agenda-log-mode)
;; F1 is reserved for some special cases when "C-h" isn't available
(general-define-key
  "<f2>" 'circ/alias-org-agenda-agenda
  "<f3>" 'circ/alias-org-agenda-tasks
  "<f4>" 'circ/open-inbox
  "<f5>" 'circ/open-checklists
)
#+END_SRC

*** Help
#+BEGIN_SRC emacs-lisp
(general-define-key
  "C-h v" 'counsel-describe-variable
  "C-h f" 'counsel-describe-function
)
#+END_SRC
* Custom Command Line Options
These are for easy launching of emacs.

To automagically open emacsclient or emacs do so in the format:
#+BEGIN_SRC sh
emacsclient -c -a 'false' --no-wait --eval "(circ/startup/agenda)" || emacs --agenda
#+END_SRC
This will open an emacsclient and automatically launch an emacsclient if emacs
is already running, and run the =circ/startup/agenda= function. If emacs is not
running, it will open a new instance and use the =--agenda= flag to launch
=circ/startup/agenda=.

#+BEGIN_SRC emacs-lisp
(defun circ/startup/inbox (&optional switch) (circ/open-inbox))
(add-to-list 'command-switch-alist '("--inbox" . circ/startup/inbox))

(defun circ/startup/agenda (&optional switch) (circ/alias-org-agenda-agenda))
(add-to-list 'command-switch-alist '("--agenda" . circ/startup/agenda))

(defun circ/startup/tasks (&optional switch) (circ/alias-org-agenda-tasks))
(add-to-list 'command-switch-alist '("--tasks" . circ/startup/tasks))

(defun circ/startup/pims (&optional switch) (circ/set-up-agenda-view))
(add-to-list 'command-switch-alist '("--pims" . circ/startup/pims))
#+END_SRC
