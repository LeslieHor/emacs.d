#+STARTUP: overview
#+TITLE: emacs.d config

* Better defaults
** Start Up
#+BEGIN_SRC emacs-lisp
(server-start) ; Start emacs server
;(desktop-save-mode 1) ; Save session and restore on next launch
#+END_SRC

** UI
#+BEGIN_SRC emacs-lisp
(setq inhibit-startup-screen t) ; inhibit useless and old-school startup screen
(setq ring-bell-function 'ignore) ; silent bell when you make a mistake
(setq-default frame-title-format '("%b - Emacs")) ; set the emacs title.
                                        ; overrides the old "emacs@HOST" title
(set-frame-font "Liberation Mono 7" t t)
(menu-bar-mode -1)
(tool-bar-mode -1)
(scroll-bar-mode -1)
(load-theme 'wheatgrass)
; Split vertically by default
(setq split-width-threshold 160)
(setq split-height-threshold 100)
(setq-default fill-column 80)
(setq calendar-week-start-day 1)
#+END_SRC

** Tab Behaviour
#+BEGIN_SRC emacs-lisp
(setq-default indent-tabs-mode nil) ; don't insert tabs
(setq-default tab-width 4) ; self-documenting
(setq indent-line-function 'insert-tab)
(setq comment-column 2)
#+END_SRC

** Backup and autosave locations
#+BEGIN_SRC emacs-lisp
(setq auto-save-visited-file-name t)
(setq auto-save-default nil)
(setq backup-directory-alist '((".*" . "~/.emacs.d/backup")))
(setq auto-save-file-name-transforms '((".*" "~/.emacs.d/autosave/" t)))
#+END_SRC

** Default major mode
#+BEGIN_SRC emacs-lisp
(setq-default major-mode 'org-mode)
#+END_SRC

* Whitespace
Force it on all the time.

Highlights:
- face visualisation
- empty lines at beginning of end of buffer
- tabs
- tailing blanks

#+BEGIN_SRC emacs-lisp
(require 'whitespace)
(setq whitespace-style '(face empty tabs trailing))
(global-whitespace-mode t)
#+END_SRC

* Org
#+BEGIN_SRC emacs-lisp
(setq org-html-postamble "<p class=\"created\">Created: %T</p>")
(setq org-src-fontify-natively t)
(setq org-src-tab-acts-natively t)
(setq org-startup-folded nil) ; Start org mode expanded
(setq org-startup-with-inline-images t) ; Show images by default
(setq org-startup-indented nil)
(setq org-hide-leading-stars t)
(setq org-edit-src-content-indentation 0)
(setq org-clock-into-drawer t)
(setq org-agenda-window-setup 'current-window)
(setq org-agenda-sticky t)
(setq org-log-done 'time)
(setq org-agenda-skip-scheduled-if-done t)
(setq org-agenda-skip-deadline-if-done t)
(setq org-src-window-setup 'current-window)

(add-to-list 'org-link-frame-setup '(file . find-file))

;; Enable habit tracking in org-mode
(require 'org-habit)
(add-to-list 'org-modules 'org-habit)
;; Don't show any habits in the agenda, there is a dedicated section for that.
(setq org-habit-show-habits nil)
(setq org-habit-show-habits-only-for-today nil)
(setq org-habit-show-all-today nil)

;; Set up languages for running code blocks in org
(org-babel-do-load-languages
 'org-babel-load-languages '((python . t)
                             (sh . t)
                             (emacs-lisp . t)))
#+END_SRC

Line wrap mode
#+BEGIN_SRC emacs-lisp
(defun org-mode-startup-functions ()
  (toggle-word-wrap 1)
  (toggle-truncate-lines -1))

(add-hook 'org-mode-hook 'org-mode-startup-functions)

(defun org-agenda-mode-startup-functions ()
  (hl-line-mode +1))

(add-hook 'org-agenda-mode-hook 'org-agenda-mode-startup-functions)
#+END_SRC

** Beautifying org-mode
Credits:
zzamboni - https://zzamboni.org/post/beautifying-org-mode-in-emacs/#step-4-configure-faces-for-specific-org-elements

Hide the markup for various emphasis'
#+BEGIN_SRC emacs-lisp
(setq org-hide-emphasis-markers t)
#+END_SRC

Replace list bullet point with nice unicode
#+BEGIN_SRC emacs-lisp
(font-lock-add-keywords
  'org-mode
  '(("^ *\\([-]\\) "
     (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "â€¢"))))))
#+END_SRC

Set up nice fonts
#+BEGIN_SRC emacs-lisp
(let* ((base-font-color  (face-foreground 'default nil 'default))
       (headline        `(:inherit    default
                          :weight     bold
                          :foreground ,base-font-color)))

  (custom-theme-set-faces
   'user
   `(org-document-title   ((t (,@headline :height 1.00 :underline t))))
   `(org-level-1          ((t (,@headline :height 1.00 :foreground "#e6194b"))))
   `(org-level-2          ((t (,@headline :height 1.00 :foreground "#3cb44b"))))
   `(org-level-3          ((t (,@headline :height 1.00 :foreground "#ffe119"))))
   `(org-level-4          ((t (,@headline :height 1.00 :foreground "#4363d8"))))
   `(org-level-5          ((t (,@headline :height 1.00 :foreground "#f58231"))))
   `(org-level-6          ((t (,@headline :height 1.00 :foreground "#911eb4"))))
   `(org-level-7          ((t (,@headline :height 1.00 :foreground "#42d4f4"))))
   `(org-level-8          ((t (,@headline :height 1.00 :foreground "#f032e6"))))
   `(org-block-background ((t (:height 1.00 :background "#222222"))))
   `(org-block            ((t (:height 1.00 :background "#222222"))))
   `(org-block-begin-line ((t (:height 1.00 :foreground "#222222" :background "#070707"))))
   `(org-block-end-line   ((t (:height 1.00 :foreground "#222222" :background "#070707"))))
))
#+END_SRC

* Mode Line
#+BEGIN_SRC emacs-lisp
(column-number-mode 1) ; show column number
(set-face-attribute 'mode-line nil ; Set active mode line colour
                    :foreground "white"
                    :background "blue")
(set-face-attribute 'mode-line-buffer-id nil ; Set buffer id colour
                    :foreground "white"
                    :background "black")
#+END_SRC

* Custom Functions
** Helper Functions
#+BEGIN_SRC emacs-lisp
(defun leslie/strip-last-newline (string)
  (replace-regexp-in-string "\n\\'" "" string))

(defun leslie/escape-double-quotes (string)
  (replace-regexp-in-string "\"" "\\\\\"" string))

(defun leslie/strip-font-properties (string)
  (set-text-properties 0 (length string) nil string)
  string)
#+END_SRC

** eshell-new
Interative function to create a new instance of eshell.

#+BEGIN_SRC emacs-lisp
(defun leslie/eshell-new ()
  "Open a new instance of eshell."
  (interactive)
  (eshell 'N))
#+END_SRC

** transpose-buffers
Transpose two buffers.

#+BEGIN_SRC emacs-lisp
(defun leslie/transpose-buffers (dir &optional arg)
  "Transpose the buffers in the current window and the target window
If arg is non-nil, the selected window will change to keep the source buffer
selected."
  (let ((target-window (windmove-find-other-window dir))
        (source-window (selected-window)))
    (cond ((null target-window)
           (format "No window found in dir %s" dir))
          ((and (window-minibuffer-p target-window)
                (not (minibuffer-window-active-p target-window)))
           (user-error "Minibuffer is inactive"))
          (t
           (let ((target-buffer (window-buffer target-window))
                 (source-buffer (window-buffer)))
             (set-window-buffer target-window source-buffer)
             (set-window-buffer source-window target-buffer))
           (if arg
               (select-window target-window))))))

(defun leslie/transpose-buffers-left (&optional arg)
    "Transpose buffers from current window to buffer to the left"
  (interactive)
  (leslie/transpose-buffers 'left arg))

(defun leslie/transpose-buffers-up (&optional arg)
    "Transpose buffers from current window to buffer above"
  (interactive)
  (leslie/transpose-buffers 'up arg))

(defun leslie/transpose-buffers-right (&optional arg)
    "Transpose buffers from current window to buffer to the right"
  (interactive)
  (leslie/transpose-buffers 'right arg))

(defun leslie/transpose-buffers-down (&optional arg)
    "Transpose buffers from current window to buffer below"
  (interactive)
  (leslie/transpose-buffers 'down arg))
#+END_SRC

** cast-buffer
Send a buffer to another window.

#+BEGIN_SRC emacs-lisp
(defun leslie/cast-buffer (dir &optional arg)
  "Casts the current buffer to window in direction dir, and switches current
window back to last buffer.
If arg is non-nil, the targetted window is selected."
  (let ((target-window (windmove-find-other-window dir))
        (source-buffer (window-buffer)))
    (cond ((null target-window)
           (format "No window found in dir %s" dir))
          ((and (window-minibuffer-p target-window)
                (not (minibuffer-window-active-p target-window)))
           (user-error "Minibuffer is inactive"))
          (t
           (set-window-buffer target-window source-buffer)
           (previous-buffer)
           (if arg
               (select-window target-window))))))

(defun leslie/cast-buffer-left (&optional arg)
  "Cast current buffer to the left"
  (interactive)
  (leslie/cast-buffer 'left arg))

(defun leslie/cast-buffer-up (&optional arg)
  "Cast current buffer up"
  (interactive)
  (leslie/cast-buffer 'up arg))

(defun leslie/cast-buffer-right (&optional arg)
  "Cast current buffer to the right"
  (interactive)
  (leslie/cast-buffer 'right arg))

(defun leslie/cast-buffer-down (&optional arg)
  "Cast current buffer down"
  (interactive)
  (leslie/cast-buffer 'down arg))
#+END_SRC

** duplicate-buffer
Open buffer in another window.

#+BEGIN_SRC emacs-lisp
(defun leslie/duplicate-buffer (dir &optional arg)
  "Opens the current buffer in the window in the direction dir
If arg is non-nil, the targeted window is selected"
  (let ((target-window (windmove-find-other-window dir))
        (source-buffer (window-buffer)))
    (cond ((null target-window)
           (format "No window found in dir %s" dir))
          ((and (window-minibuffer-p target-window)
                (not (minibuffer-window-active-p target-window)))
           (user-error "Minibuffer is inactive"))
          (t
           (set-window-buffer target-window source-buffer)
           (if arg
               (select-window target-window))))))

(defun leslie/duplicate-buffer-left (&optional arg)
  "Cast current buffer to the left"
  (interactive)
  (leslie/duplicate-buffer 'left arg))

(defun leslie/duplicate-buffer-up (&optional arg)
  "Cast current buffer up"
  (interactive)
  (leslie/duplicate-buffer 'up arg))

(defun leslie/duplicate-buffer-right (&optional arg)
  "Cast current buffer to the right"
  (interactive)
  (leslie/duplicate-buffer 'right arg))

(defun leslie/duplicate-buffer-down (&optional arg)
  "Cast current buffer down"
  (interactive)
  (leslie/duplicate-buffer 'down arg))
#+END_SRC

** regenerate-tags
Regenerate tags using a command defined in the project root under the =.emacs=
directory.

#+BEGIN_SRC emacs-lisp
(defun leslie/regenerate-tags ()
  "use the generate-tags script in the project root to generate tags"
  (interactive)
  (cond ((projectile-project-root)
         (let* ((root-dir (projectile-project-root))
                (generate-tags-script (concat root-dir ".emacs/generate-tags"))
                (tag-command (concat ". " generate-tags-script " " root-dir))
                (result (if (file-exists-p generate-tags-script)
                            (shell-command-to-string tag-command)
                          (projectile-regenerate-tags))))
           (message result)))
        (t
         (user-error "Not in a project!"))))
#+END_SRC

** open-terminal-in-workdir
Opens a konsole in the current project root. If not in project, opens it in the
current directory.

#+BEGIN_SRC emacs-lisp
(defun leslie/open-terminal-in-workdir ()
 "Opens a terminal in the project root.
If not in a project, opens it in the current directory."
 (interactive)
 (let ((workdir (if (projectile-project-root)
                    (projectile-project-root)
                  default-directory)))
   (call-process-shell-command
    (concat "konsole --workdir " workdir) nil 0)))
#+END_SRC

** whitespace-mode
Toggle on and off whitespace trailing mode

#+BEGIN_SRC emacs-lisp
(defun leslie/toggle-whitespace-full ()
  "toggle display of more whitespace"
  (interactive)
  (whitespace-toggle-options '(lines-tail)))
#+END_SRC

** alignment functions
#+BEGIN_SRC emacs-lisp
(defun leslie/align-once-head (start end regexp)
  "Align by regex once, adding spaces to the head of the regexp"
  (interactive "r\nsAlign once head regexp: ")
  (align-regexp start end
                (concat "\\(\\s-*\\)" regexp) 1 1 nil))

(defun leslie/align-once-tail (start end regexp)
  "Align by regex once, adding spaces to the tail of the regexp"
  (interactive "r\nsAlign once tail regexp: ")
  (align-regexp start end
                (concat regexp "\\(\\s-*\\)") 1 1 nil))

(defun leslie/align-repeat-head (start end regexp)
  "Align by regex repeatedly, adding spaces to the head of the regexp"
  (interactive "r\nsAlign repeat head regexp: ")
  (align-regexp start end
                (concat "\\(\\s-*\\)" regexp) 1 1 t))

(defun leslie/align-repeat-tail (start end regexp)
  "Align by regex repeatedly, adding spaces to the tail of the regexp"
  (interactive "r\nsAlign repeat tail regexp: ")
  (align-regexp start end
                (concat regexp "\\(\\s-*\\)") 1 1 t))
#+END_SRC

** file opener functions
Some extra functions to aid in opening files

#+BEGIN_SRC emacs-lisp
(defun leslie/find-file-line (filename linenum)
  "invoke function find-file and goto-line"
  (find-file filename)
  (goto-line linenum))
#+END_SRC

The =find-file-line= function expects two args. We just therefore parse any
FILENAME:LINENUMBER string that it uses.

#+BEGIN_SRC emacs-lisp
(defun leslie/parse-file-special-syntax (file-string)
  "parses the format FILENAME:LINENUMBER"
  (let* ((file-list (split-string file-string ":"))
         (filename (car file-list))
         (line-number (string-to-number(cadr file-list))))
    (list filename line-number)))
#+END_SRC

We also want the ability to parse dirty file paths.

#+BEGIN_SRC emacs-lisp
(defun leslie/clean-file-path (file-string)
  "cleans the file path"
  (replace-regexp-in-string
   "^.*:[0-9]*\\(.*\\)$"
   ""
   file-string
   nil nil 1))
#+END_SRC

Plus we need a function to tie it all together.

#+BEGIN_SRC emacs-lisp
(defun leslie/find-file-special-syntax (file-string)
  "opens special syntax"
  (apply 'leslie/find-file-line
         (leslie/parse-file-special-syntax
          (leslie/clean-file-path file-string))))
#+END_SRC

** open-in-intellij
Helpful function to open the current buffer and line in intellij.

The complimentary command for intellij is:
#+BEGIN_SRC sh
emacsclient -n +$LINENUMBER$:$COLUMN$ $FILE$
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun leslie/open-in-intellij ()
  "Open the current file + line in intellij"
  (interactive)
  (let* ((file (buffer-file-name))
         (line-num (number-to-string (line-number-at-pos)))
         (command (concat "idea " file ":" line-num)))
    (shell-command command)
    (message "file opened in intellij")))
#+END_SRC

** check-project
Compile / check the project and send results to ivy-read.

Expects results in the format:

#+BEGIN_EXAMPLE
FILENAME:100 explanation
FILENAME:200 explanation
FILENAME:40can also be dirty
#+END_EXAMPLE

#+BEGIN_SRC emacs-lisp
(defun leslie/check-project ()
  "run .emacs/check-project and put results in ivy-read"
  (interactive)
  (cond ((projectile-project-root)
         (message "Checking project...")
         (let* ((root-dir (projectile-project-root))
                (script (concat root-dir ".emacs/check-project"))
                (command (concat ". " script " " root-dir))
                (result (shell-command-to-string command)))
           (cond ((> (length result) 0)
                  (completing-read "Check project results: "
                                   (split-string result "\n")
                                   :action 'leslie/find-file-special-syntax))
                 (t
                  (user-error "Check complete")))))
        (t
         (user-error "Not in a project!"))))
#+END_SRC

** show-file-path
Show the full file path as a message

#+BEGIN_SRC emacs-lisp
(defun leslie/show-file-path ()
  "Show full file path as a message"
  (interactive)
  (if buffer-file-name
      (message buffer-file-name)
    (message "No valid file path")))
#+END_SRC

** smart-clear-buffer
Clear the buffer, but with special cases for certain major modes.

#+BEGIN_SRC emacs-lisp
(defun leslie/smart-clear-buffer ()
  "Clear the current buffer. term-mode requires different command to clear."
  (interactive)
  (case major-mode
    ('term-mode (comint-clear-buffer))
    (otherwise (erase-buffer))))
#+END_SRC

** Revert project buffers
Revert all the buffers in the current project.

#+BEGIN_SRC emacs-lisp
(defun leslie/revert-project-buffers ()
  (interactive)
  (let* ((project (projectile-ensure-project (projectile-project-root)))
         (project-buffers (projectile-project-buffers project))
         (buffers (remove-if-not 'buffer-file-name project-buffers)))
    (dolist (buffer buffers)
      (with-current-buffer buffer
        (ignore-errors (revert-buffer nil t))
        (message "Reverted: %s" buffer)))
    (message "Project buffers reverted")))
#+END_SRC
** Save all project buffers
#+BEGIN_SRC emacs-lisp
(defun leslie/save-project-buffers ()
  (interactive)
  (let* ((project (projectile-ensure-project (projectile-project-root)))
         (project-buffers (projectile-project-buffers project))
         (buffers (remove-if-not 'buffer-file-name project-buffers)))
    (dolist (buffer buffers)
      (with-current-buffer buffer
        (save-buffer)
        (message "Saved: %s" buffer)))
    (message "Project buffers saved")))
#+END_SRC
** Org Set Property
#+BEGIN_SRC emacs-lisp
(defun leslie/org-set-property (property)
  (interactive)
  (let* ((current-value (org-entry-get nil property))
         (value (read-string (format "Set property %s: " property)
                             current-value)))
    (org-entry-put nil property value)))
#+END_SRC
** Org file reference
#+BEGIN_SRC emacs-lisp
(defun leslie/org-file-reference ()
  (interactive)
  (let* ((target-file (expand-file-name
                       (completing-read "File reference (C-M-j to done): "
                                        (mapcar (lambda (filepath)
                                                  (file-relative-name
                                                   filepath
                                                   leslie/org-reference-directory))
                                                (directory-files-recursively
                                                 leslie/org-reference-directory
                                                 ".*\.org"
                                                 nil)))
                       leslie/org-reference-directory))
         (org-heading (org-get-heading)))
    (org-back-to-heading)
    (org-cut-subtree)

    (find-file target-file)
    (let ((target-buffer (get-file-buffer target-file)))
      (unless (file-exists-p target-file)
        (make-directory (file-name-directory target-file) t)
        (with-current-buffer target-buffer
          (insert (concat "#+TITLE: " org-heading))
          (newline))
        (message "Created file"))
      (with-current-buffer target-buffer
        (end-of-buffer)
        (newline)
        (yank)
        (save-buffer)))))
#+END_SRC
** Buffer yank paste
#+BEGIN_SRC emacs-lisp
(setq leslie/buffer-clipboard nil)

(defun leslie/buffer-yank ()
  (interactive)
  (setq leslie/buffer-clipboard (current-buffer)))

(defun leslie/buffer-paste ()
  (interactive)
  (when leslie/buffer-clipboard
    (set-window-buffer (selected-window) leslie/buffer-clipboard)))
#+END_SRC
** Kill buffer
#+BEGIN_SRC emacs-lisp
(defun leslie/kill-this-buffer ()
  (interactive)
  (kill-buffer (current-buffer)))
#+END_SRC
** Cortex
#+BEGIN_SRC emacs-lisp
(defun leslie/cortex/create-file ()
  "Create a new cortex file"
  (interactive)
  (let* ((title (read-string "Title: "))
         (id (leslie/cortex/create-new-file title)))
    (find-file (leslie/cortex/expand-filepath id))
    (goto-char (point-max))))

(defun leslie/cortex/create-new-file (title)
  (let ((new-id (leslie/cortex/new-id)))
    (leslie/cortex/ensure-file new-id title)
    new-id))

(defun leslie/cortex/get-ids ()
  (mapcar (lambda (file)
            (replace-regexp-in-string "\.org" "" file))
          (directory-files leslie/cortex/directory nil "^[0-9]*\.org$")))

(defun leslie/cortex/get-title ()
  (let ((point-location (point)))
    (goto-char (point-min))
    (re-search-forward "\* \\(.*\\)")
    (goto-char point-location)
    (match-string 1)))

(defun leslie/cortex/get-entry ()
  (let ((point-location (point)))
    (goto-char (point-min))
    (let ((entry (cond ((re-search-forward ":END: *\n" nil t)
                        (buffer-substring (point) (point-max)))
                       ((re-search-forward "\* .*\n" nil t)
                        (buffer-substring (point) (point-max)))
                       (t "ERROR PARSING ENTRY"))))
      (goto-char point-location)
      (replace-regexp-in-string "\\[cortex:[0-9]*\\]" "" entry))))

(defun leslie/cortex/get-file-previews()
  (let ((ids (leslie/cortex/get-ids)))
    (mapcar (lambda (id)
              (with-temp-buffer
                (insert-file-contents (leslie/cortex/expand-filepath id))
                (concat (propertize id 'face '(:foreground "grey")) ": "
                        (propertize (leslie/cortex/get-title) 'face '(:foreground "green")) "\n"
                        (leslie/cortex/get-entry))))
            ids)))

(defun leslie/cortex/expand-filepath (id)
  "Given an id, create the full cortex filepath"
  (concat (file-name-as-directory leslie/cortex/directory)
          id ".org"))

(defun leslie/cortex/extract-id (filepath)
  "Given a cortex filepath, return the id"
  (let ((filename (file-name-nondirectory filepath)))
    (string-match "^\\([0-9]*\\)\.org" filename)
    (match-string 1 filename)))

(defun leslie/cortex/ensure-file (id &optional descr)
  (let ((description (cond (descr descr)
                           (t "")))
        (abs-filepath (leslie/cortex/expand-filepath id)))
    (unless (file-exists-p (leslie/cortex/expand-filepath id))
      (write-region (format "* %s\n" (capitalize description)) nil
                    abs-filepath))))

(defun leslie/cortex/format-link (id descr)
  (format "[[cortex:%s][%s]]" id descr))

(defun leslie/cortex/add-backlink (id)
  "Adds a backlink to the slide ID that links to the currently visited slide"
  (let ((current-file (buffer-file-name))
        (current-heading (org-get-heading t t))
        (abs-filepath (leslie/cortex/expand-filepath id)))
    (with-temp-buffer
      (let ((file-buffer (get-file-buffer abs-filepath)))
        (insert-file-contents abs-filepath)
        (org-mode)
        (org-entry-put nil "Backlinks"
                       ;; Ensure we do not add a duplicate backlink
                       (let* ((backlinks (org-entry-get nil "Backlinks"))
                              (link (leslie/cortex/format-link
                                     (leslie/cortex/extract-id current-file)
                                     current-heading)))
                         (cond ((string-match-p (regexp-quote link)
                                                (cond (backlinks backlinks)
                                                      (t "")))
                                backlinks)
                               (t
                                (cond (backlinks (concat backlinks " " link))
                                      (t link))))))
        (write-file abs-filepath)))))

(defun leslie/cortex/new-id ()
  (format-time-string "%Y%m%d%H%M%S"))

(defun leslie/cortex/interactive-slide-picker (&optional initial-input)
  "Prompts user to interactively pick a slide and returns the id and the
description in a cons.

(id . description)

If no slide is found, a new id is generated and the search term is returned as
the description"
  (let* ((result (completing-read "Cortex link (C-M-j to done): "
                                  (leslie/cortex/get-file-previews)
                                  nil nil
                                  initial-input))
         (id (progn
               (string-match "^\\([0-9]*\\):" result)
               (match-string 1 result)))
         (description (cond
                       (id
                        (string-match "^[0-9]*: \\(.*\\)" result)
                        (match-string 1 result))
                       (t
                        (string-match "^\\(.*\\)" result)
                        (match-string 1 result)))))

    ;; Remove any font properties
    (set-text-properties 0 (length id) nil id)
    (set-text-properties 0 (length description) nil description)
    (message "ID: %s" id)
    (message "Des: %s" description)

    (cons (cond ((file-exists-p (leslie/cortex/expand-filepath id)) id)
                (t (leslie/cortex/new-id)))
          description)))

(defun leslie/cortex/add-link (id description)
  "Create a cortex link. If a region is highlighted, it is replaced with the
generated link"
  (when (region-active-p)
    (delete-region (region-beginning) (region-end)))
  (insert (leslie/cortex/format-link id description)))

(defun leslie/cortex/link (start end)
  "Create a cortex link.

When a region is highlighted, the initial search input is set to the highlighted
text, and the initial default description is also set to the highlighted text.

When no region is highlighed, the initial search input and initial description
are blank.

If the link given does not exist, the file is created with an initial heading
of the inputted description.

The targeted file is assigned a backlink for the original file the link was
created from."
  (interactive "r")
  (let* ((initial-input (when (region-active-p)
                               (leslie/strip-font-properties
                                (buffer-substring start end))))
         (id-desc (leslie/cortex/interactive-slide-picker initial-input))
         (id (car id-desc))
         (desc (cdr id-desc))
         (description (read-string "Description: " (cond (initial-input initial-input)
                                                         (t desc)))))

    ;; Firstly, ensure that a target file exists with the proper heading
    (leslie/cortex/ensure-file id desc)
    (leslie/cortex/add-backlink id)
    (leslie/cortex/add-link id description)
    (save-buffer)))

(defun leslie/cortex/get-all-links ()
  "Returns all cortex links in the current file in a list of conses."
  (let ((point-location (point))) ; Save pointer to restore later
    ;; Go to the beginning of the buffer
    (goto-char (point-min))
    ;; Move past the properties (if any)
    (re-search-forward (regexp-quote ":END:") nil t)
    (let (links)
      ;; Generate list of links in current buffer
      (while (re-search-forward "\\[\\[cortex:\\([0-9]*\\)\\]\\[\\(.*?\\)\\]\\]"
                                nil t)
        (let ((id (match-string 1))
              (desc (match-string 2)))
          (set-text-properties 0 (length id) nil id)
          (set-text-properties 0 (length desc) nil desc)
          (push (cons id desc) links)))
      (goto-char point-location)
      (cl-remove-duplicates links :test #'equal))))

(defun leslie/cortex/update-backlink (slide-id link-id old-desc new-desc)
  "For the slide of `slide-id`, update the backlink of `link-id` to update the
description"
  (message "Updating cortex slide %s" slide-id)
  (with-temp-buffer
    (let ((filepath (leslie/cortex/expand-filepath slide-id)))
      (insert-file-contents filepath)
      (org-mode)
      (let ((backlinks (org-entry-get nil "Backlinks")))
        (org-entry-put nil "Backlinks"
                       (replace-regexp-in-string
                        (regexp-quote (leslie/cortex/format-link link-id old-desc))
                        (leslie/cortex/format-link link-id new-desc)
                        backlinks)))
      (write-file filepath))))

(defun leslie/cortex/rename-current-title (new-title)
  "Renames the title in the current slide"
  (let ((old-title (org-get-heading t t))
        (point-location (point))) ; Restore pointer later
    (goto-char (point-min))
    (re-search-forward (regexp-quote (concat "* " old-title)))
    (replace-match (concat "* " new-title))
    (goto-char (- point-location (- (length old-title) (length new-title)))))
  (save-buffer))

(defun leslie/cortex/get-current-id ()
  (leslie/cortex/extract-id (buffer-file-name)))

(defun leslie/cortex/rename-slide ()
  "Rename the current slide and update the backlinks for any linked slides"
  (interactive)
  (let* ((current-id (leslie/cortex/get-current-id))
         (old-title (org-get-heading t t))
         (new-title (read-string "New title: " old-title)))
    (message "Changing %s to %s" old-title new-title)
    (leslie/cortex/rename-current-title new-title)
    (dolist (link (leslie/cortex/get-all-links))
      (let ((link-id (car link)))
        (leslie/cortex/update-backlink link-id current-id
                                       old-title new-title)))))

(defun leslie/cortex/search-slides ()
  "Search all slides and open"
  (interactive)
  (find-file (leslie/cortex/expand-filepath
              (car (leslie/cortex/interactive-slide-picker)))))

(defun leslie/cortex/continue ()
  "Creates a continue link at the bottom of the current slide.

If the current slide has no index, set the index property to 1.

The new slide is created with an incremented index."
  (interactive)
  (let* ((point-location (point))
         (buffer-size (point-max))
         (current-title (org-get-heading t t))
         (org-index (org-entry-get nil "Index"))
         (current-index (cond (org-index org-index) (t "1")))
         (new-index (number-to-string (+ 1 (string-to-number current-index))))
         (new-id (leslie/cortex/new-id))
         (new-title (read-string "New title: " current-title)))
    (goto-char (point-max))
    (insert "\n")
    (leslie/cortex/ensure-file new-id new-title)
    (leslie/cortex/add-backlink new-id)
    (leslie/cortex/add-link new-id "Continued...")

    ;; If the continued slide has the same title, increment indexes
    (when (equal current-title new-title)
      (message "Indexing slides")
      (unless (org-entry-get nil "Index")
        (org-entry-put nil "Index" current-index))
      (leslie/cortex/add-index new-id new-index))

    (goto-char (+ point-location (- (point-max) buffer-size)))
    (save-buffer)
    (find-file (leslie/cortex/expand-filepath new-id))
    (goto-char (point-max))
    (message "%s continued..." current-title)))

(defun leslie/cortex/add-index (id index)
  "Add index to given slide id"
  (with-temp-buffer
    (let ((abs-filepath (leslie/cortex/expand-filepath id)))
      (insert-file-contents abs-filepath)
      (org-mode)
      (org-entry-put nil "Index" index)
      (write-file abs-filepath))))
#+END_SRC

** Surround
#+BEGIN_SRC emacs-lisp
(defun leslie/surround-parentheses () (interactive) (leslie/surround "(" ")"))
(defun leslie/surround-brackets    () (interactive) (leslie/surround "[" "]"))
(defun leslie/surround-braces      () (interactive) (leslie/surround "{" "}"))
(defun leslie/surround-asterisk    () (interactive) (leslie/surround "*" "*"))
(defun leslie/surround-d-quote     () (interactive) (leslie/surround "\"" "\""))
(defun leslie/surround-s-quote     () (interactive) (leslie/surround "'" "'"))
(defun leslie/surround-slash       () (interactive) (leslie/surround "/" "/"))
(defun leslie/surround-equals      () (interactive) (leslie/surround "=" "="))
(defun leslie/surround-plus        () (interactive) (leslie/surround "+" "+"))
(defun leslie/surround-minus       () (interactive) (leslie/surround "-" "-"))

(defun leslie/surround-region ()
  (interactive)
  (let* ((start (read-string "Beginning: "))
         (end (read-string "End: " start)))
    (leslie/surround start end)))

(defun leslie/surround (start end)
  (let ((region (buffer-substring (region-beginning) (region-end))))
    (delete-region (region-beginning) (region-end))
    (insert (format "%s%s%s" start region end))))
#+END_SRC

** Insert org timestamp
#+BEGIN_SRC emacs-lisp
(defun leslie/insert-label-timestamp (label)
  (insert (format "%s: " label))
  (org-time-stamp-inactive))

(defun leslie/insert-created-timestamp ()
  (interactive)
  (leslie/insert-label-timestamp "Created"))
#+END_SRC
** Term Mode Functions
#+BEGIN_SRC emacs-lisp
(defun leslie/term/delete-previous-word ()
  "Simulates typical C-<backspace> behaviour by sending C-w instead."
  (interactive)
  (term-send-raw-string "\C-w"))

(defun leslie/term/delete-next-word ()
  "Simulates typical C-<delete> behaviour by sending M-d instead."
  (interactive)
  (term-send-raw-string "\^[d"))

(defun leslie/term/go-to-previous-word ()
  "Simulates typical C-<left> behaviour by sending M-b instead."
  (interactive)
  (term-send-raw-string "\^[b"))

(defun leslie/term/go-to-next-word ()
  "Simulates typical C-<right> behaviour by sending M-f instead."
  (interactive)
  (term-send-raw-string "\^[f"))
#+END_SRC

** Shell Command
#+BEGIN_SRC emacs-lisp
(defvar leslie/shell-line-history '())

(defun leslie/do-sh-cmd (input-list command &optional strip-newline)
  (let (output-list)
    (dolist (dirty-input input-list)
      (set-text-properties 0 (length dirty-input) nil dirty-input)
      (let* ((input (leslie/escape-double-quotes
                     (leslie/strip-last-newline
                      dirty-input)))
             (output (shell-command-to-string
                      (concat command " <<< \"" input "\""))))
        (setq output-list (cons (if strip-newline
                                    (leslie/strip-last-newline output)
                                  output) output-list))))
    (reverse output-list)))

(defun leslie/sh-cmd (&optional cmd whole-buffer split-lines)
  "Execute CMD on the buffer. If CMD is nil, ask the user what
command to use. If split-lines is non-nil, split the input by
newlines and send each line into the command individually.

Use the selected region as the input to the shell command. If no
region is selected, use the current line as the input, except
when WHOLE-BUFFER is non-nil, in which case, use the entire
buffer as the input.

A history of executed commands is kept."
  (interactive)
  (let ((command (cond (cmd cmd)
                       (t (completing-read "Command (C-M-j to done): "
                                           leslie/shell-line-history)))))
    (add-to-list 'leslie/shell-line-history command)
    (cond ((eq evil-this-type 'block)
           ;; Case when region is an evil block
           (let* ((rb (region-beginning))
                  (re (region-end))
                  (input-list (extract-rectangle rb re))
                  (output-list (leslie/do-sh-cmd input-list command t))
                  (start (= (point) rb)))
             (goto-char rb)
             (delete-rectangle rb re)
             (insert-rectangle output-list)
             ;; after inserting rectanble, point will move to the end of the
             ;; input, so if the point was at the start of the rectangle, then
             ;; move it back.
             (when start
               (goto-char rb))))
          (t
           (let* ((rb (cond (whole-buffer (point-min))
                            ((use-region-p) (region-beginning))
                            (t (line-beginning-position))))
                  (re (cond (whole-buffer (point-max))
                            ((use-region-p) (region-end))
                            (t (line-end-position))))
                  (input (buffer-substring rb re))
                  (input-list (cond (split-lines (split-string input "\n"))
                                    (t (list input))))
                  (output-list (leslie/do-sh-cmd input-list command (not whole-buffer))))
             (delete-region rb re)
             (dolist (line output-list)
               (insert line)))))))
#+END_SRC
** Org agenda habits
Force habit graphs to be drawn everywhere
#+BEGIN_SRC emacs-lisp
(defvar leslie/org-habit-show-graphs-everywhere t
  "If non-nil, show habit graphs in all types of agenda buffers.

Normally, habits display consistency graphs only in
\"agenda\"-type agenda buffers, not in other types of agenda
buffers.  Set this variable to any non-nil variable to show
consistency graphs in all Org mode agendas.")

(defun leslie/org-agenda-mark-habits ()
  "Mark all habits in current agenda for graph display.

This function enforces `leslie/org-habit-show-graphs-everywhere' by
marking all habits in the current agenda as such.  When run just
before `org-agenda-finalize' (such as by advice; unfortunately,
`org-agenda-finalize-hook' is run too late), this has the effect
of displaying consistency graphs for these habits.

When `leslie/org-habit-show-graphs-everywhere' is nil, this function
has no effect."
  (when (and leslie/org-habit-show-graphs-everywhere
         (not (get-text-property (point) 'org-series)))
    (let ((cursor (point))
          item data)
      (while (setq cursor (next-single-property-change cursor 'org-marker))
        (setq item (get-text-property cursor 'org-marker))
        (when (and item (org-is-habit-p item))
          (with-current-buffer (marker-buffer item)
            (setq data (org-habit-parse-todo item)))
          (put-text-property cursor
                             (next-single-property-change cursor 'org-marker)
                             'org-habit-p data))))))

(advice-add #'org-agenda-finalize :before #'leslie/org-agenda-mark-habits)
#+END_SRC
* Local variables
** Safe Local Eval Aliases
#+BEGIN_SRC emacs-lisp
(defun leslie/file-local-eval-safe-auto-revert ()
  (interactive)
  (auto-revert-mode t))
#+END_SRC
** Safe Local Eval List
#+BEGIN_SRC emacs-lisp
(add-to-list 'safe-local-eval-forms '(leslie/file-local-eval-safe-auto-revert))
#+END_SRC

* Package Specific
** ediff
#+BEGIN_SRC emacs-lisp
(setq ediff-split-window-function 'split-window-horizontally)
(setq ediff-window-setup-function 'ediff-setup-windows-plain)
#+END_SRC

Restore previous window config.
#+BEGIN_SRC emacs-lisp
(defvar leslie/ediff-last-window-configuration nil)

(defun leslie/ediff-store-window-configuration ()
  (setq leslie/ediff-last-window-configuration (current-window-configuration)))

(defun leslie/ediff-restore-window-configuration ()
  (set-window-configuration leslie/ediff-last-window-configuration))

(add-hook 'ediff-before-setup-hook #'leslie/ediff-store-window-configuration)
(add-hook 'ediff-quit-hook #'leslie/ediff-restore-window-configuration)
#+END_SRC

** which-key
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/which-key-3.3.1")
(require 'which-key)
(which-key-mode)
#+END_SRC

** evil
Load evil, and its dependencies in it comes with.

#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/evil-1.2.14")
(add-to-list 'load-path "~/.emacs.d/packages/evil-1.2.14/lib")
(require 'evil)
(evil-mode 1)
#+END_SRC

Rebind the ~q~ and ~quit~ commands to make more sense.

#+BEGIN_SRC emacs-lisp
(evil-ex-define-cmd "q" 'kill-this-buffer) ; :q should kill the buffer rather
                                        ; than quiting emacs
(evil-ex-define-cmd "quit" 'evil-quit-all) ; :quit to quit emacs
;; Deal with common mistakes
(evil-ex-define-cmd "W"  'evil-write)
(evil-ex-define-cmd "Wq" 'evil-save-and-close)
(evil-ex-define-cmd "WQ" 'evil-save-and-close)

(evil-define-command evil-save-and-kill-buffer (file &optional bang)
  "Save current buffer and close buffer.
Override for :wq"
  :repeat nil
  (interactive "<f><!>")
  (evil-write nil nil nil file bang)
  (kill-this-buffer))
(evil-ex-define-cmd "wq" 'evil-save-and-kill-buffer)
#+END_SRC

Set initial states
#+BEGIN_SRC emacs-lisp
(evil-set-initial-state 'vc-annotate-mode 'motion)
#+END_SRC

** evil-leader
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/evil-leader-0.4.3")
(require 'evil-leader)
(global-evil-leader-mode)
#+END_SRC

** evil-org
#+BEGIN_SRC emacs-lisp
(add-to-list
 'load-path
 "~/.emacs.d/packages/evil-org-mode-b6d652a9163d3430a9e0933a554bdbee5244bbf6")
(require 'evil-org)
(add-hook 'org-mode-hook 'evil-org-mode)
(evil-org-set-key-theme '(navigation insert textobjects additional calendar shift todo heading))
(add-hook 'org-mode-hook
          (lambda ()
          (setq evil-auto-indent nil)))
(require 'evil-org-agenda)
(evil-org-agenda-set-keys)
#+END_SRC

** evil-numbers
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/evil-numbers-0.4")
(require 'evil-numbers)
#+END_SRC

** evil-quickscope
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/evil-quickscope-0.1.4")
(require 'evil-quickscope)
(global-evil-quickscope-mode 1)
#+END_SRC

** ivy / swiper / counsel
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/swiper-0.11.0")
(require 'ivy)
(require 'swiper)
(require 'counsel)
(setq ivy-use-virtual-buffers t)
(setq ivy-count-format "(%d/%d) ")
(ivy-mode 1)

;; Setting up more ivy completion
(setq org-outline-path-complete-in-steps nil)
(setq org-completion-use-ido nil)
#+END_SRC

** projectile
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/projectile-2.0.0")
(require 'projectile)
(projectile-mode +1)
(setq projectile-project-search-path '("~/projects/")) ; where the projects are
(setq projectile-completion-system 'ivy)
#+END_SRC

** counsel-projectile
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/counsel-projectile-0.3.0")
(require 'counsel-projectile)
(setq counsel-projectile-grep-initial-input '(ivy-thing-at-point))
                                        ; this required a fix that was taken
                                        ; from commit a07ddc8
#+END_SRC

** ranger
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/ranger.el-0.9.8.5")
(require 'ranger)
#+END_SRC

** rainbow-delimiters
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/rainbow-delimiters-2.1.3")
(require 'rainbow-delimiters)
#+END_SRC

Set the colours to be as distinct as possible.

#+BEGIN_SRC emacs-lisp
(set-face-attribute 'rainbow-delimiters-depth-1-face nil :foreground "#e6194b")
(set-face-attribute 'rainbow-delimiters-depth-2-face nil :foreground "#3cb44b")
(set-face-attribute 'rainbow-delimiters-depth-3-face nil :foreground "#ffe119")
(set-face-attribute 'rainbow-delimiters-depth-4-face nil :foreground "#4363d8")
(set-face-attribute 'rainbow-delimiters-depth-5-face nil :foreground "#f58231")
(set-face-attribute 'rainbow-delimiters-depth-6-face nil :foreground "#911eb4")
(set-face-attribute 'rainbow-delimiters-depth-7-face nil :foreground "#42d4f4")
(set-face-attribute 'rainbow-delimiters-depth-8-face nil :foreground "#f032e6")
(set-face-attribute 'rainbow-delimiters-depth-9-face nil :foreground "#bfef45")
(set-face-attribute 'rainbow-delimiters-unmatched-face nil
                    :background "#ff0000"
                    :foreground "#ffffff")
#+END_SRC

** beacon
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/beacon-1.3.4")
(require 'beacon)
(beacon-mode 1)
#+END_SRC

** json-mode
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/json-snatcher-1.0.0")
(add-to-list 'load-path "~/.emacs.d/packages/json-reformat-0.0.6")
(add-to-list 'load-path "~/.emacs.d/packages/json-mode-1.7.0")
(require 'json-mode)
#+END_SRC

** telephone-line
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/telephone-line-0.4")
(require 'telephone-line)
#+END_SRC

Telephone line customization.

#+BEGIN_SRC emacs-lisp
(setq telephone-line-lhs
      '((evil   . (telephone-line-evil-tag-segment))
        (accent . (telephone-line-vc-segment
                   telephone-line-erc-modified-channels-segment
                   telephone-line-process-segment))
        (nil    . (telephone-line-buffer-segment))))
(setq telephone-line-rhs
      '((nil    . (telephone-line-misc-info-segment))
        (accent . (telephone-line-major-mode-segment))
        (evil   . (telephone-line-airline-position-segment))))
(telephone-line-mode 1)
#+END_SRC

** nlinum-relative
nlinum is a dependency.

Delay is kinda required or else files with loads of lines tend to lag.

#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/nlinum-1.8.1")
(require 'nlinum)

(add-to-list
 'load-path
 "~/.emacs.d/packages/nlinum-relative-5b9950c97ba79a6f0683e38b13da23f39e01031c")
(require 'nlinum-relative)
(nlinum-relative-setup-evil)
(global-nlinum-relative-mode)
(setq nlinum-relative-redisplay-delay 0.2) ; delay
(setq nlinum-relative-current-symbol "") ; e.g. "->"
                                        ; "" for display current line number
(setq nlinum-relative-offset 0)          ; 1 if you want 0, 2, 3...
#+END_SRC

I want relative numbers to display when in evil operator mode.

#+BEGIN_SRC emacs-lisp
(add-hook 'evil-operator-state-entry-hook
          (lambda () (when (bound-and-true-p nlinum-relative-mode)
                       (nlinum-relative-on))))
(add-hook 'evil-operator-state-exit-hook
          (lambda () (when (bound-and-true-p nlinum-relative-mode)
                       (nlinum-relative-off))))
#+END_SRC

** diff-hl
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/diff-hl-1.8.6")
(require 'diff-hl)
(require 'diff-hl-flydiff)
(global-diff-hl-mode)
(diff-hl-flydiff-mode) ; Don't wait for save to calcualte diff
#+END_SRC

** erlang
#+BEGIN_SRC emacs-lisp
(defvar leslie/enable-erlang t)
(when leslie/enable-erlang
  (setq load-path (cons  "~/.emacs.d/packages/erlang-2.8.4" load-path))
  (setq erlang-root-dir "~/erl_rel/18.3")
  (setq exec-path (cons "~/erl_rel/18.3/bin" exec-path))
  (require 'erlang-start)
  (require 'erlang-flymake))
#+END_SRC

*** Use regular indenting for single '%' comments
#+BEGIN_SRC emacs-lisp
(defun leslie/erlang-comment-indent ()
  (cond ((looking-at "%%%") 0)
        ((looking-at "%%")
         (or (erlang-calculate-indent)
             (current-indentation)))
        ((looking-at "%")
         (or (erlang-calculate-indent)
             (current-indentation)))
        (t
         (save-excursion
           (skip-chars-backward " \t")
           (max (if (bolp) 0 (1+ (current-column)))
                comment-column)))))

(advice-add
   'erlang-comment-indent
   :override
   (lambda (&rest r) (leslie/erlang-comment-indent))
   '((name . "erlang-comment-indent-advice")))
#+END_SRC

** term mode
Set colours to be more readable

#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'term
  (set-face-attribute 'term-color-green   nil :foreground "#55ff55")
  (set-face-attribute 'term-color-blue    nil :foreground "#5555ff")
  (set-face-attribute 'term-color-red     nil :foreground "#ff5555")
  (set-face-attribute 'term-color-magenta nil :foreground "#ff55ff")
  (set-face-attribute 'term-color-cyan    nil :foreground "#55ffff")
  (set-face-attribute 'term-color-yellow  nil :foreground "#ffff55"))
#+END_SRC

Disable line number mode for term mode.
Requires this hacky double add hook thing because the
global-nlinum-relative-mode hook is run after the term-mode-hook

#+BEGIN_SRC emacs-lisp
(defun setup-term-mode ()
  "Counteract global nlinum mode"
  (add-hook 'after-change-major-mode-hook
            (lambda () (nlinum-mode 0))
            :append :local))

(add-hook 'term-mode-hook 'setup-term-mode)
#+END_SRC

Set normal / visual / operator mode to be line mode.
Set insert mode to be char mode.

=ignore-errors= added because this crashes term-mode from starting up.
I don't know why.

#+BEGIN_SRC emacs-lisp
(defun term-mode-normal-visual-operator-switch ()
  (when (equal major-mode 'term-mode) (ignore-errors (term-line-mode))))
(defun term-mode-insert-switch ()
  (when (equal major-mode 'term-mode) (ignore-errors (term-char-mode)) (end-of-buffer)))

(add-hook 'evil-normal-state-entry-hook 'term-mode-normal-visual-operator-switch)
(add-hook 'evil-visual-state-entry-hook 'term-mode-normal-visual-operator-switch)
(add-hook 'evil-operator-state-entry-hook 'term-mode-normal-visual-operator-switch)
(add-hook 'evil-insert-state-entry-hook 'term-mode-insert-switch)
#+END_SRC

Have the term buffer close automatically when the process has finished.

Source: https://oremacs.com/2015/01/01/three-ansi-term-tips/

#+BEGIN_SRC emacs-lisp
(defun auto-exit-term-exec-hook ()
  (let* ((buff (current-buffer))
         (proc (get-buffer-process buff)))
    (set-process-sentinel
     proc
     `(lambda (process event)
        (if (string= event "finished\n")
            (kill-buffer ,buff))))))

(add-hook 'term-exec-hook 'auto-exit-term-exec-hook)
#+END_SRC

** man
Open man pages in current window
#+BEGIN_SRC emacs-lisp
(setq Man-notify-method 'pushy)
#+END_SRC
** general
#+BEGIN_SRC emacs-lisp
(add-to-list
 'load-path
 "~/.emacs.d/packages/general-2d2dd1d532fa75c1ed0c010d50e817ce43e58066/")
(require 'general)
(general-auto-unbind-keys)
#+END_SRC

* Keybindings
** Aliases
To keep the code nice and clean.
#+BEGIN_SRC emacs-lisp
(defun leslie/alias-text-scale-down () (interactive) (text-scale-adjust -1))
(defun leslie/alias-text-scale-up   () (interactive) (text-scale-adjust +1))

(defun leslie/alias-search-buffer () (interactive) (swiper (ivy-thing-at-point)))

(defun leslie/alias-transpose-buffer-left  () (interactive) (leslie/transpose-buffers-left t))
(defun leslie/alias-transpose-buffer-down  () (interactive) (leslie/transpose-buffers-down t))
(defun leslie/alias-transpose-buffer-up    () (interactive) (leslie/transpose-buffers-up t))
(defun leslie/alias-transpose-buffer-right () (interactive) (leslie/transpose-buffers-right t))

(defun leslie/alias-cast-buffer-left  () (interactive) (leslie/cast-buffer-left t))
(defun leslie/alias-cast-buffer-down  () (interactive) (leslie/cast-buffer-down t))
(defun leslie/alias-cast-buffer-up    () (interactive) (leslie/cast-buffer-up t))
(defun leslie/alias-cast-buffer-right () (interactive) (leslie/cast-buffer-right t))

(defun leslie/alias-duplicate-buffer-left  () (interactive) (leslie/duplicate-buffer-left t))
(defun leslie/alias-duplicate-buffer-down  () (interactive) (leslie/duplicate-buffer-down t))
(defun leslie/alias-duplicate-buffer-up    () (interactive) (leslie/duplicate-buffer-up t))
(defun leslie/alias-duplicate-buffer-right () (interactive) (leslie/duplicate-buffer-right t))

(defun leslie/alias-erlang-find-tag () (interactive) (erlang-find-tag (erlang-default-function-or-module)))

(defun leslie/alias-bash-shell () (interactive) (ansi-term "/bin/bash"))
(defun leslie/alias-clip-shell () (interactive) (ansi-term "/usr/bin/clisp"))
(defun leslie/alias-python-shell () (interactive) (ansi-term "/usr/bin/python"))

(defun leslie/alias-org-force-publish () (interactive) (org-publish-current-project t))

(defun leslie/alias-org-set-property-category () (interactive) (leslie/org-set-property "CATEGORY"))

(defun leslie/alias-org-agenda-n () (interactive) (org-agenda nil "n"))

(defun leslie/alias-sh-cmd-whole-buffer () (interactive) (leslie/sh-cmd nil t nil))
(defun leslie/alias-sh-cmd-split-lines () (interactive) (leslie/sh-cmd nil nil t))
(defun leslie/alias-sh-cmd-whole-buffer-split-lines () (interactive) (leslie/sh-cmd nil t t))
#+END_SRC

** Helper Functions
#+BEGIN_SRC emacs-lisp
(setq leslie/p1-prefix-normal   "C-M-S-")
(setq leslie/p1-prefix-special  "C-M-")
(setq leslie/p1-prefix-standard "M-f")

(setq leslie/p2-prefix-normal   "s-M-S-")
(setq leslie/p2-prefix-special  "s-M-")
(setq leslie/p2-prefix-standard "M-d")

(setq leslie/p3-prefix-normal   "s-C-S-")
(setq leslie/p3-prefix-special  "s-C-")
(setq leslie/p3-prefix-standard "M-s")

(setq leslie/p4-prefix-normal   "s-C-M-")
(setq leslie/p4-prefix-special  "s-C-M-")
(setq leslie/p4-prefix-standard "M-a")

(defun leslie/p1 (key command description &optional keymap)
  (let* ((prefix-normal   leslie/p1-prefix-normal)
         (prefix-special  leslie/p1-prefix-special)
         (standard-prefix leslie/p1-prefix-standard)
         (prefix-key (cond ((string= key ";") (concat prefix-special ":"))
                           ((string= key "-") (concat prefix-special "_"))
                           ((string= key "=") (concat prefix-special "+"))
                           ((string= key ",") (concat prefix-special "<"))
                           ((string= key ".") (concat prefix-special ">"))
                           ((string= key "/") (concat prefix-special "?"))
                           (t (concat prefix-normal key))))
         (standard-prefix-key (concat standard-prefix " " key)))
    (leslie/set-keys prefix-key standard-prefix-key command description keymap)))

(defun leslie/p2 (key command description &optional keymap)
  (let* ((prefix-normal   leslie/p2-prefix-normal)
         (prefix-special  leslie/p2-prefix-special)
         (standard-prefix leslie/p2-prefix-standard)
         (prefix-key (cond (t (concat prefix-special (upcase (substring key 0 1)) (substring key 1)))))
         (standard-prefix-key (concat standard-prefix " " key)))
    (leslie/set-keys prefix-key standard-prefix-key command description keymap)))

(defun leslie/p3 (key command description &optional keymap)
  (let* ((prefix-normal   leslie/p3-prefix-normal)
         (prefix-special  leslie/p3-prefix-special)
         (standard-prefix leslie/p3-prefix-standard)
         (prefix-key (cond (t (concat prefix-special (upcase (substring key 0 1)) (substring key 1)))))
         (standard-prefix-key (concat standard-prefix " " key)))
    (leslie/set-keys prefix-key standard-prefix-key command description keymap)))

(defun leslie/p4 (key command description &optional keymap)
  (let* ((prefix-normal   leslie/p4-prefix-normal)
         (prefix-special  leslie/p4-prefix-special)
         (standard-prefix leslie/p4-prefix-standard)
         (prefix-key (cond (t (concat prefix-normal key ))))
         (standard-prefix-key (concat standard-prefix " " key)))
    (leslie/set-keys prefix-key standard-prefix-key command description keymap)))

(defun leslie/set-keys (prefix-key standard-prefix-key command description &optional keymap)
  (cond (command
         (leslie/set-key prefix-key command description keymap)
         (leslie/set-key standard-prefix-key command description keymap))
        (t
         (leslie/set-prefix prefix-key description keymap)
         (leslie/set-prefix standard-prefix-key description keymap))))

(defun leslie/set-prefix (key description &optional keymap)
  (cond (keymap
         (general-define-key
           :keymaps keymap
           :states '(normal insert visual operator motion emacs)
           key (list :ignore t :which-key description)))
        (t
         (general-define-key
           :states '(normal insert visual operator motion emacs)
           key (list :ignore t :which-key description)))))

(defun leslie/set-key (key command description &optional keymap)
  (cond (keymap
         (general-define-key
          :keymaps keymap
          :states '(normal insert visual operator motion emacs)
          key (list command :which-key description)))
        (t
         (general-define-key 
          :states '(normal insert visual operator motion emacs)
          key (list command :which-key description)))))

#+END_SRC

** Term Mode Keys
Evil-mode interferes with the normal bash bindings. They must be dealt with.

*** C-a     - Go to beginning of line
#+BEGIN_SRC emacs-lisp
(evil-define-key 'insert term-raw-map (kbd "C-a") 'term-send-raw)
#+END_SRC

*** C-e     - Go to end of line
#+BEGIN_SRC emacs-lisp
(evil-define-key 'insert term-raw-map (kbd "C-e") 'term-send-raw)
#+END_SRC

*** M-f     - Go to next word
Interferes with my custom invokers.

*** M-b     - Go to previous word
Already build in.

*** C-x x   - Toggle point between current position and start of line
C-x interferes with emacs a lot. I am leaving this out one.

*** M-d     - Delete next word
Interferes with my custom invokers.

*** C-x C-e - Edit the current command in your text editor
Danger! Having this makes it too easy to invoke vim from within emacs.

Bad idea.

*** C--     - Undo previous action(s)
Does anyone use this? I won't. Leaving it out.

*** C-w     - Cut current word before the cursor
#+BEGIN_SRC emacs-lisp
(evil-define-key 'insert term-raw-map (kbd "C-w") 'term-send-raw)
#+END_SRC

*** C-k     - Cut from cursor to end of line
#+BEGIN_SRC emacs-lisp
(evil-define-key 'insert term-raw-map (kbd "C-k") 'term-send-raw)
#+END_SRC

*** C-u     - Cut from cursor to start of line
#+BEGIN_SRC emacs-lisp
(evil-define-key 'insert term-raw-map (kbd "C-u") 'term-send-raw)
#+END_SRC

*** C-y     - Paste the cut buffer at current position
#+BEGIN_SRC emacs-lisp
(evil-define-key 'insert term-raw-map (kbd "C-y") 'term-send-raw)
#+END_SRC

*** C-d     - Send EOF / Delete current character
#+BEGIN_SRC emacs-lisp
(evil-define-key 'insert term-raw-map (kbd "C-d") 'term-send-raw)
#+END_SRC

*** C-l     - Clear the terminal screen
Already built-in.

*** C-z     - Send current command to the background.
#+BEGIN_SRC emacs-lisp
;; C-z is more useful as a switch between evil and emacs states
;; So a command is available instead
(defun term-send-current-command-to-background ()
  (interactive)
  (term-send-raw-string "\C-z"))
#+END_SRC

*** C-r - Search history
#+BEGIN_SRC emacs-lisp
(evil-define-key 'insert term-raw-map (kbd "C-r") 'term-send-raw)
#+END_SRC

*** C-<backspace> - Delete prevous word
Not strictly a bash thing, but I'm putting it in anyway.
Simply send C-w instead
#+BEGIN_SRC emacs-lisp
(evil-define-key 'insert term-raw-map (kbd "C-<backspace>")
  'leslie/term/delete-previous-word)
#+END_SRC

*** C-<delete> - Delete next word
Not strictly a bash thing, but I'm putting it in anyway.
Simply send M-d instead
#+BEGIN_SRC emacs-lisp
(evil-define-key 'insert term-raw-map (kbd "C-<delete>")
  'leslie/term/delete-next-word)
#+END_SRC

*** C-<left> - Go to previous word
Not strictly a bash thing, but I'm putting it in anyway.
Simply send M-b instead
#+BEGIN_SRC emacs-lisp
(evil-define-key 'insert term-raw-map (kbd "C-<left>")
  'leslie/term/go-to-previous-word)
#+END_SRC

*** C-<right> - Go to next word
Not strictly a bash thing, but I'm putting it in anyway.
Simply send M-f instead
#+BEGIN_SRC emacs-lisp
(evil-define-key 'insert term-raw-map (kbd "C-<right>")
  'leslie/term/go-to-next-word)
#+END_SRC

** Unbinding Keys
#+BEGIN_SRC emacs-lisp
;(general-unbind 
;  '(normal insert visual operator)
;  '(global-map org-mode-map evil-org-mode-map)
  ;"C-S-h"
  ;"C-S-j"
  ;"C-S-k"
  ;"C-S-l"
  ;"C-M-S-d"
;)

;; Prevent these from appearing in the standard keymap
(global-unset-key (kbd "M-s ESC"))
(global-unset-key (kbd "M-s ."))
(global-unset-key (kbd "M-s _"))
(global-unset-key (kbd "M-s o"))
(global-unset-key (kbd "M-s w"))
#+END_SRC

** P1
#+BEGIN_SRC emacs-lisp
;;FUN      KEY    FUNCTION                              DESCRIPTION                           MODE
(leslie/p1 ","    'previous-buffer                      "prev buffer")
(leslie/p1 "-"    'leslie/alias-text-scale-down         "text scale down")
(leslie/p1 "."    'next-buffer                          "next buffer")
(leslie/p1 "/"    'leslie/alias-search-buffer           "search buffer")
(leslie/p1 ";"    'counsel-M-x                          "M-x")
(leslie/p1 "="    'leslie/alias-text-scale-up           "text scale up")
(leslie/p1 "a t"  'nil                                  "terminals")
(leslie/p1 "b b"  'ivy-switch-buffer                    "switch buffers")
(leslie/p1 "b c"  'nil                                  "cast buffers")
(leslie/p1 "b ch" 'leslie/alias-cast-buffer-left        "cast buffer left")
(leslie/p1 "b cj" 'leslie/alias-cast-buffer-down        "cast buffer down")
(leslie/p1 "b ck" 'leslie/alias-cast-buffer-up          "cast buffer up")
(leslie/p1 "b cl" 'leslie/alias-cast-buffer-right       "cast buffer right")
(leslie/p1 "b d"  'nil                                  "duplicate buffers")
(leslie/p1 "b dh" 'leslie/alias-duplicate-buffer-left   "duplicate buffer left")
(leslie/p1 "b dj" 'leslie/alias-duplicate-buffer-down   "duplicate buffer down")
(leslie/p1 "b dk" 'leslie/alias-duplicate-buffer-up     "duplicate buffer up")
(leslie/p1 "b dl" 'leslie/alias-duplicate-buffer-right  "duplicate buffer right")
(leslie/p1 "b f"  'leslie/show-file-path                "show file path")
(leslie/p1 "b o"  'open-in-new-config                   "open buffer in a new window config")
(leslie/p1 "b p"  'leslie/buffer-paste                  "paste buffer")
(leslie/p1 "b r"  'rename-buffer                        "rename buffer")
(leslie/p1 "b t"  'nil                                  "transpose buffers")
(leslie/p1 "b th" 'leslie/alias-transpose-buffer-left   "transpose windows left")
(leslie/p1 "b tj" 'leslie/alias-transpose-buffer-down   "transpose windows down")
(leslie/p1 "b tk" 'leslie/alias-transpose-buffer-up     "transpose windows up")
(leslie/p1 "b tl" 'leslie/alias-transpose-buffer-right  "transpose windows right")
(leslie/p1 "b x"  'leslie/smart-clear-buffer            "clear buffer")
(leslie/p1 "b y"  'leslie/buffer-yank                   "yank buffer")
(leslie/p1 "b"    'nil                                  "buffers")
(leslie/p1 "c"    'delete-window                        "close window")
(leslie/p1 "c"    'ranger-disable                       "close ranger"                        'ranger-mode-map)
(leslie/p1 "d"    'evil-goto-definition                 "goto definition")
(leslie/p1 "d"    'leslie/alias-erlang-find-tag         "goto definition"                     'erlang-mode-map)
(leslie/p1 "d"    'org-open-at-point                    "open link"                           'org-mode-map)
(leslie/p1 "e a"  'nil                                  "align")
(leslie/p1 "e aH" 'leslie/align-repeat-head             "regex ahead of match repeatedly")
(leslie/p1 "e aT" 'leslie/align-repeat-tail             "regex to tail of match repeatedly")
(leslie/p1 "e aa" 'erlang-align-arrows                  "align arrows"                        'erlang-mode-map)
(leslie/p1 "e ah" 'leslie/align-once-head               "regex ahead of match")
(leslie/p1 "e at" 'leslie/align-once-tail               "regex to tail of match")
(leslie/p1 "e c"  'ispell                               "spell check")
(leslie/p1 "e d"  'erlang-clone-arguments               "duplicate arguments"                 'erlang-mode-map)
(leslie/p1 "e f"  'nil                                  "formatting")
(leslie/p1 "e fb" 'json-mode-beautify                   "json beautify"                       'json-mode-map)
(leslie/p1 "e fi" 'indent-region                        "indent region")
(leslie/p1 "e fp" 'fill-paragraph                       "fill paragraph")
(leslie/p1 "e fr" 'fill-region                          "fill region")
(leslie/p1 "e i"  'erlang-indent-region                 "indent region"                       'erlang-mode-map)
(leslie/p1 "e j"  'erlang-generate-new-clause           "new clause"                          'erlang-mode-map)
(leslie/p1 "e l"  'org-insert-link                      "edit link"                           'org-mode-map)
(leslie/p1 "e s"  'nil                                  "surround")
(leslie/p1 "e s'" 'leslie/surround-s-quote              "single quote '")
(leslie/p1 "e s(" 'leslie/surround-parentheses          "parentheses ( )")
(leslie/p1 "e s)" 'leslie/surround-parentheses          "parentheses ( )")
(leslie/p1 "e s*" 'leslie/surround-asterisk             "asterisk *")
(leslie/p1 "e s+" 'leslie/surround-plus                 "plus +")
(leslie/p1 "e s-" 'leslie/surround-minus                "minus -")
(leslie/p1 "e s/" 'leslie/surround-slash                "slash /")
(leslie/p1 "e s=" 'leslie/surround-equals               "equals =")
(leslie/p1 "e s[" 'leslie/surround-brackets             "brackets [ ]")
(leslie/p1 "e s\"" 'leslie/surround-d-quote             "double quote \"")
(leslie/p1 "e s]" 'leslie/surround-brackets             "brackets [ ]")
(leslie/p1 "e ss" 'leslie/surround-region               "surround region")
(leslie/p1 "e s{" 'leslie/surround-braces               "braces { }")
(leslie/p1 "e s}" 'leslie/surround-braces               "braces { }")
(leslie/p1 "e"    'nil                                  "edits")
(leslie/p1 "f b"  'ivy-switch-buffer                    "buffers")
(leslie/p1 "f d"  'dired-create-directory               "create directory"                    'ranger-mode-map)
(leslie/p1 "f f"  'counsel-find-file                    "find file")
(leslie/p1 "f h"  'org-html-export-to-html              "export to html"                      'org-mode-map)
(leslie/p1 "f r"  'counsel-recentf                      "find recent file")
(leslie/p1 "f"    'nil                                  "files")
(leslie/p1 "h"    'windmove-left                        "win left")
(leslie/p1 "j"    'windmove-down                        "win down")
(leslie/p1 "k"    'windmove-up                          "win up")
(leslie/p1 "l"    'windmove-right                       "wind right")
(leslie/p1 "o i"  'leslie/open-in-intellij              "open in intellij")
(leslie/p1 "o r"  'ranger                               "ranger")
(leslie/p1 "o tc" 'leslie/alias-clisp-shell             "clisp")
(leslie/p1 "o te" 'erlang-shell                         "erlang")
(leslie/p1 "o tp" 'leslie/alias-python-shell            "python")
(leslie/p1 "o tt" 'leslie/alias-bash-shell              "bash")
(leslie/p1 "o"    'nil                                  "applications")
(leslie/p1 "p ?"  'projectile-command-map               "other")
(leslie/p1 "p O"  'leslie/alias-org-force-publish       "force org publish project"           'org-mode-map)
(leslie/p1 "p b"  'projectile-switch-to-buffer          "switch project buffer")
(leslie/p1 "p c"  'leslie/check-project                 "check / compile project")
(leslie/p1 "p f"  'counsel-projectile-find-file         "find project file")
(leslie/p1 "p g"  'counsel-projectile-grep              "find instances in project")
(leslie/p1 "p i"  'org-insert-link                      "insert link")
(leslie/p1 "p o"  'org-publish-current-project          "org publish project"                 'org-mode-map)
(leslie/p1 "p p"  'counsel-projectile-switch-project    "switch project")
(leslie/p1 "p r"  'leslie/revert-project-buffers        "revert project buffers")
(leslie/p1 "p s"  'org-store-link                       "copy link")
(leslie/p1 "p t"  'leslie/regenerate-tags               "regenerate tags")
(leslie/p1 "p w"  'leslie/save-project-buffers          "save all project buffers")
(leslie/p1 "p w"  'org-save-all-org-buffers             "save all org buffers"                'org-mode-map)
(leslie/p1 "p"    'nil                                  "projects")
(leslie/p1 "q"    'leslie/kill-this-buffer              "kill buffer")
(leslie/p1 "r n"  'nil                                  "numbers")
(leslie/p1 "r ni" 'increment-register                   "increment register with number")
(leslie/p1 "r np" 'insert-register                      "paste number from register")
(leslie/p1 "r ny" 'number-to-register                   "yank number to register")
(leslie/p1 "r p"  'nil                                  "positions")
(leslie/p1 "r pp" 'jump-to-register                     "goto register position")
(leslie/p1 "r py" 'point-to-register                    "yank current position to register")
(leslie/p1 "r r"  'nil                                  "rectangle")
(leslie/p1 "r rp" 'insert-register                      "paste rectangle from register")
(leslie/p1 "r ry" 'copy-rectangle-to-register           "yank rectangle to register")
(leslie/p1 "r t"  'nil                                  "text")
(leslie/p1 "r ta" 'append-to-register                   "append text to register")
(leslie/p1 "r tb" 'prepend-to-register                  "prepend text to register (before)")
(leslie/p1 "r tp" 'insert-register                      "paste text register")
(leslie/p1 "r ty" 'copy-to-register                     "yank text to register")
(leslie/p1 "r"    'nil                                  "registers")
(leslie/p1 "t R"  'auto-revert-mode                     "toggle auto revert mode")
(leslie/p1 "t W"  'leslie/toggle-whitespace-full        "toggle whitespace full")
(leslie/p1 "t c"  'comment-line                         "toggle comment line")
(leslie/p1 "t f"  'font-lock-mode                       "toggle auto font formatting")
(leslie/p1 "t h"  'hl-line-mode                         "toggle highight line mode")
(leslie/p1 "t h"  'ranger-toggle-dotfiles               "toggle hidden"                       'ranger-mode-map)
(leslie/p1 "t i"  'org-toggle-inline-images             "toggle images"                       'org-mode-map)
(leslie/p1 "t l"  'nlinum-mode                          "toggle relative line numbers")
(leslie/p1 "t p"  'projectile-mode                      "toggle projectile mode")
(leslie/p1 "t r"  'rainbow-delimiters-mode              "toggle rainbow delimiters")
(leslie/p1 "t t"  'nil                                  "tables"                              'org-mode-map)
(leslie/p1 "t tr" 'org-table-toggle-coordinate-overlay  "toggle table coords"                 'org-mode-map)
(leslie/p1 "t w"  'whitespace-mode                      "toggle whitespace display")
(leslie/p1 "t"    'nil                                  "toggles")
(leslie/p1 "v D"  'vc-ediff                             "ediff")
(leslie/p1 "v a"  'vc-annotate                          "annotate")
(leslie/p1 "v b"  'vc-retrieve-tag                      "change branch")
(leslie/p1 "v d"  'vc-version-ediff                     "version ediff")
(leslie/p1 "v"    'nil                                  "version control")
(leslie/p1 "w e"  'balance-windows                      "balance windows")
(leslie/p1 "w h"  'split-window-right                   "split horizontal")
(leslie/p1 "w o"  'delete-other-windows                 "delete other windows")
(leslie/p1 "w r"  'revert-buffer                        "reload from disk")
(leslie/p1 "w v"  'split-window-below                   "split vertical")
(leslie/p1 "w z"  'maximize-window                      "maximize")
(leslie/p1 "w"    'nil                                  "windows")
(leslie/p1 "x"    'nil                                  "sh cmd")
(leslie/p1 "x x"  'leslie/sh-cmd                        "sh cmd")
(leslie/p1 "x X"  'leslie/alias-sh-cmd-whole-buffer     "sh cmd whole buffer")
(leslie/p1 "x s"  'leslie/alias-sh-cmd-split-lines      "sh cmd split lines")
(leslie/p1 "x S"  'leslie/alias-sh-cmd-whole-buffer-split-lines "sh cmd whole buffer split lines")
#+END_SRC

** P2
#+BEGIN_SRC emacs-lisp
;;         KEY    FUNCTION                              DESCRIPTION                           MODE
(leslie/p2 "h"    'shrink-window-horizontally           "shrink horz"                         'override)
(leslie/p2 "j"    'enlarge-window                       "enlarge vert"                        'override)
(leslie/p2 "k"    'shrink-window                        "shrink vert"                         'override)
(leslie/p2 "l"    'enlarge-window-horizontally          "enlarge horz"                        'override)
#+END_SRC

** P3
#+BEGIN_SRC emacs-lisp
;;         KEY    FUNCTION                              DESCRIPTION                           MODE
(leslie/p3 "f r"  'set-frame-name                       "rename frame")
(leslie/p3 "f c"  'make-frame                           "create new frame")
(leslie/p3 "f o"  'pop-out-config-to-new-frame          "pop out to frame")
(leslie/p3 "f"    'nil                                  "frames")
(leslie/p3 "h"    'evil-jump-backward                   "jump back")
(leslie/p3 "l"    'evil-jump-forward                    "jump forward")
#+END_SRC

** P4
#+BEGIN_SRC emacs-lisp
;;         KEY    FUNCTION                              DESCRIPTION                           MODE
(leslie/p4 "["    'org-previous-link                    "previous link"                       'org-mode-map)
(leslie/p4 "]"    'org-next-link                        "next link"                           'org-mode-map)
(leslie/p4 "a"    'leslie/alias-org-agenda-n            "agenda")
(leslie/p4 "b a"  'leslie/alias-org-agenda-n            "agenda")
(leslie/p4 "b c"  'leslie/open-calendar                 "calendar")
(leslie/p4 "b i"  'leslie/open-inbox                    "inbox")
(leslie/p4 "b r"  'leslie/open-read                     "read")
(leslie/p4 "b s"  'leslie/open-someday                  "someday")
(leslie/p4 "b t"  'leslie/open-todo                     "todo")
(leslie/p4 "b vc" 'org-columns                          "columns"                             'org-mode-map)
(leslie/p4 "b"    'nil                                  "buffer switching")
(leslie/p4 "c c"  'leslie/cortex/continue               "continue in another slide"           'org-mode-map)
(leslie/p4 "c f"  'leslie/cortex/search-slides          "search slides")
(leslie/p4 "c l"  'leslie/cortex/link                   "cortex link"                         'org-mode-map)
(leslie/p4 "c n"  'leslie/cortex/create-file            "create cortex file")
(leslie/p4 "c r"  'leslie/cortex/rename-slide           "rename slide"                        'org-mode-map)
(leslie/p4 "c"    'nil                                  "cortex"                              'org-mode-map)
(leslie/p4 "f m"  'leslie/org-file-reference            "file reference"                      'org-mode-map)
(leslie/p4 "f m"  'leslie/org-file-reference            "file reference"                      'org-mode-map)
(leslie/p4 "f p"  'leslie/pims/set-project              "set as project"                      'org-mode-map)
(leslie/p4 "f r"  'org-refile                           "org refile"                          'org-mode-map)
(leslie/p4 "f t"  'leslie/pims/set-todo                 "set as todo"                         'org-mode-map)
(leslie/p4 "f"    'nil                                  "filing"                              'org-mode-map)
(leslie/p4 "h"    'outline-backward-same-level          "back same level")
(leslie/p4 "i"    'org-clock-in                         "clock in"                            'org-mode-map)
(leslie/p4 "j"    'outline-next-visible-heading         "next visible heading")
(leslie/p4 "k"    'outline-previous-visible-heading     "prev visible heading")
(leslie/p4 "l"    'outline-forward-same-level           "forward same level")
(leslie/p4 "m"    'org-archive-subtree-default          "archive"                             'org-mode-map)
(leslie/p4 "n"    'org-capture                          "org capture")
(leslie/p4 "o"    'org-clock-out                        "clock out"                           'org-mode-map)
(leslie/p4 "p c"  'leslie/alias-org-set-property-category "set category"                      'org-mode-map)
(leslie/p4 "p d"  'org-deadline                         "deadline"                            'org-mode-map)
(leslie/p4 "p p"  'org-set-property                     "set property (free)"                 'org-mode-map)
(leslie/p4 "p s"  'org-schedule                         "schedule"                            'org-mode-map)
(leslie/p4 "p t"  'org-set-tags-command                 "set tags"                            'org-mode-map)
(leslie/p4 "p"    'nil                                  "property"                            'org-mode-map)
(leslie/p4 "t c"  'org-table-create-or-convert-from-region "create / convert table"           'org-mode-map)
(leslie/p4 "t d"  'nil                                  "delete"                              'org-mode-map)
(leslie/p4 "t dc" 'org-table-delete-column              "delete column"                       'org-mode-map)
(leslie/p4 "t dr" 'org-table-kill-row                   "delete row"                          'org-mode-map)
(leslie/p4 "t i"  'nil                                  "insert"                              'org-mode-map)
(leslie/p4 "t ic" 'org-table-insert-column              "insert column"                       'org-mode-map)
(leslie/p4 "t ih" 'org-table-insert-hline               "insert horizontal line"              'org-mode-map)
(leslie/p4 "t ir" 'org-table-insert-row                 "insert row"                          'org-mode-map)
(leslie/p4 "t"    'nil                                  "tables"                              'org-mode-map)
(leslie/p4 "u"    'outline-up-heading                   "up heading")
(leslie/p4 "v c"  'leslie/insert-created-timestamp      "created date"                        'org-mode-map)
(leslie/p4 "v d"  'org-time-stamp                       "time stamp"                          'org-mode-map)
(leslie/p4 "v p"  'counsel-yank-pop                     "paste selector")
(leslie/p4 "v"    'nil                                  "insert items"                        'org-mode-map)
(leslie/p4 "x"    'nil                                  "none")
(leslie/p4 "x"    'org-toggle-checkbox                  "toggle checkbox"                     'org-mode-map)
#+END_SRC

** Other
*** Non-P Bindings
#+BEGIN_SRC emacs-lisp

#+END_SRC

*** Help
#+BEGIN_SRC emacs-lisp
(general-define-key
  "C-h v" 'counsel-describe-variable
  "C-h f" 'counsel-describe-function
)
#+END_SRC
