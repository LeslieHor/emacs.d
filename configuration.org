#+TITLE: emacs.d config

* Better defaults

** Start Up

#+BEGIN_SRC emacs-lisp
(server-start) ; Start emacs server
(desktop-save-mode 1) ; Save session and restore on next launch
#+END_SRC

** UI

#+BEGIN_SRC emacs-lisp
(setq inhibit-startup-screen t) ; inhibit useless and old-school startup screen
(setq ring-bell-function 'ignore) ; silent bell when you make a mistake
(setq-default frame-title-format '("%b - Emacs")) ; set the emacs title.
                                        ; overrides the old "emacs@HOST" title
(set-frame-font "DejaVu Sans Mono 6" nil t)
(menu-bar-mode -1)
(tool-bar-mode -1)
(scroll-bar-mode -1)
(load-theme 'wheatgrass)
; Split vertically by default
(setq split-width-threshold 0)
(setq split-height-threshold nil)
#+END_SRC

** Tab Behaviour

#+BEGIN_SRC emacs-lisp
(setq-default indent-tabs-mode nil) ; don't insert tabs
(setq-default tab-width 4) ; self-documenting
(setq indent-line-function 'insert-tab)
#+END_SRC

** Backup and autosave locations

#+BEGIN_SRC emacs-lisp
(setq backup-directory-alist '((".*" . "~/.emacs.d/backup")))
(setq auto-save-file-name-transforms '((".*" "~/.emacs.d/autosave/" t)))
#+END_SRC

** Default major mode

#+BEGIN_SRC emacs-lisp
(setq-default major-mode 'text-mode)
#+END_SRC

* Whitespace

Force it on all the time.

Highlights:
- face visualisation
- empty lines at beginning of end of buffer
- tabs
- tailing blanks

#+BEGIN_SRC emacs-lisp
(require 'whitespace)
(setq whitespace-style '(face empty tabs trailing))
(global-whitespace-mode t)
#+END_SRC

* Org

#+BEGIN_SRC emacs-lisp
(setq org-html-postamble "<p class=\"created\">Created: %T</p>")
(setq org-src-fontify-natively t)
(setq org-src-tab-acts-natively t)
;; Set up languages for running code blocks in org
(org-babel-do-load-languages
 'org-babel-load-languages '(
                             (python . t)
                             (sh . t)
                             (emacs-lisp . t)
                             )
 )
#+END_SRC

* Mode Line

#+BEGIN_SRC emacs-lisp
(column-number-mode 1) ; show column number
(set-face-attribute 'mode-line nil ; Set active mode line colour
                    :foreground "white"
                    :background "blue")
(set-face-attribute 'mode-line-buffer-id nil ; Set buffer id colour
                    :foreground "white"
                    :background "black")
#+END_SRC

* Custom Functions

** eshell-new

Interative function to create a new instance of eshell.

#+BEGIN_SRC emacs-lisp
(defun eshell-new()
  "Open a new instance of eshell."
  (interactive)
  (eshell 'N))
#+END_SRC

** transpose-buffers

Transpose two buffers.

#+BEGIN_SRC emacs-lisp
(defun transpose-buffers (dir &optional arg)
  "Transpose the buffers in the current window and the target window
If arg is non-nil, the selected window will change to keep the source buffer
selected."
  (let ((target-window (windmove-find-other-window dir))
        (source-window (selected-window)))
    (cond ((null target-window)
           (format "No window found in dir %s" dir))
          ((and (window-minibuffer-p target-window)
                (not (minibuffer-window-active-p target-window)))
           (user-error "Minibuffer is inactive"))
          (t
           (let ((target-buffer (window-buffer target-window))
                 (source-buffer (window-buffer)))
             (set-window-buffer target-window source-buffer)
             (set-window-buffer source-window target-buffer))
           (if arg
               (select-window target-window))))))

(defun transpose-buffers-left (&optional arg)
    "Transpose buffers from current window to buffer to the left"
  (interactive)
  (transpose-buffers 'left arg))

(defun transpose-buffers-up (&optional arg)
    "Transpose buffers from current window to buffer above"
  (interactive)
  (transpose-buffers 'up arg))

(defun transpose-buffers-right (&optional arg)
    "Transpose buffers from current window to buffer to the right"
  (interactive)
  (transpose-buffers 'right arg))

(defun transpose-buffers-down (&optional arg)
    "Transpose buffers from current window to buffer below"
  (interactive)
  (transpose-buffers 'down arg))
#+END_SRC

** cast-buffer

Send a buffer to another window.

#+BEGIN_SRC emacs-lisp
(defun cast-buffer (dir &optional arg)
  "Casts the current buffer to window in direction dir, and switches current
window back to last buffer.
If arg is non-nil, the targetted window is selected."
  (let ((target-window (windmove-find-other-window dir))
        (source-buffer (window-buffer)))
    (cond ((null target-window)
           (format "No window found in dir %s" dir))
          ((and (window-minibuffer-p target-window)
                (not (minibuffer-window-active-p target-window)))
           (user-error "Minibuffer is inactive"))
          (t
           (set-window-buffer target-window source-buffer)
           (previous-buffer)
           (if arg
               (select-window target-window))))))

(defun cast-buffer-left (&optional arg)
  "Cast current buffer to the left"
  (interactive)
  (cast-buffer 'left arg))

(defun cast-buffer-up (&optional arg)
  "Cast current buffer up"
  (interactive)
  (cast-buffer 'up arg))

(defun cast-buffer-right (&optional arg)
  "Cast current buffer to the right"
  (interactive)
  (cast-buffer 'right arg))

(defun cast-buffer-down (&optional arg)
  "Cast current buffer down"
  (interactive)
  (cast-buffer 'down arg))
#+END_SRC

** duplicate-buffer

Open buffer in another window.

#+BEGIN_SRC emacs-lisp
(defun duplicate-buffer (dir &optional arg)
  "Opens the current buffer in the window in the direction dir
If arg is non-nil, the targeted window is selected"
  (let ((target-window (windmove-find-other-window dir))
        (source-buffer (window-buffer)))
    (cond ((null target-window)
           (format "No window found in dir %s" dir))
          ((and (window-minibuffer-p target-window)
                (not (minibuffer-window-active-p target-window)))
           (user-error "Minibuffer is inactive"))
          (t
           (set-window-buffer target-window source-buffer)
           (if arg
               (select-window target-window))))))

(defun duplicate-buffer-left (&optional arg)
  "Cast current buffer to the left"
  (interactive)
  (duplicate-buffer 'left arg))

(defun duplicate-buffer-up (&optional arg)
  "Cast current buffer up"
  (interactive)
  (duplicate-buffer 'up arg))

(defun duplicate-buffer-right (&optional arg)
  "Cast current buffer to the right"
  (interactive)
  (duplicate-buffer 'right arg))

(defun duplicate-buffer-down (&optional arg)
  "Cast current buffer down"
  (interactive)
  (duplicate-buffer 'down arg))
#+END_SRC

** open-in-new-config

Open a buffer in a new eyebrowse window config

#+BEGIN_SRC emacs-lisp
(defun open-in-new-config ()
  "Open current buffer in a new eyebrowse config"
  (interactive)
  (let ((current-buffer (window-buffer)))
    (eyebrowse-create-window-config)
    (set-window-buffer (selected-window) current-buffer)))
#+END_SRC

** get-string-from-file

Read a file in as a string.

#+BEGIN_SRC emacs-lisp
(defun get-string-from-file (filePath)
  "Return filePath's file content."
  (with-temp-buffer
    (insert-file-contents filePath)
    (buffer-string)))
#+END_SRC

[[http://ergoemacs.org/emacs/elisp_read_file_content.html][Credits to “Pascal J Bourguignon” and “TheFlyingDutchman"]]

** regenerate-tags

Regenerate tags using a command defined in the project root under the =.emacs=
directory.

#+BEGIN_SRC emacs-lisp
(defun regenerate-tags ()
  "use the generate-tags script in the project root to generate tags"
  (interactive)
  (cond ((projectile-project-root)
         (let* ((root-dir (projectile-project-root))
                (generate-tags-script (concat root-dir ".emacs/generate-tags"))
                (tag-command (concat ". " generate-tags-script " " root-dir))
                (result (shell-command-to-string tag-command)))
           (message result)))
        (t
         (user-error "Not in a project!"))))
#+END_SRC

** set-frame-title

Set the frame's title in a custom way.

#+BEGIN_SRC emacs-lisp
(defun set-frame-title ()
  "Sets the frame's title"
  (interactive)
  (let ((custom-title (read-string "Frame title: ")))
    (set-frame-parameter nil 'custom-title custom-title)
    (set-frame-titles)
    (message "Title set to %s" custom-title)))
#+END_SRC

** open-terminal-in-workdir

Opens a konsole in the current project root. If not in project, opens it in the
current directory.

#+BEGIN_SRC emacs-lisp
(defun open-terminal-in-workdir ()
 "Opens a terminal in the project root.
If not in a project, opens it in the current directory."
 (interactive)
 (let ((workdir (if (projectile-project-root)
                    (projectile-project-root)
                  default-directory)))
   (call-process-shell-command
    (concat "konsole --workdir " workdir) nil 0)))
#+END_SRC

** pop-out-config-to-new-frame

Open a new frame and copy the window config into the newly created frame.

#+BEGIN_SRC emacs-lisp
(defvar temp-new-frame-config nil
  "Temporarily stores window config that will be loaded when a new frame is
created. This variable is cleared after a frame loads the config.")

(defun pop-out-config-to-new-frame ()
  "Open the current eyebrowse config in a new frame"
  (interactive)
  (setq temp-new-frame-config (cadr (assq
                                     (eyebrowse--get 'current-slot)
                                     (eyebrowse--get 'window-configs))))
  (make-frame))

(defun set-frame-initial-config (frame)
  (when temp-new-frame-config
    (select-frame frame)
    (eyebrowse--fixup-window-config temp-new-frame-config)
    (window-state-put temp-new-frame-config (frame-root-window) 'safe)
    (setq temp-new-frame-config nil)))

(add-hook 'after-make-frame-functions 'set-frame-initial-config)
#+END_SRC

** whitespace-mode

Toggle on and off whitespace trailing mode

#+BEGIN_SRC emacs-lisp
(defun toggle-whitespace-full ()
  "toggle display of more whitespace"
  (interactive)
  (whitespace-toggle-options '(lines-tail newline-mark)))
#+END_SRC

** alignment functions

#+BEGIN_SRC emacs-lisp
(defun align-once-head (start end regexp)
  "Align by regex once, adding spaces to the head of the regexp"
  (interactive "r\nsAlign once head regexp: ")
  (align-regexp start end
                (concat "\\(\\s-*\\)" regexp) 1 1 nil))

(defun align-once-tail (start end regexp)
  "Align by regex once, adding spaces to the tail of the regexp"
  (interactive "r\nsAlign once tail regexp: ")
  (align-regexp start end
                (concat regexp "\\(\\s-*\\)") 1 1 nil))

(defun align-repeat-head (start end regexp)
  "Align by regex repeatedly, adding spaces to the head of the regexp"
  (interactive "r\nsAlign repeat head regexp: ")
  (align-regexp start end
                (concat "\\(\\s-*\\)" regexp) 1 1 t))

(defun align-repeat-tail (start end regexp)
  "Align by regex repeatedly, adding spaces to the tail of the regexp"
  (interactive "r\nsAlign repeat tail regexp: ")
  (align-regexp start end
                (concat regexp "\\(\\s-*\\)") 1 1 t))
#+END_SRC
** file opener functions
Some extra functions to aid in opening files

#+BEGIN_SRC emacs-lisp
(defun find-file-line (filename linenum)
  "invoke function find-file and goto-line"
  (find-file filename)
  (goto-line linenum))
#+END_SRC

The =find-file-line= function expects two args. We just therefore parse any
FILENAME:LINENUMBER string that it uses.

#+BEGIN_SRC emacs-lisp
(defun parse-file-special-syntax (file-string)
  "parses the format FILENAME:LINENUMBER"
  (let* ((file-list (split-string file-string ":"))
         (filename (car file-list))
         (line-number (string-to-number(cadr file-list))))
    (list filename line-number)))
#+END_SRC

We also want the ability to parse dirty file paths.

#+BEGIN_SRC emacs-lisp
(defun clean-file-path (file-string)
  "cleans the file path"
  (replace-regexp-in-string
   "^.*:[0-9]*\\(.*\\)$"
   ""
   file-string
   nil nil 1))
#+END_SRC

Plus we need a function to tie it all together.

#+BEGIN_SRC emacs-lisp
(defun find-file-special-syntax (file-string)
  "opens special syntax"
  (apply 'find-file-line
         (parse-file-special-syntax
          (clean-file-path file-string))))
#+END_SRC

** project compilation

Compile / check the project and send results to ivy-read.

Expects results in the format:

#+BEGIN_EXAMPLE
FILENAME:100 explanation
FILENAME:200 explanation
FILENAME:40can also be dirty
#+END_EXAMPLE

#+BEGIN_SRC emacs-lisp
(defun check-project ()
  "run .emacs/check-project and put results in ivy-read"
  (interactive)
  (cond ((projectile-project-root)
         (let* ((root-dir (projectile-project-root))
                (script (concat root-dir ".emacs/check-project"))
                (command (concat ". " script " " root-dir))
                (result (shell-command-to-string command)))
           (cond ((> (length result) 0)
                  (ivy-read "Check project results: "
                            (split-string result "\n")
                            :action 'find-file-special-syntax))
                 (t
                  (user-error "Check complete")))))
        (t
         (user-error "Not in a project!"))))
#+END_SRC

* Package Specific

** which-key

#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/which-key-3.3.1")
(require 'which-key)
(which-key-mode)
#+END_SRC

** evil

Load evil, and its dependencies in it comes with.

#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/evil-1.2.14")
(add-to-list 'load-path "~/.emacs.d/packages/evil-1.2.14/lib")
(require 'evil)
(evil-mode 1)
#+END_SRC

Rebind the ~q~ and ~quit~ commands to make more sense.

#+BEGIN_SRC emacs-lisp
(evil-ex-define-cmd "q" 'kill-this-buffer) ; :q should kill the buffer rather
                                        ; than quiting emacs
(evil-ex-define-cmd "quit" 'evil-quit) ; :quit to quit emacs
#+END_SRC

** evil-leader

#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/evil-leader-0.4.3")
(require 'evil-leader)
(global-evil-leader-mode)
#+END_SRC

** evil-org

#+BEGIN_SRC emacs-lisp
(add-to-list
 'load-path
 "~/.emacs.d/packages/evil-org-mode-b6d652a9163d3430a9e0933a554bdbee5244bbf6")
(require 'evil-org)
(add-hook 'org-mode-hook 'evil-org-mode)
(evil-org-set-key-theme '(navigation insert textobjects additional calendar))
(add-hook 'org-mode-hook
          (lambda ()
          (setq evil-auto-indent nil)))
(require 'evil-org-agenda)
(evil-org-agenda-set-keys)
#+END_SRC

** evil-numbers

#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/evil-numbers-0.4")
(require 'evil-numbers)
#+END_SRC

** evil-quickscope

#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/evil-quickscope-0.1.4")
(require 'evil-quickscope)
(global-evil-quickscope-mode 1)
#+END_SRC

** ivy / swiper / counsel

#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/swiper-0.11.0")
(require 'ivy)
(require 'swiper)
(require 'counsel)
(setq ivy-use-virtual-buffers t)
(setq ivy-count-format "(%d/%d) ")
#+END_SRC

** projectile

#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/projectile-2.0.0")
(require 'projectile)
(projectile-mode +1)
(setq projectile-project-search-path '("~/projects/")) ; where the projects are
(setq projectile-completion-system 'ivy)
#+END_SRC

** counsel-projectile

#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/counsel-projectile-0.3.0")
(require 'counsel-projectile)
(setq counsel-projectile-grep-initial-input '(ivy-thing-at-point))
                                        ; this required a fix that was taken
                                        ; from commit a07ddc8
#+END_SRC

** ranger

#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/ranger.el-0.9.8.5")
(require 'ranger)
#+END_SRC

** neotree

#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/emacs-neotree-0.5.2")
(require 'neotree)
(setq neo-theme 'arrow)
(setq neo-autorefresh nil)
#+END_SRC

Neotree keybindings conflict with evil-moe, so rebind them.

#+BEGIN_SRC emacs-lisp
(evil-define-key 'normal neotree-mode-map (kbd "TAB") 'neotree-enter)
(evil-define-key 'normal neotree-mode-map (kbd "SPC") 'neotree-quick-look)
(evil-define-key 'normal neotree-mode-map (kbd "q") 'neotree-hide)
(evil-define-key 'normal neotree-mode-map (kbd "RET") 'neotree-enter)
(evil-define-key 'normal neotree-mode-map (kbd "g") 'neotree-refresh)
(evil-define-key 'normal neotree-mode-map (kbd "n") 'neotree-next-line)
(evil-define-key 'normal neotree-mode-map (kbd "p") 'neotree-previous-line)
(evil-define-key 'normal neotree-mode-map (kbd "A") 'neotree-stretch-toggle)
(evil-define-key 'normal neotree-mode-map (kbd "H") 'neotree-hidden-file-toggle)
#+END_SRC

** rainbow-delimiters

#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/rainbow-delimiters-2.1.3")
(require 'rainbow-delimiters)
#+END_SRC

Set the colours to be as distinct as possible.

#+BEGIN_SRC emacs-lisp
(set-face-attribute 'rainbow-delimiters-depth-1-face nil :foreground "#e6194B")
(set-face-attribute 'rainbow-delimiters-depth-2-face nil :foreground "#3cb44b")
(set-face-attribute 'rainbow-delimiters-depth-3-face nil :foreground "#ffe119")
(set-face-attribute 'rainbow-delimiters-depth-4-face nil :foreground "#4363d8")
(set-face-attribute 'rainbow-delimiters-depth-5-face nil :foreground "#f58231")
(set-face-attribute 'rainbow-delimiters-depth-6-face nil :foreground "#911eb4")
(set-face-attribute 'rainbow-delimiters-depth-7-face nil :foreground "#42d4f4")
(set-face-attribute 'rainbow-delimiters-depth-8-face nil :foreground "#f032e6")
(set-face-attribute 'rainbow-delimiters-depth-9-face nil :foreground "#bfef45")
(set-face-attribute 'rainbow-delimiters-depth-9-face nil :foreground "#bfef45")
(set-face-attribute 'rainbow-delimiters-unmatched-face nil
                    :background "#ff0000"
                    :foreground "#ffffff")
#+END_SRC

** beacon

#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/beacon-1.3.4")
(require 'beacon)
(beacon-mode 1)
#+END_SRC

** json-mode

#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/json-snatcher-1.0.0")
(add-to-list 'load-path "~/.emacs.d/packages/json-reformat-0.0.6")
(add-to-list 'load-path "~/.emacs.d/packages/json-mode-1.7.0")
(require 'json-mode)
#+END_SRC

** eyebrowse

#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/dash.el-2.16.0")
(add-to-list 'load-path "~/.emacs.d/packages/eyebrowse-0.7.7")
(require 'eyebrowse)
(setq eyebrowse-new-workspace t) ; New workspaces start with scratch buffer
(eyebrowse-mode) ; enable global eyebrowse mode on start up
#+END_SRC

Set the format of the status line.

#+BEGIN_SRC emacs-lisp
(setq eyebrowse-mode-line-left-delimiter "| ")
(setq eyebrowse-mode-line-right-delimiter " |")
(setq eyebrowse-mode-line-separator " | ")
(setq eyebrowse-mode-line-style 'always) ; Will show in title bar instead
(setq eyebrowse-tagged-slot-format "%s: %t")
#+END_SRC

Eyebrowse mode line takes up too much space. Show it in the title bar instead.

Slight alteration is required of the eyebrowse package to force it to calculate
the mode line, even when I don't want to show it.

#+BEGIN_SRC emacs-lisp
(defun eyebrowse-workspaces-string (&optional frame)
    "Get the current workspaces as a string."
    (let ((workspaces (substring-no-properties
                       (eyebrowse-mode-line-indicator frame))))
      (replace-regexp-in-string
       (format "| \\(%s.*?\\) |.*\\'" (eyebrowse--get 'current-slot frame))
       "> \\1 <"
       workspaces
       nil nil 1)))
(defun eyebrowse-workspaces-string-rename (arg1 arg2)
    "Advice for `eyebrowse-rename-window-config'. Requires two
    arguments ARG1 and ARG2 to work..."
    (set-frame-titles))
(defun set-frame-titles ()
  (dolist (frame (frame-list))
    (set-frame-parameter frame 'title
                         (concat
                          (frame-parameter frame 'custom-title)
                          " : "
                          (eyebrowse-workspaces-string frame)
                          " - Emacs"))))

(set-frame-titles)

(add-hook 'eyebrowse-post-window-switch-hook 'set-frame-titles)
(advice-add 'eyebrowse-close-window-config
            :after #'set-frame-titles)
(advice-add 'eyebrowse-rename-window-config
            :after #'eyebrowse-workspaces-string-rename)
#+END_SRC

** telephone-line

#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/telephone-line-0.4")
(require 'telephone-line)
#+END_SRC

Telephone line customization.

#+BEGIN_SRC emacs-lisp
(setq telephone-line-lhs
      '((evil   . (telephone-line-evil-tag-segment))
        (accent . (telephone-line-vc-segment
                   telephone-line-erc-modified-channels-segment
                   telephone-line-process-segment))
        (nil    . (telephone-line-buffer-segment))))
(setq telephone-line-rhs
      '((nil    . (telephone-line-misc-info-segment))
        (accent . (telephone-line-major-mode-segment))
        (evil   . (telephone-line-airline-position-segment))))
(telephone-line-mode 1)
#+END_SRC

** nlinum-relative

nlinum is a dependency.

Delay is kinda required or else files with loads of lines tend to lag.

#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/nlinum-1.8.1")
(require 'nlinum)

(add-to-list
 'load-path
 "~/.emacs.d/packages/nlinum-relative-5b9950c97ba79a6f0683e38b13da23f39e01031c")
(require 'nlinum-relative)
(nlinum-relative-setup-evil)
(global-nlinum-relative-mode)
(setq nlinum-relative-redisplay-delay 0.2) ; delay
(setq nlinum-relative-current-symbol "") ; e.g. "->"
                                        ; "" for display current line number
(setq nlinum-relative-offset 0)          ; 1 if you want 0, 2, 3...
#+END_SRC

I want relative numbers to display when in evil operator mode.

#+BEGIN_SRC emacs-lisp
(add-hook 'evil-operator-state-entry-hook
          (lambda () (when (bound-and-true-p nlinum-relative-mode)
                       (nlinum-relative-on))))
(add-hook 'evil-operator-state-exit-hook
          (lambda () (when (bound-and-true-p nlinum-relative-mode)
                       (nlinum-relative-off))))
#+END_SRC

** diff-hl

#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages/diff-hl-1.8.6")
(require 'diff-hl)
(require 'diff-hl-flydiff)
(global-diff-hl-mode)
(diff-hl-flydiff-mode) ; Don't wait for save to calcualte diff
#+END_SRC

** erlang

#+BEGIN_SRC emacs-lisp
(setq load-path (cons  "~/erl_rel/18.3/lib/tools-2.8.3/emacs" load-path))
(setq erlang-root-dir "~/erl_rel/18.3")
(setq exec-path (cons "~/erl_rel/18.3/bin" exec-path))
(require 'erlang-start)
#+END_SRC

** term mode
Set colours to be more readable

#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'term
  (set-face-attribute 'term-color-green   nil :foreground "#55ff55")
  (set-face-attribute 'term-color-blue    nil :foreground "#5555ff")
  (set-face-attribute 'term-color-red     nil :foreground "#ff5555")
  (set-face-attribute 'term-color-magenta nil :foreground "#ff55ff")
  (set-face-attribute 'term-color-cyan    nil :foreground "#ff55ff")
  (set-face-attribute 'term-color-yellow  nil :foreground "#ffff55"))
#+END_SRC

Disable line number mode for term mode.
Requires this hacky double add hook thing because the
global-nlinum-relative-mode hook is run after the term-mode-hook

#+BEGIN_SRC emacs-lisp
(defun setup-term-mode ()
  "Counteract global nlinum mode"
  (add-hook 'after-change-major-mode-hook
            (lambda () (nlinum-mode 0))
            :append :local))

(add-hook 'term-mode-hook 'setup-term-mode)
#+END_SRC

** general

#+BEGIN_SRC emacs-lisp
(add-to-list
 'load-path
 "~/.emacs.d/packages/general-2d2dd1d532fa75c1ed0c010d50e817ce43e58066/")
(require 'general)
(general-auto-unbind-keys)
#+END_SRC

* Keybindings

** P1 Bindings

*** Home

**** Normal

#+BEGIN_SRC emacs-lisp
(general-define-key
 "C-M-:" 'counsel-M-x
 "C-M-?" '((lambda() (interactive)(swiper (ivy-thing-at-point)))
           :which-key "swiper")
 "C-M-S-c" 'delete-window
 "C-M-S-h" 'windmove-left
 "C-M-S-d" 'evil-goto-definition
 "C-M-S-j" 'windmove-down
 "C-M-S-k" 'windmove-up
 "C-M-S-l" 'windmove-right
 "C-M-S-q" 'kill-this-buffer
 "C-M-_" '((lambda () (interactive)(text-scale-adjust -1))
           :which-key "decrease text size")
 "C-M-+" '((lambda () (interactive)(text-scale-adjust +1))
           :which-key "increase text size")
 )
#+END_SRC

**** Ranger

#+BEGIN_SRC emacs-lisp
;;;;; Ranger
(general-define-key
 :keymaps 'ranger-mode-map
 "C-M-S-c" 'ranger-disable
 )
#+END_SRC

**** Erlang

#+BEGIN_SRC emacs-lisp
(general-define-key
 :keymaps 'erlang-mode-map
 "C-M-S-d" '((lambda () (interactive)(erlang-find-tag (erlang-find-tag-default)))
             :which-key "goto erlang definition") ; For some reason, this
                                        ; property is required this keybinding
                                        ; to work
 )
#+END_SRC

*** File / directory related

#+BEGIN_SRC emacs-lisp
(general-create-definer files-leader
 :prefix "C-M-S-f")
#+END_SRC

**** Normal

#+BEGIN_SRC emacs-lisp
(files-leader
 "f" '(counsel-find-file :which-key "find file") ; find file using ivy
 "r" '(counsel-recentf :which-key "find recent file") ; find recently edited
                                        ; files
 "b" '(ivy-switch-buffer :which-key "buffers")
 )
#+END_SRC

**** Org

#+BEGIN_SRC emacs-lisp
(files-leader
 :keymaps 'org-mode-map
 "h" '(org-html-export-to-html :which-key "export to html file")
 )
#+END_SRC

**** Ranger

#+BEGIN_SRC emacs-lisp
(files-leader
 :keymaps 'ranger-mode-map
 "d" '(dired-create-directory :which-key "create directory")
 )
#+END_SRC

**** Neotree

#+BEGIN_SRC emacs-lisp
;;;;; Neotree
(files-leader
 :keymaps 'neotree-mode-map
 "n" '(neotree-create-node :which-key "create directory / file")
 "d" '(neotree-delete-node :which-key "delete directory / file")
 "r" '(neotree-rename-node :which-key "rename directory / file")
 "t" '(neotree-change-root :which-key "change root directory")
 "c" '(neotree-copy-node :which-key "Copy directory / file")
 )
#+END_SRC

*** Motion related

#+BEGIN_SRC emacs-lisp
(general-create-definer motions-leader
 :prefix "C-M-S-m")
#+END_SRC

**** Org and Emacs Lisp

#+BEGIN_SRC emacs-lisp
(motions-leader
 :keymaps '(org-mode-map emacs-lisp-mode-map)
 "k" '(outline-previous-visible-heading :which-key "prev heading")
 "j" '(outline-next-visible-heading :which-key "next heading")
 "h" '(outline-backward-same-level :which-key "prev same level heading")
 "l" '(outline-forward-same-level :which-key "next same level heading")
 "u" '(outline-up-heading :which-key "move up a heading")
 )
#+END_SRC

*** Window related

#+BEGIN_SRC emacs-lisp
(general-create-definer windows-leader
 :prefix "C-M-S-w")
#+END_SRC

**** Normal

#+BEGIN_SRC emacs-lisp
(windows-leader
 "v" 'split-window-below
 "h" 'split-window-right
 "z" 'maximize-window
 "o" 'delete-other-windows
 "e" 'balance-windows
 "r" '(revert-buffer :which-key "reload from disk")
 )
#+END_SRC

**** Neotree

#+BEGIN_SRC emacs-lisp
(windows-leader
 :keymaps 'neotree-mode-map
 "z" '(neotree-stretch-toggle :which-key "maximize tree pane")
 )
#+END_SRC

*** Buffer related

#+BEGIN_SRC emacs-lisp
(general-create-definer buffer-leader
  :prefix "C-M-S-b")
#+END_SRC

**** Normal

#+BEGIN_SRC emacs-lisp
(buffer-leader
 "b" '(ivy-switch-buffer :which-key "switch buffers")
 "o" '(open-in-new-config :which-key "open buffer in a new window config")
 "t" '(:ignore t :which-key "transpose buffers")
 "th" '((lambda () (interactive)(transpose-buffers-left t)) ; weird syntax is
        :which-key "transpose windows left")                ; for calling the
 "tj" '((lambda () (interactive)(transpose-buffers-down t)) ; function with
        :which-key "transpose windows down")                ; arguments
 "tk" '((lambda () (interactive)(transpose-buffers-up t))
        :which-key "transpose windows up")
 "tl" '((lambda () (interactive)(transpose-buffers-right t))
        :which-key "transpose windows right")
 "c" '(:ignore t :which-key "cast buffer")
 "ch" '((lambda () (interactive)(cast-buffer-left t))
        :which-key "cast buffer left")
 "cj" '((lambda () (interactive)(cast-buffer-down t))
        :which-key "cast buffer down")
 "ck" '((lambda () (interactive)(cast-buffer-up t))
        :which-key "cast buffer up")
 "cl" '((lambda () (interactive)(cast-buffer-right t))
        :which-key "cast buffer right")
 "d" '(:ignore t :which-key "duplicate buffer")
 "dh" '((lambda () (interactive)(duplicate-buffer-left t))
        :which-key "duplicate buffer left")
 "dj" '((lambda () (interactive)(duplicate-buffer-down t))
        :which-key "duplicate buffer down")
 "dk" '((lambda () (interactive)(duplicate-buffer-up t))
        :which-key "duplicate buffer up")
 "dl" '((lambda () (interactive)(duplicate-buffer-right t))
        :which-key "duplicate buffer right")
 )
#+END_SRC

*** Toggles

#+BEGIN_SRC emacs-lisp
(general-create-definer toggles-leader
  :prefix "C-M-S-t")
#+END_SRC

**** Normal

#+BEGIN_SRC emacs-lisp
(toggles-leader
 "w" '(whitespace-mode :which-key "toggle whitespace display")
 "W" '(toggle-whitespace-full :which-key "toggle whitespace full")
 "n" '(neotree-toggle :which-key "toggle neotree")
 "p" '(projectile-mode :which-key "toggle projectile mode")
 "f" '(font-lock-mode :which-key "toggle auto font formatting")
 "c" '(comment-line :which-key "comment line")
 "r" '(rainbow-delimiters-mode :which-key "rainbow delimiters")
 "l" '(nlinum-mode :which-key "toggle relative line numbers")
 )
#+END_SRC

**** Org

#+BEGIN_SRC emacs-lisp
(toggles-leader
  :keymaps 'org-mode-map
  "x" '(org-toggle-checkbox :which-key "toggle checkbox")
  "i" '(org-toggle-inline-images :which-key "toggle images")
  "t" '(:ignore t :which-key "todos / tables")
  "ts" '(org-todo :which-key "cycle todo status")
  "tr" '(org-table-toggle-coordinate-overlays
         :which-key "toggle table reference")
  )
#+END_SRC

**** Ranger

#+BEGIN_SRC emacs-lisp
(toggles-leader
  :keymaps 'ranger-mode-map
  "h" '(ranger-toggle-dotfiles :which-key "toggle hidden")
  )
#+END_SRC

**** Neotree

#+BEGIN_SRC emacs-lisp
(toggles-leader
  :keymaps 'neotree-mode-map
  "c" '(neotree-collapse-all :which-key "collapse all")
  "h" '(neotree-hidden-file-toggle :which-key "toggle hidden")
  )
#+END_SRC

*** Specialized edits

#+BEGIN_SRC emacs-lisp
(general-create-definer edits-leader
  :prefix "C-M-S-e")
#+END_SRC

**** Normal
#+BEGIN_SRC emacs-lisp
(edits-leader
 "ah" '(align-once-head :which-key "regex ahead of match")
 "aH" '(align-repeat-head :which-key "regex ahead of match repeatedly")
 "at" '(align-once-tail :which-key "regex to tail of match")
 "aT" '(align-repeat-tail :which-key "regex to tail of match repeatedly")
 )
#+END_SRC

**** Org

#+BEGIN_SRC emacs-lisp
(edits-leader
 :keymaps 'org-mode-map
 "t" '(:ignore t :which-key "tables")
 "tc" '(org-table-create-or-convert-from-region
        :which-key "create / convert table")
 "td" '(:ignore t :which-key "delete")
 "tdc" '(org-table-delete-column :which-key "delete column")
 "tdr" '(org-table-kill-row :whick-key "delete row")
 "ti" '(:ignore t :which-key "insert")
 "tic" '(org-table-insert-column :which-key "insert column")
 "tir" '(org-table-insert-row :which-key "insert row")
 "tih" '(org-table-insert-hline :which-key "insert horizontal line")
 "l" '(org-insert-link :which-key "edit link")
 "s" '(org-sort :which-key "sort")
 "o" '(org-open-at-point :which-key "open link")
 )
#+END_SRC

**** Erlang mode

#+BEGIN_SRC emacs-lisp
(edits-leader
  :keymaps 'erlang-mode-map
  "aa" '(erlang-align-arrows :which-key "align arrows")
  "j" '(erlang-generate-new-clause :which-key "new clause")
  "d" '(erlang-clone-arguments :which-key "duplicate arguments")
  "i" '(erlang-indent-region :which-key "indent region")
  )
#+END_SRC

*** Registers

#+BEGIN_SRC emacs-lisp
(general-create-definer registers-leader
  :prefix "C-M-S-r")
#+END_SRC

**** Normal

#+BEGIN_SRC emacs-lisp
(registers-leader
  "p" '(:ignore t :which-key "positions")
  "py" '(point-to-register :which-key "yank current position to register")
  "pp" '(jump-to-register :which-key "goto register position")
  "t" '(:ignore t :which-key "text")
  "ty" '(copy-to-register :which-key "yank text to register")
  "tp" '(insert-register :which-key "paste text register")
  "ta" '(append-to-register :which-key "append text to register")
  "tb" '(prepend-to-register :which-key "prepend text to register (before)")
  "r" '(:ignore t :which-key "rectangle")
  "ry" '(copy-rectangle-to-register :which-key "yank rectangle to register")
  "rp" '(insert-register :which-key "paste rectangle from register")
  "n" '(:ignore t :which-key "numbers")
  "ny" '(number-to-register :which-key "yank number to register")
  "np" '(insert-register :which-key "paste number from register")
  "ni" '(increment-register :which-key "increment register with number")
 )
#+END_SRC

*** Applications

#+BEGIN_SRC emacs-lisp
(general-create-definer applications-leader
  :prefix "C-M-S-o")
#+END_SRC

**** Normal

#+BEGIN_SRC emacs-lisp
(applications-leader
 "r" '(ranger :which-key "ranger")
 "t" '(:ignore t :which-key "terminals")
 "tt" '((lambda() (interactive)(ansi-term "/bin/bash"))
        :which-key "bash")
 "te" '(erlang-shell :which-key "erlang-shell")
 "tc" '((lambda() (interactive)(ansi-term "/usr/bin/clisp"))
        :which-key "clisp")
 "tp" '((lambda() (interactive)(ansi-term "/usr/bin/python"))
        :which-key "python")
 )
#+END_SRC

*** Version control

#+BEGIN_SRC emacs-lisp
(general-create-definer version-control-leader
  :prefix "C-M-S-v")
#+END_SRC

**** Normal

#+BEGIN_SRC emacs-lisp
(version-control-leader
 "a" '(vc-annotate :which-key "annotate")
 "d" '(vc-diff :which-key "diff") ; Change to vc-ediff if you want
 "b" '(vc-retrieve-tag :which-key "change branch")
 )
#+END_SRC

*** Projects

#+BEGIN_SRC emacs-lisp
(general-create-definer projects-leader
  :prefix "C-M-S-p")
#+END_SRC

**** Normal

#+BEGIN_SRC emacs-lisp
(projects-leader
 "?" '(projectile-command-map :which-key "other")
 "p" '(counsel-projectile-switch-project :which-key "switch project")
 "g" '(counsel-projectile-grep :which-key "find instances in project")
 "f" '(counsel-projectile-find-file :which-key "find project file") ; find file
                                        ; in current project
 "s" '(org-store-link :which-key "copy link")
 "i" '(org-insert-link :which-key "insert link")
 "t" '(regenerate-tags :which-key "regenerate tags")
 "c" '(check-project :whick-key "check / compile project")
 )
#+END_SRC

** P2 Bindings

*** Resize Windows

#+BEGIN_SRC emacs-lisp
(general-define-key
 :states '(normal insert visual operator) ; This is just for demonstration
                                        ; purposes. Just to remind me how to do
                                        ; this.
 :keymaps 'override ; required to override evil-org's C-S-hjkl mappings
 "C-S-h" 'shrink-window-horizontally
 "C-S-j" 'enlarge-window
 "C-S-k" 'shrink-window
 "C-S-l" 'enlarge-window-horizontally
 )
#+END_SRC

** P3 Bindings

*** Eyebrowse

#+BEGIN_SRC emacs-lisp
(general-define-key
 "C-M-1" 'eyebrowse-switch-to-window-config-1
 "C-M-2" 'eyebrowse-switch-to-window-config-2
 "C-M-3" 'eyebrowse-switch-to-window-config-3
 "C-M-4" 'eyebrowse-switch-to-window-config-4
 "C-M-5" 'eyebrowse-switch-to-window-config-5
 "C-M-6" 'eyebrowse-switch-to-window-config-6
 "C-M-7" 'eyebrowse-switch-to-window-config-7
 "C-M-8" 'eyebrowse-switch-to-window-config-8
 "C-M-9" 'eyebrowse-switch-to-window-config-9
 "C-M-<" 'eyebrowse-prev-window-config
 "C-M->" 'eyebrowse-next-window-config
 "C-M-w" 'eyebrowse-last-window-config
 "C-M-h" 'evil-jump-backward
 "C-M-l" 'evil-jump-forward
 )
#+END_SRC

*** Eyebrowse Frames

#+BEGIN_SRC emacs-lisp
(general-create-definer frames-leader
  :prefix "C-M-f")
#+END_SRC

**** Normal

#+BEGIN_SRC emacs-lisp
(frames-leader
 "r" '(eyebrowse-rename-window-config :which-key "rename config")
 "q" '(eyebrowse-close-window-config :which-key "close config")
 "c" '(eyebrowse-create-window-config :which-key "create config")
 "R" '(set-frame-title :which-key "rename frame")
 "o" '(pop-out-config-to-new-frame :which-key "pop out to frame")
 )
#+END_SRC

*** Help overrides

#+BEGIN_SRC emacs-lisp
(general-define-key
 "C-h v" 'counsel-describe-variable
 "C-h f" 'counsel-describe-function
 )
#+END_SRC
